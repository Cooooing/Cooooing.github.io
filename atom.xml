<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>咕咕咕的小破站</title>
  
  
  <link href="https://cooooing.github.io/atom.xml" rel="self"/>
  
  <link href="https://cooooing.github.io/"/>
  <updated>2025-10-23T12:41:49.000Z</updated>
  <id>https://cooooing.github.io/</id>
  
  <author>
    <name>咕咕咕</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>杭州九溪至云栖竹径徒步线</title>
    <link href="https://cooooing.github.io/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E6%9D%AD%E5%B7%9E%E4%B9%9D%E6%BA%AA%E8%87%B3%E4%BA%91%E6%A0%96%E7%AB%B9%E5%BE%84%E5%BE%92%E6%AD%A5%E7%BA%BF/"/>
    <id>https://cooooing.github.io/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E6%9D%AD%E5%B7%9E%E4%B9%9D%E6%BA%AA%E8%87%B3%E4%BA%91%E6%A0%96%E7%AB%B9%E5%BE%84%E5%BE%92%E6%AD%A5%E7%BA%BF/</id>
    <published>2025-10-23T12:41:49.000Z</published>
    <updated>2025-10-23T12:41:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇不止是徒步线的记录，还记录了国庆假期左右的其他，其实分两三篇应该会更好。</p><h3 id="国庆前"><a href="#国庆前" class="headerlink" title="国庆前"></a>国庆前</h3><p>首先国庆和中秋连在一起放了八天假期。<br>公司在节前发了蟹卡（五公五母十只螃蟹）和两个柚子。螃蟹带回家了没有尝到，柚子倒是很不错。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E6%9D%AD%E5%B7%9E%E4%B9%9D%E6%BA%AA%E8%87%B3%E4%BA%91%E6%A0%96%E7%AB%B9%E5%BE%84%E5%BE%92%E6%AD%A5%E7%BA%BF/%E8%9F%B9%E5%8D%A1.jpg"                        alt="蟹卡"                 ></p><h3 id="家"><a href="#家" class="headerlink" title="家"></a>家</h3><p>国庆假期的前几天在家，久违的过年的感觉。只是比过年的人少了很多，没有那么的热闹，但也足够了。<br>和朋友去吃了火锅，六个人吃了不到四百，人均才六十多，不到七十。相比我之前和现在工作的地方真的是便宜太多了。<br>那家火锅店也是很偏僻了，在县城的边边上，旁边就是农田了，对面就是护城河。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E6%9D%AD%E5%B7%9E%E4%B9%9D%E6%BA%AA%E8%87%B3%E4%BA%91%E6%A0%96%E7%AB%B9%E5%BE%84%E5%BE%92%E6%AD%A5%E7%BA%BF/%E7%81%AB%E9%94%85%E5%BA%97.jpg"                        alt="火锅店"                 ></p><p>朋友还跑了两三家药店帮我买药，我跑了几家也没得卖。最后买到了四小瓶。<br>后来朋友妈妈知道了还打电话来和我说，因为朋友舅舅得过这个病，所以她比较了解，给我推荐了别的药。<br>真的非常感谢了。</p><p>去姨妈家吃饭，在门口盆里的鸡胗和肠子还被猫叼跑了。痛失两道菜。<br>一共四只猫，还为了这些吃的打架。<br>对峙吵架中…</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E6%9D%AD%E5%B7%9E%E4%B9%9D%E6%BA%AA%E8%87%B3%E4%BA%91%E6%A0%96%E7%AB%B9%E5%BE%84%E5%BE%92%E6%AD%A5%E7%BA%BF/%E7%8C%AB%E5%92%AA%E5%AF%B9%E5%B3%99.jpg"                        alt="猫咪对峙"                 ></p><p>吃完后就躺在树下的花坛边睡觉，过得真舒服啊。</p><h3 id="徒步"><a href="#徒步" class="headerlink" title="徒步"></a>徒步</h3><p>假期后半程回到杭州，准备和朋友去徒步。<br>计划路线是：九溪公交站 - 九溪烟树 - 九溪十八涧 - 龙井村 - 十里锒铛 - 云栖竹径<br>但是实际上并没有走这条线。</p><p>我俩在九溪公交站会合，这里可以看到钱塘江：</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E6%9D%AD%E5%B7%9E%E4%B9%9D%E6%BA%AA%E8%87%B3%E4%BA%91%E6%A0%96%E7%AB%B9%E5%BE%84%E5%BE%92%E6%AD%A5%E7%BA%BF/%E4%B9%9D%E6%BA%AA%E5%85%AC%E4%BA%A4%E7%AB%99.jpg"                        alt="九溪公交站"                 ></p><p>到了之后，就开始向里进发。应该是沿着小溪一路向上，不多久就可以到九溪烟树。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E6%9D%AD%E5%B7%9E%E4%B9%9D%E6%BA%AA%E8%87%B3%E4%BA%91%E6%A0%96%E7%AB%B9%E5%BE%84%E5%BE%92%E6%AD%A5%E7%BA%BF/%E4%B9%9D%E6%BA%AA%E7%83%9F%E6%A0%911.jpg"                        alt="九溪烟树1"                 ><br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E6%9D%AD%E5%B7%9E%E4%B9%9D%E6%BA%AA%E8%87%B3%E4%BA%91%E6%A0%96%E7%AB%B9%E5%BE%84%E5%BE%92%E6%AD%A5%E7%BA%BF/%E4%B9%9D%E6%BA%AA%E7%83%9F%E6%A0%912.jpg"                        alt="九溪烟树2"                 ></p><p>再往后，一路上都能碰到各种小溪。喜欢玩水的人会非常开心了，大热天玩水也是很舒服。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E6%9D%AD%E5%B7%9E%E4%B9%9D%E6%BA%AA%E8%87%B3%E4%BA%91%E6%A0%96%E7%AB%B9%E5%BE%84%E5%BE%92%E6%AD%A5%E7%BA%BF/%E5%B0%8F%E6%BA%AA1.jpg"                        alt="小溪1"                 ><br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E6%9D%AD%E5%B7%9E%E4%B9%9D%E6%BA%AA%E8%87%B3%E4%BA%91%E6%A0%96%E7%AB%B9%E5%BE%84%E5%BE%92%E6%AD%A5%E7%BA%BF/%E5%B0%8F%E6%BA%AA2.jpg"                        alt="小溪2"                 ></p><p>然后就是龙井村，这里的每家每户好像都卖茶叶。<br>这里商业化不是非常严重，每家都是独栋建筑，有些巷子可以看到别人家的院子，有些在路边会有弄得很好看的花园。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E6%9D%AD%E5%B7%9E%E4%B9%9D%E6%BA%AA%E8%87%B3%E4%BA%91%E6%A0%96%E7%AB%B9%E5%BE%84%E5%BE%92%E6%AD%A5%E7%BA%BF/%E9%BE%99%E4%BA%95%E6%9D%91.jpg"                        alt="龙井村"                 ></p><p>在龙井村这里，我们偏离了原定路线。准备接着向北走，去法喜寺尝下素斋。<br>此时已经下午快一点，除了路上带的几瓶水，两块面包和几块巧克力，我们没吃别的。（饿啊<br>但后面是上山的路，也是最难走的。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E6%9D%AD%E5%B7%9E%E4%B9%9D%E6%BA%AA%E8%87%B3%E4%BA%91%E6%A0%96%E7%AB%B9%E5%BE%84%E5%BE%92%E6%AD%A5%E7%BA%BF/%E8%8C%B6%E7%94%B01.jpg"                        alt="茶田1"                 ><br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E6%9D%AD%E5%B7%9E%E4%B9%9D%E6%BA%AA%E8%87%B3%E4%BA%91%E6%A0%96%E7%AB%B9%E5%BE%84%E5%BE%92%E6%AD%A5%E7%BA%BF/%E8%8C%B6%E7%94%B02.jpg"                        alt="茶田2"                 ></p><p>接着爬到山顶，有个三叉还是四岔路，往法喜寺的方向是下山的方向。一路上都是树荫遮蔽，比上山的茶田一路上晒过来要好了很多。<br>出了树林，有一段很长很长的下坡，坡度很大。没有阶梯，纯坡。看着护林员骑着电动车走大S线骑上来…</p><p>下山后，到法喜寺。进门每人给了三柱香。（朋友说他是党员，所以我有了六柱<br>寺门口有很多人在摸字。<br>寺里的锦鲤很多很好看。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E6%9D%AD%E5%B7%9E%E4%B9%9D%E6%BA%AA%E8%87%B3%E4%BA%91%E6%A0%96%E7%AB%B9%E5%BE%84%E5%BE%92%E6%AD%A5%E7%BA%BF/%E6%B3%95%E5%96%9C%E5%AF%BA1.jpg"                        alt="法喜寺1"                 ><br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E6%9D%AD%E5%B7%9E%E4%B9%9D%E6%BA%AA%E8%87%B3%E4%BA%91%E6%A0%96%E7%AB%B9%E5%BE%84%E5%BE%92%E6%AD%A5%E7%BA%BF/%E6%B3%95%E5%96%9C%E5%AF%BA2.jpg"                        alt="法喜寺2"                 ><br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E6%9D%AD%E5%B7%9E%E4%B9%9D%E6%BA%AA%E8%87%B3%E4%BA%91%E6%A0%96%E7%AB%B9%E5%BE%84%E5%BE%92%E6%AD%A5%E7%BA%BF/%E6%B3%95%E5%96%9C%E5%AF%BA3.jpg"                        alt="法喜寺3"                 ></p><p>在法喜寺休息了很久，有大麦茶和菊花茶。<br>可惜的是因为在修缮的原因，没有吃到素斋。</p><p>不过出了寺庙之后，去吃了一家素食自主，是今天的第一顿饭了。此时已经四点了大概（有点难崩，不过吃了三碗</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E6%9D%AD%E5%B7%9E%E4%B9%9D%E6%BA%AA%E8%87%B3%E4%BA%91%E6%A0%96%E7%AB%B9%E5%BE%84%E5%BE%92%E6%AD%A5%E7%BA%BF/%E7%B4%A0%E6%96%8B.jpg"                        alt="素斋"                 ></p><p>最后迎着夕阳去往公交站，准备坐公交去云栖竹径（他说是不能忘记最开始的目标</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E6%9D%AD%E5%B7%9E%E4%B9%9D%E6%BA%AA%E8%87%B3%E4%BA%91%E6%A0%96%E7%AB%B9%E5%BE%84%E5%BE%92%E6%AD%A5%E7%BA%BF/%E5%A4%95%E9%98%B3.jpg"                        alt="夕阳"                 ></p><p>公交等了很久很久，324H线！<br>等车的时候，遇到了一家印度人（应该是印度人，非常经典的印度形象）。应该是老父亲，他的英语和中文说的都不错，和他儿子交流是他们自己的语言。<br>大概聊了一些。</p><p>等坐上公交，到达云栖竹径时，已经七点了，天已经黑了。<br>然后云栖竹径关门了！很遗憾，只能回家了。</p><p>遗憾也是常态，不按计划、随心而动的旅途才是放松身心的旅游。相遇是缘，不遇也是。<br>没有赶进度的计划，没有被时间追着跑。能在公交站等一个小时的公交，和遇到印度人聊聊天也不错，不是吗。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇不止是徒步线的记录，还记录了国庆假期左右的其他，其实分两三篇应该会更好。&lt;/p&gt;
&lt;h3 id=&quot;国庆前&quot;&gt;&lt;a href=&quot;#国庆前&quot; class=&quot;headerlink&quot; title=&quot;国庆前&quot;&gt;&lt;/a&gt;国庆前&lt;/h3&gt;&lt;p&gt;首先国庆和中秋连在一起放了八天假期。&lt;</summary>
      
    
    
    
    <category term="记录生活" scheme="https://cooooing.github.io/categories/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="旅游" scheme="https://cooooing.github.io/tags/%E6%97%85%E6%B8%B8/"/>
    
    <category term="西湖" scheme="https://cooooing.github.io/tags/%E8%A5%BF%E6%B9%96/"/>
    
    <category term="法喜寺" scheme="https://cooooing.github.io/tags/%E6%B3%95%E5%96%9C%E5%AF%BA/"/>
    
  </entry>
  
  <entry>
    <title>ArchLinux安装</title>
    <link href="https://cooooing.github.io/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/ArchLinux%E5%AE%89%E8%A3%85/"/>
    <id>https://cooooing.github.io/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/ArchLinux%E5%AE%89%E8%A3%85/</id>
    <published>2025-09-21T14:38:38.000Z</published>
    <updated>2025-09-21T14:38:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Ubuntu、Deepin之类的玩腻了，尝试下新鲜玩意。<br>最开始在旧电脑上尝试直接安装，但是失败了，很多报错，现在看来是镜像源的问题。<br>然后尝试在 Hyper-V 虚拟机中安装，过程很顺利，基本没有问题。<br>最后再次尝试在旧电脑物理机上安装，有了虚拟机的经验，安装也比较顺利。<br><strong>唯一失败的就是：分区时没注意磁盘，将分区信息写到了系统u盘，导致u盘数据丢失。惨痛的教训 <code>lsblk</code> 或者 <code>fdisk -l</code> 很重要！</strong></p><h2 id="安装-Arch-Linux-系统"><a href="#安装-Arch-Linux-系统" class="headerlink" title="安装 Arch Linux 系统"></a>安装 Arch Linux 系统</h2><p>首先进入 Arch Live 环境（archiso），是官方 ISO 引导后的安装环境。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Arch Linux 6.15.8-arch1-2 (tty1)</span><br><span class="line"></span><br><span class="line">archiso login:root (automatic login)</span><br><span class="line"></span><br><span class="line">To install Arch Linux follow the installation guide:</span><br><span class="line">https://wiki.archlinux.org/title/Installation_guide</span><br><span class="line"></span><br><span class="line">For Wi-Fi,authenticate to the wireless network using the iwctl utility.</span><br><span class="line">For mobile broadband (WWAN) modems,comnect with the mmcli utility.</span><br><span class="line">Ethernet,WLAN and WWAN interfaces using DHCP should work automatically.</span><br><span class="line"></span><br><span class="line">After comnecting to the internet,the installation guide can be accessed</span><br><span class="line">via the convenience script Installation_guide.</span><br><span class="line"></span><br><span class="line">root@archiso ~ #</span><br></pre></td></tr></table></figure><h3 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h3><p><code>ping archlinux.org -c 3</code> 确认是否有网络</p><p>如果是有线网络，通常自动就有网络。如果是 WIFI ，使用 <code>iwctl</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iwctl</span><br><span class="line"><span class="comment"># 交互模式下（示例）</span></span><br><span class="line">device list</span><br><span class="line">station wlan0 scan</span><br><span class="line">station wlan0 get-networks</span><br><span class="line">station wlan0 connect YOUR_SSID</span><br><span class="line">station list <span class="comment"># 用于查看连接状态</span></span><br><span class="line"><span class="comment"># exit 返回</span></span><br></pre></td></tr></table></figure><h3 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h3><p><code>ls /sys/firmware/efi/efivars</code> 用于输出 <strong>EFI 变量</strong>，区分启动模式是 BIOS 还是 UEFI。</p><ul><li>BIOS 启动：内核只会得到传统的硬件初始化信息，不会加载 EFI 相关功能。</li><li>UEFI 启动：内核会通过 UEFI 固件接口（EFI Runtime Services）获得一系列 EFI 变量（比如引导顺序、启动项、安全启动开关等）。Linux 内核会把这些变量暴露在文件系统里，就是 <code>/sys/firmware/efi/efivars</code>。</li></ul><p>所以 UEFI 启动必须有一个 <strong>EFI 分区 (ESP)</strong>，格式化为 FAT32，挂载到 <code>/boot</code> 或 <code>/boot/efi</code>。</p><h4 id="BIOS-与-UEFI"><a href="#BIOS-与-UEFI" class="headerlink" title="BIOS 与 UEFI"></a>BIOS 与 UEFI</h4><p>BIOS：</p><ul><li>历史悠久：BIOS（Basic Input&#x2F;Output System）是上世纪 80 年代就有的固件。</li><li>分区表限制：BIOS 通常和 <strong>MBR 分区表</strong>搭配使用。MBR 最大只支持 <strong>2TB 硬盘容量</strong>，最多 4 个主分区。</li><li>启动方式：BIOS 启动时，会从磁盘开头的 <strong>MBR (Master Boot Record)</strong> 读取引导代码，然后加载操作系统。</li><li>兼容性好：老机器几乎都是 BIOS，新机器大多支持兼容模式（CSM），可以让 BIOS 模式继续使用。</li></ul><p>UEFI：</p><ul><li>现代标准：UEFI（Unified Extensible Firmware Interface）是 BIOS 的替代品，大多数 2015 年以后的电脑默认用 UEFI。</li><li>分区表支持：UEFI 通常和 <strong>GPT 分区表</strong>搭配。GPT 支持 <strong>&gt;2TB 的硬盘</strong>，分区数量几乎无限制。</li><li>启动方式：UEFI 会读取硬盘上的 <strong>EFI 系统分区 (ESP)</strong>，里面存放引导程序（例如 <code>grubx64.efi</code> 或 <code>systemd-boot</code>）。</li><li>功能更强：支持图形界面、鼠标操作、安全启动（Secure Boot）、多系统管理更方便。</li></ul><h3 id="分区设置"><a href="#分区设置" class="headerlink" title="分区设置"></a>分区设置</h3><p><strong>一定注意分区设置的位置！</strong><br><strong>事先使用 <code>lsblk</code> 或者 <code>fdisk -l</code> 命令查看磁盘信息，确定分区位置。</strong></p><h4 id="创建分区"><a href="#创建分区" class="headerlink" title="创建分区"></a>创建分区</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sda</span><br></pre></td></tr></table></figure><p>然后依次输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">g                   # 创建 GPT 分区表</span><br><span class="line"></span><br><span class="line">n                   # 新建分区 1</span><br><span class="line">&lt;回车&gt;              # 分区号，直接回车（默认 1）</span><br><span class="line">&lt;回车&gt;              # 起始扇区，直接回车（默认）</span><br><span class="line">+512M               # 结束扇区，输入大小 → +512M</span><br><span class="line">t                   # 改类型</span><br><span class="line">1                   # 选择分区 1</span><br><span class="line">1                   # 设置为 EFI System</span><br><span class="line"></span><br><span class="line">n                   # 新建分区 2</span><br><span class="line">&lt;回车&gt;              # 分区号，直接回车（默认 2）</span><br><span class="line">&lt;回车&gt;              # 起始扇区，直接回车</span><br><span class="line">+2G                 # 结束扇区，输入大小 → +2G</span><br><span class="line">t                   # 改类型</span><br><span class="line">2                   # 选择分区 2</span><br><span class="line">19                  # 设置为 Linux swap</span><br><span class="line"></span><br><span class="line">n                   # 新建分区 3</span><br><span class="line">&lt;回车&gt;              # 分区号，直接回车（默认 3）</span><br><span class="line">&lt;回车&gt;              # 起始扇区，直接回车</span><br><span class="line">&lt;回车&gt;              # 结束扇区，直接回车（用完剩余空间）</span><br><span class="line"></span><br><span class="line">w                   # 保存并退出</span><br></pre></td></tr></table></figure><h4 id="格式化分区"><a href="#格式化分区" class="headerlink" title="格式化分区"></a>格式化分区</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># EFI 分区</span></span><br><span class="line">mkfs.fat -F32 /dev/sda1</span><br><span class="line"></span><br><span class="line"><span class="comment"># swap 分区</span></span><br><span class="line">mkswap /dev/sda2</span><br><span class="line">swapon /dev/sda2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根分区</span></span><br><span class="line">mkfs.ext4 /dev/sda3</span><br></pre></td></tr></table></figure><h4 id="挂载分区"><a href="#挂载分区" class="headerlink" title="挂载分区"></a>挂载分区</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sda3 /mnt</span><br><span class="line"><span class="built_in">mkdir</span> -p /mnt/boot</span><br><span class="line">mount /dev/sda1 /mnt/boot</span><br></pre></td></tr></table></figure><h3 id="配置镜像源（可选）"><a href="#配置镜像源（可选）" class="headerlink" title="配置镜像源（可选）"></a>配置镜像源（可选）</h3><ol><li>临时使用国内镜像<br>在 live 环境里，修改 pacman 的镜像源列表： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先备份原来的</span></span><br><span class="line"><span class="built_in">cp</span> /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.bak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑镜像列表</span></span><br><span class="line">nano /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure>把国内源放到前面，例如： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch</span><br><span class="line">Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch</span><br><span class="line">Server = https://mirrors.aliyun.com/archlinux/$repo/os/$arch</span><br></pre></td></tr></table></figure><blockquote><p>注意：把想用的镜像放在 <strong>最上面</strong>，pacman 会优先使用。<br>保存退出后，运行：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Syyu</span><br></pre></td></tr></table></figure></p></blockquote></li><li>选择最快的镜像<br>Arch 自带 <code>reflector</code> 工具（Live ISO 可能没有，需要先安装）： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman -Sy reflector --noconfirm</span><br><span class="line">reflector --country China --latest 5 --<span class="built_in">sort</span> rate --save /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure>会自动选择最近最快的中国镜像。</li></ol><h3 id="安装基础系统"><a href="#安装基础系统" class="headerlink" title="安装基础系统"></a>安装基础系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt base linux linux-firmware vim nano networkmanager</span><br></pre></td></tr></table></figure><p>安装完成后生成 fstab：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure><p>然后进入新系统环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt</span><br></pre></td></tr></table></figure><h2 id="安装并配置-bootloader（UEFI-推荐-GRUB-或-systemd-boot）"><a href="#安装并配置-bootloader（UEFI-推荐-GRUB-或-systemd-boot）" class="headerlink" title="安装并配置 bootloader（UEFI 推荐 GRUB 或 systemd-boot）"></a>安装并配置 bootloader（<strong>UEFI 推荐 GRUB 或 systemd-boot</strong>）</h2><h4 id="使用-GRUB（UEFI）"><a href="#使用-GRUB（UEFI）" class="headerlink" title="使用 GRUB（UEFI）"></a>使用 GRUB（UEFI）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -S --noconfirm grub efibootmgr dosfstools os-prober mtools</span><br><span class="line">grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB</span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><h4 id="使用-GRUB（BIOS）"><a href="#使用-GRUB（BIOS）" class="headerlink" title="使用 GRUB（BIOS）"></a>使用 GRUB（BIOS）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -S --noconfirm grub</span><br><span class="line">grub-install --target=i386-pc /dev/sda   <span class="comment"># 注意写在磁盘（如 /dev/sda），不是分区</span></span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><h3 id="系统其余配置"><a href="#系统其余配置" class="headerlink" title="系统其余配置"></a>系统其余配置</h3><ol><li>时区： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Taipei /etc/localtime</span><br><span class="line">hwclock --systohc</span><br></pre></td></tr></table></figure></li><li>本地化（示例同时启用 zh_CN.UTF-8 与 en_US.UTF-8）： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/^#zh_CN.UTF-8/zh_CN.UTF-8/&#x27;</span> /etc/locale.gen</span><br><span class="line">sed -i <span class="string">&#x27;s/^#en_US.UTF-8/en_US.UTF-8/&#x27;</span> /etc/locale.gen</span><br><span class="line">locale-gen</span><br><span class="line"><span class="built_in">echo</span> LANG=zh_CN.UTF-8 &gt; /etc/locale.conf</span><br><span class="line"><span class="built_in">echo</span> KEYMAP=us &gt; /etc/vconsole.conf   <span class="comment"># 如需中文控制台可改为 zh_CN</span></span><br></pre></td></tr></table></figure></li><li>主机名与 hosts： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="built_in">arch</span> &gt; /etc/hostname</span><br><span class="line"><span class="built_in">cat</span> &gt;&gt; /etc/hosts &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">127.0.0.1localhost</span></span><br><span class="line"><span class="string">::1    localhost</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure></li><li>root 密码： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure></li></ol><h3 id="安装-ssh-服务"><a href="#安装-ssh-服务" class="headerlink" title="安装 ssh 服务"></a>安装 ssh 服务</h3><p><code>sudo pacman -S --noconfirm openssh</code><br><code>sudo systemctl enable sshd</code><br><code>sudo systemctl start sshd</code></p><p>记得编辑<code>/etc/ssh/sshd_config</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PasswordAuthentication yes   # 允许密码登录</span><br><span class="line">PermitRootLogin yes          # 如果你用 root 登录（可选）</span><br><span class="line">UsePAM yes                   # 必须启用 PAM</span><br></pre></td></tr></table></figure><p><code>sudo systemctl restart sshd</code></p><h2 id="安装-KDE-桌面环境"><a href="#安装-KDE-桌面环境" class="headerlink" title="安装 KDE 桌面环境"></a>安装 KDE 桌面环境</h2><p><code>sudo pacman -Syu</code> 更新系统<br><code>sudo pacman -S --noconfirm xorg</code> 安装 Xorg（显示服务器）</p><p>安装 KDE Plasma 桌面和常用应用：</p><ul><li><code>sudo pacman -S --noconfirm plasma kde-system-meta kde-utilities-meta</code> 最小化安装，比较轻量</li><li><code>sudo pacman -S --noconfirm plasma kde-applications</code> 完整安装（含所有 KDE 应用，比如浏览器、相册、邮件客户端等）</li></ul><p>安装登录管理器（推荐 SDDM）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S --noconfirm sddm</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> sddm</span><br></pre></td></tr></table></figure><p><code>sudo pacman -S noto-fonts noto-fonts-cjk noto-fonts-emoji adobe-source-han-sans-cn-fonts adobe-source-han-serif-cn-fonts</code> 安装 KDE 常用中文字体</p><p>手动指定QT环境变量，在 <code>~/.xprofile</code> 或 <code>~/.bashrc</code> 里加上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LANG=zh_CN.UTF-8</span><br><span class="line"><span class="built_in">export</span> LC_ALL=zh_CN.UTF-8</span><br><span class="line"><span class="built_in">export</span> QT_QPA_PLATFORMTHEME=kde</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Ubuntu、Deepin之类的玩腻了，尝试下新鲜玩意。&lt;br&gt;最开始在旧电脑上尝试直接安装，但是失败了，很多报错，现在看来是镜像源的问题。</summary>
      
    
    
    
    <category term="编程记录" scheme="https://cooooing.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Arch Linux" scheme="https://cooooing.github.io/tags/Arch-Linux/"/>
    
  </entry>
  
  <entry>
    <title>Go内置时间常量格式（time包）对照表</title>
    <link href="https://cooooing.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Go%E5%86%85%E7%BD%AE%E6%97%B6%E9%97%B4%E5%B8%B8%E9%87%8F%E6%A0%BC%E5%BC%8F%EF%BC%88time%E5%8C%85%EF%BC%89%E5%AF%B9%E7%85%A7%E8%A1%A8/"/>
    <id>https://cooooing.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Go%E5%86%85%E7%BD%AE%E6%97%B6%E9%97%B4%E5%B8%B8%E9%87%8F%E6%A0%BC%E5%BC%8F%EF%BC%88time%E5%8C%85%EF%BC%89%E5%AF%B9%E7%85%A7%E8%A1%A8/</id>
    <published>2025-09-06T05:43:56.000Z</published>
    <updated>2025-09-06T05:43:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go-时间布局格式"><a href="#Go-时间布局格式" class="headerlink" title="Go 时间布局格式"></a>Go 时间布局格式</h2><p>Go 使用 <strong>参考时间</strong> <code>Mon Jan 2 15:04:05 MST 2006</code> 来定义格式，而不是像 C 语言或 Python 的 <code>%Y %m %d</code>。</p><table><thead><tr><th>类型</th><th>标记</th><th>含义</th><th>示例（参考时间 2025-09-06 11:45:05.123456789）</th><th>注意事项</th></tr></thead><tbody><tr><td><strong>年</strong></td><td><code>2006</code></td><td>四位年份</td><td><code>2025</code></td><td>常用于完整年份显示</td></tr><tr><td></td><td><code>06</code></td><td>两位年份</td><td><code>25</code></td><td>适合老式格式或节省字符</td></tr><tr><td><strong>月</strong></td><td><code>01</code></td><td>两位数字月份</td><td><code>09</code></td><td>0 填充</td></tr><tr><td></td><td><code>1</code></td><td>数字月份（无前导零）</td><td><code>9</code></td><td>方便简写</td></tr><tr><td></td><td><code>Jan</code></td><td>英文缩写月份</td><td><code>Sep</code></td><td>三个字母英文缩写</td></tr><tr><td></td><td><code>January</code></td><td>英文全称月份</td><td><code>September</code></td><td>更易读，长度可变</td></tr><tr><td><strong>日</strong></td><td><code>02</code></td><td>两位数字日</td><td><code>06</code></td><td>0 填充</td></tr><tr><td></td><td><code>_2</code></td><td>空格填充日</td><td><code> 6</code></td><td>用于对齐，日&lt;10时左侧空格</td></tr><tr><td><strong>小时</strong></td><td><code>15</code></td><td>24 小时制</td><td><code>11</code></td><td>0-23</td></tr><tr><td></td><td><code>03</code></td><td>12 小时制</td><td><code>11</code></td><td>0-12，0 会显示为 12</td></tr><tr><td></td><td><code>3</code></td><td>12 小时制，无前导零</td><td><code>11</code></td><td>0-12</td></tr><tr><td><strong>分钟&#x2F;秒</strong></td><td><code>04</code></td><td>分钟</td><td><code>45</code></td><td>两位数字</td></tr><tr><td></td><td><code>05</code></td><td>秒</td><td><code>05</code></td><td>两位数字</td></tr><tr><td><strong>上下午</strong></td><td><code>PM</code></td><td>大写 AM&#x2F;PM</td><td><code>AM</code></td><td>12 小时制，区分大小写</td></tr><tr><td></td><td><code>pm</code></td><td>小写 am&#x2F;pm</td><td><code>am</code></td><td>12 小时制，区分大小写</td></tr><tr><td><strong>时区</strong></td><td><code>MST</code></td><td>时区缩写</td><td><code>SGT</code> &#x2F; <code>CST</code> &#x2F; <code>UTC</code></td><td>受系统时区影响，可能有歧义</td></tr><tr><td></td><td><code>-0700</code></td><td>数值时区偏移（无冒号）</td><td><code>+0800</code></td><td>可解析性高，推荐用于存储&#x2F;传输</td></tr><tr><td></td><td><code>Z07:00</code></td><td>数值时区偏移（含冒号）</td><td><code>+08:00</code> 或 <code>Z</code>（UTC）</td><td>RFC3339 常用</td></tr><tr><td><strong>引号</strong></td><td><code>&#39;...&#39;</code></td><td>单引号内内容按字面量输出</td><td><code>&quot;&#39;06&quot;</code> → <code>&#39;25</code></td><td>可在格式中插入固定字符</td></tr><tr><td><strong>小数秒</strong></td><td><code>.000</code></td><td>毫秒</td><td><code>.123</code></td><td>固定 3 位小数</td></tr><tr><td></td><td><code>.000000</code></td><td>微秒</td><td><code>.123456</code></td><td>固定 6 位小数</td></tr><tr><td></td><td><code>.000000000</code></td><td>纳秒</td><td><code>.123456789</code></td><td>固定 9 位小数</td></tr><tr><td><strong>星期</strong></td><td><code>Mon</code></td><td>英文缩写星期</td><td><code>Sat</code></td><td>三个字母</td></tr><tr><td></td><td><code>Monday</code></td><td>英文全称星期</td><td><code>Saturday</code></td><td>适合全名显示</td></tr><tr><td><strong>其他符号</strong></td><td><code>T</code></td><td>ISO 8601 中的时间分隔符</td><td><code>T</code></td><td>直接输出字母 T</td></tr><tr><td></td><td><code>-</code> <code>/</code> <code>:</code> <code> </code></td><td>直接输出</td><td><code>-</code>、<code>/</code>、<code>:</code></td><td>可以自由组合布局</td></tr></tbody></table><p>注意事项</p><ol><li><strong>空格填充 vs 零填充</strong>：<ul><li><code>_2</code> → 空格填充的日，<code>02</code> → 零填充。</li></ul></li><li><strong>时区选择</strong>：<ul><li><code>MST</code> → 缩写，易读但解析可能歧义。</li><li><code>-0700</code>&#x2F;<code>Z07:00</code> → 数值偏移，更标准、更安全。</li></ul></li><li><strong>12 小时制 vs 24 小时制</strong>：<ul><li><code>3</code>&#x2F;<code>03</code> → 12 小时制，配合 <code>PM</code>&#x2F;<code>pm</code>。</li><li><code>15</code> → 24 小时制。</li></ul></li><li><strong>小数秒</strong>：<ul><li><code>StampMilli</code> &#x2F; <code>StampMicro</code> &#x2F; <code>StampNano</code> 都基于 <code>.000</code>&#x2F;<code>.000000</code>&#x2F;<code>.000000000</code>。</li></ul></li></ol><h2 id="Go-time-包时间格式常量"><a href="#Go-time-包时间格式常量" class="headerlink" title="Go time 包时间格式常量"></a>Go time 包时间格式常量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Layout      = <span class="string">&quot;01/02 03:04:05PM &#x27;06 -0700&quot;</span> <span class="comment">// The reference time, in numerical order.</span></span><br><span class="line">ANSIC       = <span class="string">&quot;Mon Jan _2 15:04:05 2006&quot;</span></span><br><span class="line">UnixDate    = <span class="string">&quot;Mon Jan _2 15:04:05 MST 2006&quot;</span></span><br><span class="line">RubyDate    = <span class="string">&quot;Mon Jan 02 15:04:05 -0700 2006&quot;</span></span><br><span class="line">RFC822      = <span class="string">&quot;02 Jan 06 15:04 MST&quot;</span></span><br><span class="line">RFC822Z     = <span class="string">&quot;02 Jan 06 15:04 -0700&quot;</span> <span class="comment">// RFC822 with numeric zone</span></span><br><span class="line">RFC850      = <span class="string">&quot;Monday, 02-Jan-06 15:04:05 MST&quot;</span></span><br><span class="line">RFC1123     = <span class="string">&quot;Mon, 02 Jan 2006 15:04:05 MST&quot;</span></span><br><span class="line">RFC1123Z    = <span class="string">&quot;Mon, 02 Jan 2006 15:04:05 -0700&quot;</span> <span class="comment">// RFC1123 with numeric zone</span></span><br><span class="line">RFC3339     = <span class="string">&quot;2006-01-02T15:04:05Z07:00&quot;</span></span><br><span class="line">RFC3339Nano = <span class="string">&quot;2006-01-02T15:04:05.999999999Z07:00&quot;</span></span><br><span class="line">Kitchen     = <span class="string">&quot;3:04PM&quot;</span></span><br><span class="line"><span class="comment">// Handy time stamps.</span></span><br><span class="line">Stamp      = <span class="string">&quot;Jan _2 15:04:05&quot;</span></span><br><span class="line">StampMilli = <span class="string">&quot;Jan _2 15:04:05.000&quot;</span></span><br><span class="line">StampMicro = <span class="string">&quot;Jan _2 15:04:05.000000&quot;</span></span><br><span class="line">StampNano  = <span class="string">&quot;Jan _2 15:04:05.000000000&quot;</span></span><br><span class="line">DateTime   = <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line">DateOnly   = <span class="string">&quot;2006-01-02&quot;</span></span><br><span class="line">TimeOnly   = <span class="string">&quot;15:04:05&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Go-time-包时间格式常量对照表"><a href="#Go-time-包时间格式常量对照表" class="headerlink" title="Go time 包时间格式常量对照表"></a>Go time 包时间格式常量对照表</h2><table><thead><tr><th>名称</th><th>布局字符串</th><th>示例输出（2025-09-06 11:45:05 +08:00）</th><th>典型用途</th><th>注意事项</th></tr></thead><tbody><tr><td><strong>Layout</strong></td><td><code>01/02 03:04:05PM &#39;06 -0700</code></td><td><code>09/06 11:45:05AM &#39;25 +0800</code></td><td>Go 的参考布局示例，展示格式规则</td><td>实际项目中较少直接使用</td></tr><tr><td><strong>ANSIC</strong></td><td><code>Mon Jan _2 15:04:05 2006</code></td><td><code>Sat Sep  6 11:45:05 2025</code></td><td>类 Unix 日志&#x2F;老式系统</td><td><code>_2</code> 表示空格填充日期</td></tr><tr><td><strong>UnixDate</strong></td><td><code>Mon Jan _2 15:04:05 MST 2006</code></td><td><code>Sat Sep  6 11:45:05 SGT 2025</code></td><td>类 Unix 日期（带时区缩写）</td><td><code>MST</code> 会替换为实际时区缩写，可能有歧义</td></tr><tr><td><strong>RubyDate</strong></td><td><code>Mon Jan 02 15:04:05 -0700 2006</code></td><td><code>Sat Sep 06 11:45:05 +0800 2025</code></td><td>Ruby 默认日期格式</td><td>使用数值时区，无歧义</td></tr><tr><td><strong>RFC822</strong></td><td><code>02 Jan 06 15:04 MST</code></td><td><code>06 Sep 25 11:45 SGT</code></td><td>老邮件标准</td><td>两位年份+时区缩写，解析不安全</td></tr><tr><td><strong>RFC822Z</strong></td><td><code>02 Jan 06 15:04 -0700</code></td><td><code>06 Sep 25 11:45 +0800</code></td><td>RFC822 数值时区版</td><td>优于 RFC822，推荐</td></tr><tr><td><strong>RFC850</strong></td><td><code>Monday, 02-Jan-06 15:04:05 MST</code></td><td><code>Saturday, 06-Sep-25 11:45:05 SGT</code></td><td>早期 HTTP&#x2F;邮件日期</td><td>已过时</td></tr><tr><td><strong>RFC1123</strong></td><td><code>Mon, 02 Jan 2006 15:04:05 MST</code></td><td><code>Sat, 06 Sep 2025 11:45:05 SGT</code></td><td>HTTP-date（旧版）</td><td>通常用 <code>GMT</code>，时区缩写有歧义</td></tr><tr><td><strong>RFC1123Z</strong></td><td><code>Mon, 02 Jan 2006 15:04:05 -0700</code></td><td><code>Sat, 06 Sep 2025 11:45:05 +0800</code></td><td>HTTP-date（推荐版）</td><td>更精确，兼容性好</td></tr><tr><td><strong>RFC3339</strong></td><td><code>2006-01-02T15:04:05Z07:00</code></td><td><code>2025-09-06T11:45:05+08:00</code></td><td>JSON &#x2F; API 常用</td><td>UTC 时输出 <code>Z</code>，否则 <code>+HH:MM</code></td></tr><tr><td><strong>RFC3339Nano</strong></td><td><code>2006-01-02T15:04:05.999999999Z07:00</code></td><td><code>2025-09-06T11:45:05.123456789+08:00</code></td><td>高精度 API 日志</td><td>输出到纳秒，0 的处理依版本不同</td></tr><tr><td><strong>Kitchen</strong></td><td><code>3:04PM</code></td><td><code>11:45AM</code></td><td>简洁 UI 时间显示</td><td>无秒、无日期</td></tr><tr><td><strong>Stamp</strong></td><td><code>Jan _2 15:04:05</code></td><td><code>Sep  6 11:45:05</code></td><td>简洁日志时间戳</td><td>无年、无时区</td></tr><tr><td><strong>StampMilli</strong></td><td><code>Jan _2 15:04:05.000</code></td><td><code>Sep  6 11:45:05.000</code></td><td>日志，带毫秒</td><td>固定 3 位小数</td></tr><tr><td><strong>StampMicro</strong></td><td><code>Jan _2 15:04:05.000000</code></td><td><code>Sep  6 11:45:05.000000</code></td><td>日志，带微秒</td><td>固定 6 位小数</td></tr><tr><td><strong>StampNano</strong></td><td><code>Jan _2 15:04:05.000000000</code></td><td><code>Sep  6 11:45:05.000000000</code></td><td>日志，带纳秒</td><td>固定 9 位小数</td></tr><tr><td><strong>DateTime</strong></td><td><code>2006-01-02 15:04:05</code></td><td><code>2025-09-06 11:45:05</code></td><td>数据库&#x2F;日志常用</td><td>无时区，解析时需额外设定</td></tr><tr><td><strong>DateOnly</strong></td><td><code>2006-01-02</code></td><td><code>2025-09-06</code></td><td>仅日期字段</td><td>常见于表单、数据库</td></tr><tr><td><strong>TimeOnly</strong></td><td><code>15:04:05</code></td><td><code>11:45:05</code></td><td>仅时间字段</td><td>无日期、无时区</td></tr></tbody></table><h2 id="格式化输出测试"><a href="#格式化输出测试" class="headerlink" title="格式化输出测试"></a>格式化输出测试</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestName</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">now := time.Now()</span><br><span class="line">layouts := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;Layout&quot;</span>:      <span class="string">&quot;01/02 03:04:05PM &#x27;06 -0700&quot;</span>,</span><br><span class="line"><span class="string">&quot;ANSIC&quot;</span>:       time.ANSIC,</span><br><span class="line"><span class="string">&quot;UnixDate&quot;</span>:    time.UnixDate,</span><br><span class="line"><span class="string">&quot;RubyDate&quot;</span>:    time.RubyDate,</span><br><span class="line"><span class="string">&quot;RFC822&quot;</span>:      time.RFC822,</span><br><span class="line"><span class="string">&quot;RFC822Z&quot;</span>:     time.RFC822Z,</span><br><span class="line"><span class="string">&quot;RFC850&quot;</span>:      time.RFC850,</span><br><span class="line"><span class="string">&quot;RFC1123&quot;</span>:     time.RFC1123,</span><br><span class="line"><span class="string">&quot;RFC1123Z&quot;</span>:    time.RFC1123Z,</span><br><span class="line"><span class="string">&quot;RFC3339&quot;</span>:     time.RFC3339,</span><br><span class="line"><span class="string">&quot;RFC3339Nano&quot;</span>: time.RFC3339Nano,</span><br><span class="line"><span class="string">&quot;Kitchen&quot;</span>:     time.Kitchen,</span><br><span class="line"><span class="string">&quot;Stamp&quot;</span>:       time.Stamp,</span><br><span class="line"><span class="string">&quot;StampMilli&quot;</span>:  time.StampMilli,</span><br><span class="line"><span class="string">&quot;StampMicro&quot;</span>:  time.StampMicro,</span><br><span class="line"><span class="string">&quot;StampNano&quot;</span>:   time.StampNano,</span><br><span class="line"><span class="string">&quot;DateTime&quot;</span>:    <span class="string">&quot;2006-01-02 15:04:05&quot;</span>,</span><br><span class="line"><span class="string">&quot;DateOnly&quot;</span>:    <span class="string">&quot;2006-01-02&quot;</span>,</span><br><span class="line"><span class="string">&quot;TimeOnly&quot;</span>:    <span class="string">&quot;15:04:05&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, layout := <span class="keyword">range</span> layouts &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%-12s : %s\n&quot;</span>, name, now.Format(layout))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;\n-- UTC 格式化 --&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> name, layout := <span class="keyword">range</span> layouts &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%-12s : %s\n&quot;</span>, name, now.UTC().Format(layout))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   TestName</span><br><span class="line">ANSIC        : Sat Sep  6 14:03:17 2025</span><br><span class="line">UnixDate     : Sat Sep  6 14:03:17 CST 2025</span><br><span class="line">RubyDate     : Sat Sep 06 14:03:17 +0800 2025</span><br><span class="line">RFC822Z      : 06 Sep 25 14:03 +0800</span><br><span class="line">RFC850       : Saturday, 06-Sep-25 14:03:17 CST</span><br><span class="line">RFC1123Z     : Sat, 06 Sep 2025 14:03:17 +0800</span><br><span class="line">RFC3339      : 2025-09-06T14:03:17+08:00</span><br><span class="line">RFC3339Nano  : 2025-09-06T14:03:17.9708592+08:00</span><br><span class="line">Kitchen      : 2:03PM</span><br><span class="line">Stamp        : Sep  6 14:03:17</span><br><span class="line">StampNano    : Sep  6 14:03:17.970859200</span><br><span class="line">DateTime     : 2025-09-06 14:03:17</span><br><span class="line">DateOnly     : 2025-09-06</span><br><span class="line">TimeOnly     : 14:03:17</span><br><span class="line">Layout       : 09/06 02:03:17PM &#x27;25 +0800</span><br><span class="line">RFC822       : 06 Sep 25 14:03 CST</span><br><span class="line">RFC1123      : Sat, 06 Sep 2025 14:03:17 CST</span><br><span class="line">StampMilli   : Sep  6 14:03:17.970</span><br><span class="line">StampMicro   : Sep  6 14:03:17.970859</span><br><span class="line"></span><br><span class="line">-- UTC 格式化 --</span><br><span class="line">UnixDate     : Sat Sep  6 06:03:17 UTC 2025</span><br><span class="line">RubyDate     : Sat Sep 06 06:03:17 +0000 2025</span><br><span class="line">RFC822Z      : 06 Sep 25 06:03 +0000</span><br><span class="line">RFC850       : Saturday, 06-Sep-25 06:03:17 UTC</span><br><span class="line">RFC1123Z     : Sat, 06 Sep 2025 06:03:17 +0000</span><br><span class="line">RFC3339      : 2025-09-06T06:03:17Z</span><br><span class="line">RFC3339Nano  : 2025-09-06T06:03:17.9708592Z</span><br><span class="line">Kitchen      : 6:03AM</span><br><span class="line">Stamp        : Sep  6 06:03:17</span><br><span class="line">StampNano    : Sep  6 06:03:17.970859200</span><br><span class="line">DateTime     : 2025-09-06 06:03:17</span><br><span class="line">DateOnly     : 2025-09-06</span><br><span class="line">TimeOnly     : 06:03:17</span><br><span class="line">Layout       : 09/06 06:03:17AM &#x27;25 +0000</span><br><span class="line">RFC822       : 06 Sep 25 06:03 UTC</span><br><span class="line">RFC1123      : Sat, 06 Sep 2025 06:03:17 UTC</span><br><span class="line">StampMilli   : Sep  6 06:03:17.970</span><br><span class="line">StampMicro   : Sep  6 06:03:17.970859</span><br><span class="line">ANSIC        : Sat Sep  6 06:03:17 2025</span><br><span class="line">--- PASS: TestName (0.01s)</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Go-时间布局格式&quot;&gt;&lt;a href=&quot;#Go-时间布局格式&quot; class=&quot;headerlink&quot; title=&quot;Go 时间布局格式&quot;&gt;&lt;/a&gt;Go 时间布局格式&lt;/h2&gt;&lt;p&gt;Go 使用 &lt;strong&gt;参考时间&lt;/strong&gt; &lt;code&gt;Mon Jan </summary>
      
    
    
    
    <category term="学习笔记" scheme="https://cooooing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="go" scheme="https://cooooing.github.io/tags/go/"/>
    
    <category term="时间" scheme="https://cooooing.github.io/tags/%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>top命令</title>
    <link href="https://cooooing.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/top%E5%91%BD%E4%BB%A4/"/>
    <id>https://cooooing.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/top%E5%91%BD%E4%BB%A4/</id>
    <published>2025-09-03T02:01:14.000Z</published>
    <updated>2025-09-03T02:01:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="top-命令"><a href="#top-命令" class="headerlink" title="top 命令"></a>top 命令</h2><p>top 命令是 Linux 常用的实时系统监控工具。它默认每隔 3 秒刷新一次。</p><h3 id="启动参数（命令行选项）"><a href="#启动参数（命令行选项）" class="headerlink" title="启动参数（命令行选项）"></a>启动参数（命令行选项）</h3><table><thead><tr><th>参数</th><th>全称</th><th>作用</th></tr></thead><tbody><tr><td><code>-d seconds</code></td><td><strong>delay-time</strong></td><td>刷新间隔（默认 3 秒），例如 <code>top -d 1</code> 每 1 秒刷新一次</td></tr><tr><td><code>-n count</code></td><td><strong>number-of-iterations</strong></td><td>运行多少次后退出，例如 <code>top -n 5</code> 显示 5 次后退出</td></tr><tr><td><code>-p pid</code></td><td><strong>process-id</strong></td><td>仅监控指定进程，例如 <code>top -p 1234</code></td></tr><tr><td><code>-u user</code></td><td><strong>user-name</strong></td><td>仅显示指定用户的进程，例如 <code>top -u root</code></td></tr><tr><td><code>-U user</code></td><td><strong>UID-based</strong></td><td>类似 <code>-u</code>，但基于 UID</td></tr><tr><td><code>-b</code></td><td><strong>batch-mode</strong></td><td>批处理模式（无交互，常用于重定向到文件：<code>top -b -n 1 &gt; out.txt</code>）</td></tr><tr><td><code>-H</code></td><td><strong>threads-mode</strong></td><td>显示线程而非进程</td></tr><tr><td><code>-i</code></td><td><strong>idle-process toggle</strong></td><td>启动时忽略空闲任务（&#x3D; 运行时按 <code>i</code>）</td></tr><tr><td><code>-c</code></td><td><strong>command-line toggle</strong></td><td>显示完整命令行（&#x3D; 运行时按 <code>c</code>）</td></tr></tbody></table><h3 id="交互式快捷键（运行时输入）"><a href="#交互式快捷键（运行时输入）" class="headerlink" title="交互式快捷键（运行时输入）"></a>交互式快捷键（运行时输入）</h3><h4 id="显示控制"><a href="#显示控制" class="headerlink" title="显示控制"></a>显示控制</h4><table><thead><tr><th>按键</th><th>全称</th><th>作用</th></tr></thead><tbody><tr><td><code>h</code></td><td><strong>help</strong></td><td>显示帮助（所有快捷键说明）</td></tr><tr><td><code>q</code></td><td><strong>quit</strong></td><td>退出 <code>top</code></td></tr><tr><td><code>z</code></td><td><strong>color&#x2F;mono toggle</strong></td><td>切换彩色&#x2F;单色模式</td></tr><tr><td><code>B</code></td><td><strong>bold toggle</strong></td><td>是否加粗高亮</td></tr><tr><td><code>l</code></td><td><strong>load-average toggle</strong></td><td>显示&#x2F;隐藏顶部的负载信息</td></tr><tr><td><code>t</code></td><td><strong>tasks toggle</strong></td><td>显示&#x2F;隐藏任务和 CPU 使用情况</td></tr><tr><td><code>m</code></td><td><strong>memory toggle</strong></td><td>显示&#x2F;隐藏内存&#x2F;Swap 行</td></tr><tr><td><code>1</code></td><td><strong>cpu-per-core</strong></td><td>展开&#x2F;收起所有 CPU 核心的使用率</td></tr></tbody></table><hr><h4 id="排序与过滤"><a href="#排序与过滤" class="headerlink" title="排序与过滤"></a>排序与过滤</h4><table><thead><tr><th>按键</th><th>全称</th><th>作用</th></tr></thead><tbody><tr><td><code>P</code></td><td><strong>sort by CPU</strong></td><td>按 CPU 使用率排序（默认）</td></tr><tr><td><code>M</code></td><td><strong>sort by Memory</strong></td><td>按内存使用率排序</td></tr><tr><td><code>T</code></td><td><strong>sort by Time</strong></td><td>按运行时间排序</td></tr><tr><td><code>N</code></td><td><strong>sort by PID</strong></td><td>按 PID 排序</td></tr><tr><td><code>R</code></td><td><strong>reverse sort</strong></td><td>反向排序</td></tr><tr><td><code>O</code>（大写）</td><td><strong>change sort field</strong></td><td>按其他字段排序（进入交互菜单选择）</td></tr><tr><td><code>o</code>（小写）</td><td><strong>filter by field</strong></td><td>过滤显示（例如 <code>COMMAND=nginx</code>）</td></tr><tr><td><code>u</code></td><td><strong>filter by user</strong></td><td>只显示某个用户的进程</td></tr></tbody></table><hr><h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><table><thead><tr><th>按键</th><th>全称</th><th>作用</th></tr></thead><tbody><tr><td><code>k</code></td><td><strong>kill</strong></td><td>杀死进程（输入 PID 和信号，默认 15 <code>SIGTERM</code>）</td></tr><tr><td><code>r</code></td><td><strong>renice</strong></td><td>调整进程 Nice 值（输入 PID 和新 nice 值）</td></tr><tr><td><code>s</code></td><td><strong>set-delay</strong></td><td>修改刷新间隔（秒）</td></tr><tr><td><code>W</code></td><td><strong>write config</strong></td><td>保存当前配置，下次启动生效（写入 <code>~/.toprc</code>）</td></tr></tbody></table><hr><h4 id="进程显示切换"><a href="#进程显示切换" class="headerlink" title="进程显示切换"></a>进程显示切换</h4><table><thead><tr><th>按键</th><th>全称</th><th>作用</th></tr></thead><tbody><tr><td><code>c</code></td><td><strong>command-line toggle</strong></td><td>显示完整命令行 vs 仅命令名</td></tr><tr><td><code>i</code></td><td><strong>idle toggle</strong></td><td>显示&#x2F;隐藏空闲进程</td></tr><tr><td><code>H</code></td><td><strong>threads toggle</strong></td><td>显示线程而不是进程</td></tr><tr><td><code>x</code></td><td><strong>highlight sort column</strong></td><td>高亮当前排序列</td></tr><tr><td><code>y</code></td><td><strong>highlight running tasks</strong></td><td>高亮正在运行的任务</td></tr><tr><td><code>u</code></td><td><strong>user filter</strong></td><td>只显示指定用户的进程</td></tr><tr><td><code>V</code></td><td><strong>forest view</strong></td><td>树状显示进程（类似 <code>pstree</code>）</td></tr></tbody></table><h2 id="显示信息"><a href="#显示信息" class="headerlink" title="显示信息"></a>显示信息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">top - 13:24:16 up 3 days, 22:41,  0 user,  load average: 0.14, 0.14, 0.11</span><br><span class="line">Tasks: 163 total,   1 running, 162 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  1.3 us,  0.8 sy,  0.0 ni, 97.1 id,  0.7 wa,  0.0 hi,  0.1 si,  0.0 st </span><br><span class="line">MiB Mem :   7940.7 total,    222.3 free,   6399.8 used,   1590.8 buff/cache     </span><br><span class="line">MiB Swap:      0.0 total,      0.0 free,      0.0 used.   1540.9 avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                                                                    </span><br><span class="line"> 1197 root      20   0 1963420 640468  36736 S   4.0   7.9 282:35.87 kube-apiserver                                                                             </span><br><span class="line"> 2327 root      20   0 2237824  49708  24064 S   1.3   0.6  80:30.91 calico-node                                                                                </span><br><span class="line">  771 root       0 -20   11.3g  89348  23552 S   1.0   1.1  79:04.21 etcd                                                                                       </span><br><span class="line"> 1228 root      20   0 1412044  84508  21376 S   1.0   1.0  78:41.97 kube-controller                                                                            </span><br><span class="line">32616 root      20   0 2227064  92080  50560 S   1.0   1.1  79:00.74 kubelet                                                                                    </span><br><span class="line"> 1212 root      20   0 1283348  32972  13056 S   0.3   0.4  15:25.14 kube-scheduler                                                                             </span><br><span class="line"> 1648 root      20   0  746604  16832   6400 S   0.3   0.2   9:40.87 node-cache                                                                                 </span><br><span class="line">15415 root      20   0       0      0      0 I   0.3   0.0   0:00.28 kworker/1:1-events                                                                         </span><br><span class="line">31742 root      20   0 2398412  60844  29696 S   0.3   0.7  26:17.82 containerd                                                                                 </span><br><span class="line">43556 ubuntu    20   0   13228   6528   4352 R   0.3   0.1   0:00.18 top                                                                                        </span><br><span class="line">    1 root      20   0   23084  12288   7680 S   0.0   0.2   1:12.93 systemd                                                                                    </span><br><span class="line">    2 root      20   0       0      0      0 S   0.0   0.0   0:00.05 kthreadd                                                                                   </span><br><span class="line">    3 root      20   0       0      0      0 S   0.0   0.0   0:00.00 pool_workqueue_release                                                                     </span><br><span class="line">    4 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker/R-rcu_g                                                                            </span><br><span class="line">    5 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker/R-rcu_p                                                                            </span><br><span class="line">    6 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker/R-slub_                                                                            </span><br><span class="line">    7 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker/R-netns                                                                            </span><br><span class="line">    9 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker/0:0H-events_highpri                                                                </span><br><span class="line">   12 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker/R-mm_pe                                                                            </span><br><span class="line">   13 root      20   0       0      0      0 I   0.0   0.0   0:00.00 rcu_tasks_kthread                                                                          </span><br><span class="line">   14 root      20   0       0      0      0 I   0.0   0.0   0:00.00 rcu_tasks_rude_kthread                                                                     </span><br><span class="line">   15 root      20   0       0      0      0 I   0.0   0.0   0:00.00 rcu_tasks_trace_kthread                                                                    </span><br><span class="line">   16 root      20   0       0      0      0 S   0.0   0.0   0:13.07 ksoftirqd/0                                                                                </span><br><span class="line">   17 root      20   0       0      0      0 I   0.0   0.0   1:02.67 rcu_preempt                                                                                </span><br><span class="line">   18 root      rt   0       0      0      0 S   0.0   0.0   0:02.89 migration/0                                                                                </span><br><span class="line">   19 root     -51   0       0      0      0 S   0.0   0.0   0:00.00 idle_inject/0                                                                              </span><br><span class="line">   20 root      20   0       0      0      0 S   0.0   0.0   0:00.00 cpuhp/0                                                                                    </span><br><span class="line">   21 root      20   0       0      0      0 S   0.0   0.0   0:00.00 cpuhp/2                                                                                    </span><br><span class="line">   22 root     -51   0       0      0      0 S   0.0   0.0   0:00.00 idle_inject/2                                                                              </span><br><span class="line">   23 root      rt   0       0      0      0 S   0.0   0.0   0:02.40 migration/2     </span><br></pre></td></tr></table></figure><h3 id="顶部状态"><a href="#顶部状态" class="headerlink" title="顶部状态"></a>顶部状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top - 13:24:16 up 3 days, 22:41,  0 user,  load average: 0.14, 0.14, 0.11</span><br></pre></td></tr></table></figure><ul><li><strong>13:24:16</strong> → 当前系统时间</li><li><strong>up 3 days, 22:41</strong> → 系统已运行 3 天 22 小时 41 分钟</li><li><strong>0 user</strong> → 当前登录用户数（这里没有用户直接登录）</li><li><strong>load average: 0.14, 0.14, 0.11</strong> 系统 1 分钟、5 分钟、15 分钟的平均负载。数字越接近 CPU 核心数，说明负载越合理。比如 4 核 CPU，load average 小于 4 基本健康。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tasks: 163 total,   1 running, 162 sleeping,   0 stopped,   0 zombie</span><br></pre></td></tr></table></figure><ul><li><strong>163 total</strong> → 系统中共有 163 个进程</li><li><strong>1 running</strong> → 正在运行的进程 1 个</li><li><strong>162 sleeping</strong> → 休眠状态的进程 162 个（大部分进程常处于此状态，等待事件触发）</li><li><strong>0 stopped</strong> → 停止的进程（通过信号暂停）</li><li><strong>0 zombie</strong> → 僵尸进程（子进程结束但父进程未回收资源，数量多时是问题信号）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%Cpu(s):  1.3 us,  0.8 sy,  0.0 ni, 97.1 id,  0.7 wa,  0.0 hi,  0.1 si,  0.0 st</span><br></pre></td></tr></table></figure><ul><li><strong>1.3 us (user space)</strong> → 用户态进程占用 CPU 1.3%</li><li><strong>0.8 sy (system)</strong> → 内核态占用 CPU 0.8%</li><li><strong>0.0 ni (nice)</strong> → 调整过 nice 优先级的进程占用 0%</li><li><strong>97.1 id (idle)</strong> → CPU 空闲 97.1%</li><li><strong>0.7 wa (I&#x2F;O wait)</strong> → 等待 I&#x2F;O 的 CPU 时间（磁盘&#x2F;网络）</li><li><strong>0.0 hi (hardware interrupt)</strong> → 硬件中断占用 CPU 时间百分比</li><li><strong>0.1 si (software interrupt)</strong> → 软件中断占用 CPU 时间百分比</li><li><strong>0.0 st (steal time)</strong> → 被虚拟机管理程序（Hypervisor）“偷走”的 CPU 时间百分比（虚拟化场景有意义）</li></ul><blockquote><p>一般关注 us+sy（实际负载），如果 wa 很高，说明 I&#x2F;O 瓶颈。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MiB Mem :   7940.7 total,    222.3 free,   6399.8 used,   1590.8 buff/cache</span><br></pre></td></tr></table></figure><ul><li><strong>7940.7 total</strong> → 总内存 7.9 GB</li><li><strong>222.3 free</strong> → 空闲内存 222 MB（未使用部分，Linux 下通常较小）</li><li><strong>6399.8 used</strong> → 被程序使用的内存 6.4 GB（包含应用+缓存）</li><li><strong>1590.8 buff&#x2F;cache</strong> → 缓冲和缓存内存（用于磁盘缓存和文件缓存，可回收）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MiB Swap:      0.0 total,      0.0 free,      0.0 used.   1540.9 avail Mem</span><br></pre></td></tr></table></figure><ul><li><strong>total 0.0</strong> → 没有配置 swap 分区</li><li><strong>free 0.0</strong> → 空闲 Swap</li><li><strong>used 0.0</strong> → 已用 Swap</li><li><strong>avail Mem 1540.9</strong> → 实际可用内存 1.5 GB（考虑缓存和可回收内存），比 free 更准确</li></ul><blockquote><p>如果 Swap used 很高，说明物理内存不足。</p></blockquote><h3 id="进程列表"><a href="#进程列表" class="headerlink" title="进程列表"></a>进程列表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND </span><br></pre></td></tr></table></figure><ul><li><strong>PID (Process ID)</strong> → 进程 ID（唯一标识）</li><li><strong>USER</strong> → 进程所有者（用户名）</li><li><strong>PR (Priority)</strong> → （内核调度的优先级，数值越小优先级越高）</li><li><strong>NI (Nice)</strong> → nice 值（用户可调节，-20 ~ 19，影响优先级）</li><li><strong>VIRT (Virtual Memory)</strong> → 进程使用的虚拟内存 (KB)，进程申请的总地址空间，包括共享库、映射文件等</li><li><strong>RES (Resident Memory)</strong> → 进程常驻物理内存 (KB)，实际占用的物理内存</li><li><strong>SHR (Shared Memory)</strong> → 共享内存 (KB)，与其他进程共享的内存</li><li><strong>S (State)</strong> → 进程状态<ul><li><code>R</code> → running</li><li><code>S</code> → sleeping</li><li><code>I</code> → idle</li><li><code>D</code> → 不可中断睡眠</li><li><code>Z</code> → 僵尸</li></ul></li><li><strong>%CPU (CPU usage)</strong> → CPU 使用率（按刷新周期计算）</li><li><strong>%MEM (Memory usage)</strong> → 内存使用率（占总内存百分比）</li><li><strong>TIME+ (CPU Time)</strong> → 进程累计使用的 CPU 时间，格式 <em>分钟:秒.百分秒</em></li><li><strong>COMMAND</strong> → 进程的命令或程序名（默认显示简写，可按 <code>c</code> 显示完整命令行）</li></ul><h2 id="一些指标的概念"><a href="#一些指标的概念" class="headerlink" title="一些指标的概念"></a>一些指标的概念</h2><h3 id="Nice-值-Niceness-Value"><a href="#Nice-值-Niceness-Value" class="headerlink" title="Nice 值 (Niceness Value)"></a>Nice 值 (Niceness Value)</h3><p>调节进程的<strong>优先级 (Priority, PR)</strong>，影响 CPU 调度的先后顺序。</p><ul><li><p><strong>取值范围</strong>：<code>-20 ~ 19</code></p><ul><li><strong>-20</strong> → 最高优先级（最“自私”，会多抢占 CPU）</li><li><strong>0</strong> → 默认值</li><li><strong>19</strong> → 最低优先级（最“友好”，让出 CPU 机会）</li></ul></li><li><p><strong>关系</strong>：</p><ul><li>最终调度优先级由 <strong>PR &#x3D; base_priority + NI</strong> 决定</li><li><code>top</code> 里 <strong>PR</strong> 越小，进程调度优先级越高</li></ul></li><li><p><strong>修改方式</strong>：</p><ul><li>启动时指定：<code>nice -n 10 my_program</code></li><li>运行时调整：<code>renice -n -5 -p 1234</code> （调整 PID&#x3D;1234 的进程）</li></ul></li><li><p>大型数据分析进程可以 <code>nice=10</code> → 不阻塞关键服务</p></li><li><p>系统关键进程可能会设置低 nice 值（-5 ~ -20），保证调度优先级</p></li></ul><hr><h3 id="交换空间-Swap-Space"><a href="#交换空间-Swap-Space" class="headerlink" title="交换空间 (Swap Space)"></a>交换空间 (Swap Space)</h3><p>当物理内存不足时，Linux 会把部分<strong>不常用的内存页</strong>写到磁盘上的 Swap 区域，以释放 RAM。<br>可以让系统避免“内存不足直接崩溃”。但磁盘速度远低于内存，频繁使用 Swap 会导致性能下降（俗称“抖动 &#x2F; thrashing”）。</p><ul><li>在 <code>top</code> 的 <strong>Swap used</strong> 升高时，说明内存吃紧</li><li>进程会明显变慢</li></ul><p><strong>Kubernetes 中默认不允许使用交换内存</strong></p><p>Kubernetes 的调度和资源控制主要依赖于 <strong>cgroup 的 CPU、内存限制</strong>。</p><ul><li><strong>内存限制</strong>：Pod 被限制多少内存，超过就会触发 <strong>OOMKill</strong>。</li><li>如果允许 swap，那么：<ul><li>Pod 占用的物理内存可能被换出到 swap，而 kubelet 和 cgroup 并不知道。</li><li>容器可能“假装”没超内存，实际上性能已经变得非常差。</li><li>这会导致 <strong>资源隔离失真</strong>，调度器也无法准确分配资源。</li></ul></li></ul><p>因此，Kubernetes 默认要求节点运行在 <strong>no swap</strong> 的状态下，以保证资源控制的可预测性。</p><p>但 Kubernetes 在后续版本有支持开启交换内存的功能：</p><p><a class="link"   href="https://kubernetes.io/blog/2021/08/09/run-nodes-with-swap-alpha/" >New in Kubernetes v1.22: alpha support for using swap memory<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://kubernetes.io/zh-cn/blog/2023/08/24/swap-linux-beta/" >Kubernetes 1.28: Beta support for using swap on Linux<i class="fas fa-external-link-alt"></i></a></p><h3 id="虚拟内存-Virtual-Memory-VIRT"><a href="#虚拟内存-Virtual-Memory-VIRT" class="headerlink" title="虚拟内存 (Virtual Memory, VIRT)"></a>虚拟内存 (Virtual Memory, VIRT)</h3><p>每个进程拥有<strong>独立的地址空间</strong>（虚拟内存），由操作系统内核管理并映射到实际物理内存或磁盘。</p><p>包含内容：</p><ol><li>程序代码</li><li>已分配但未实际使用的内存</li><li>动态库</li><li>内存映射文件（mmap）</li><li>可能被换出到 Swap 的部分</li></ol><p>指标含义：</p><ul><li><code>top</code> 里的 <strong>VIRT</strong> → 进程可寻址的虚拟内存总量（不等于真实占用 RAM）</li><li><code>RES</code> → 真实常驻物理内存</li><li><code>SHR</code> → 共享内存</li></ul><p>举例：一个 Python 程序加载 TensorFlow，<code>VIRT</code> 可能几十 GB，但 <code>RES</code> 可能只有几百 MB，因为很多库只是映射，并没有真正加载到内存。</p><h3 id="中断-Interrupt"><a href="#中断-Interrupt" class="headerlink" title="中断 (Interrupt)"></a>中断 (Interrupt)</h3><p>中断是 CPU 在运行用户代码时，被“打断”去处理某个事件的机制。分为<strong>硬件中断</strong>和<strong>软件中断</strong>。</p><h4 id="硬件中断-Hardware-Interrupt-hi"><a href="#硬件中断-Hardware-Interrupt-hi" class="headerlink" title="硬件中断 (Hardware Interrupt, hi)"></a>硬件中断 (Hardware Interrupt, hi)</h4><p>来源：外部硬件设备向 CPU 发出信号<br>例子：</p><ul><li>键盘输入（按下一个键）</li><li>网络接口卡收到数据包</li><li>磁盘 I&#x2F;O 完成通知</li></ul><p>类比：你正在写字（运行程序），突然电话响了（键盘输入），你必须停下去接电话（处理硬件中断）。</p><h4 id="软件中断-Software-Interrupt-si"><a href="#软件中断-Software-Interrupt-si" class="headerlink" title="软件中断 (Software Interrupt, si)"></a>软件中断 (Software Interrupt, si)</h4><p>来源：内核为处理高频硬件事件，把一些工作转交给“软中断”机制（通常由内核线程完成）。<br>例子：</p><ul><li>网络包的协议栈处理（TCP&#x2F;IP 解析）</li><li>大量磁盘 IO 的后续处理</li></ul><p>类比：电话太多了，你雇了秘书（内核线程）来代接一部分，这就是软件中断。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;top-命令&quot;&gt;&lt;a href=&quot;#top-命令&quot; class=&quot;headerlink&quot; title=&quot;top 命令&quot;&gt;&lt;/a&gt;top 命令&lt;/h2&gt;&lt;p&gt;top 命令是 Linux 常用的实时系统监控工具。它默认每隔 3 秒刷新一次。&lt;/p&gt;
&lt;h3 id=&quot;启</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://cooooing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="linux" scheme="https://cooooing.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>常用的锁</title>
    <link href="https://cooooing.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B8%B8%E7%94%A8%E7%9A%84%E9%94%81/"/>
    <id>https://cooooing.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B8%B8%E7%94%A8%E7%9A%84%E9%94%81/</id>
    <published>2025-07-31T06:22:54.000Z</published>
    <updated>2025-07-31T06:22:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>在并发编程中，锁是用于同步线程、避免数据竞争和确保线程安全的重要机制。</p><h2 id="互斥锁（Mutex）"><a href="#互斥锁（Mutex）" class="headerlink" title="互斥锁（Mutex）"></a>互斥锁（Mutex）</h2><p>互斥锁是最基本的锁类型，确保同一时间只有一个线程可以访问共享资源。</p><ul><li>线程获取锁后，其他尝试获取锁的线程会被阻塞，直到锁被释放。</li><li>通常用于保护临界区（Critical Section）。</li><li>实现简单，但可能导致线程阻塞和上下文切换开销。</li></ul><blockquote><p>用于需要确保独占访问共享资源的场景。</p></blockquote><h2 id="读写锁（Read-Write-Lock）"><a href="#读写锁（Read-Write-Lock）" class="headerlink" title="读写锁（Read-Write Lock）"></a>读写锁（Read-Write Lock）</h2><p>允许多个线程同时读取共享资源，但写操作需独占访问。</p><ul><li><strong>读锁</strong>：多个线程可同时持有读锁（共享锁）。</li><li><strong>写锁</strong>：写锁是独占的，写时不允许其他读或写操作。</li><li>提高并发性能，尤其在读多写少的场景。</li></ul><p>是互斥锁的一种扩展，区分读写操作以提升性能。</p><blockquote><p>用于读操作频繁、写操作较少的场景，如数据库缓存。</p></blockquote><h2 id="条件锁（Condition-Lock）"><a href="#条件锁（Condition-Lock）" class="headerlink" title="条件锁（Condition Lock）"></a>条件锁（Condition Lock）</h2><p>结合条件变量，用于线程间的协作，线程在特定条件满足时才继续执行。</p><ul><li>通常与互斥锁配合使用，线程等待条件满足时进入休眠，条件满足时被唤醒。</li><li>提高效率，避免忙等待。</li></ul><p>条件锁依赖互斥锁，互斥锁保护共享条件变量。</p><blockquote><p>用于生产者-消费者模型、线程同步等待。</p></blockquote><h2 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h2><p>一种计数器机制，控制多个线程对有限资源的访问。</p><ul><li>允许指定数量的线程同时访问资源（计数&gt;1）。</li><li>当计数为1时，行为类似于互斥锁。</li></ul><p>信号量是互斥锁的泛化，支持多线程并发访问。互斥锁限制为单一线程访问。</p><blockquote><p>用于限制并发访问数量，如连接池管理。</p></blockquote><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>在分布式系统中，用于协调多个进程或节点对共享资源的访问。</p><ul><li>跨机器实现，通常基于外部存储（如Redis、ZooKeeper、Etcd）。</li><li>需考虑网络延迟、节点故障等复杂情况。</li></ul><p>分布式锁是互斥锁的分布式扩展，适用于跨进程或跨机器场景。本地锁（如Mutex）仅限于单机多线程。</p><blockquote><p>用于分布式系统中协调跨进程或跨节点的资源访问，如分布式任务调度。</p></blockquote><h2 id="悲观锁和乐观锁（加锁策略）"><a href="#悲观锁和乐观锁（加锁策略）" class="headerlink" title="悲观锁和乐观锁（加锁策略）"></a>悲观锁和乐观锁（加锁策略）</h2><h3 id="悲观锁（Pessimistic-Lock）"><a href="#悲观锁（Pessimistic-Lock）" class="headerlink" title="悲观锁（Pessimistic Lock）"></a>悲观锁（Pessimistic Lock）</h3><p>悲观锁假设并发操作中冲突（数据竞争）发生的概率较高，因此<strong>在访问共享资源之前，总是先获取锁</strong>，确保独占访问。其他线程在锁被释放前会被阻塞。</p><blockquote><p>适用于写操作频繁、冲突概率高、数据一致性要求严格的场景。<br>如互斥锁、读写锁、数据库锁（行锁、表锁）。</p></blockquote><h3 id="乐观锁（Optimistic-Lock）"><a href="#乐观锁（Optimistic-Lock）" class="headerlink" title="乐观锁（Optimistic Lock）"></a>乐观锁（Optimistic Lock）</h3><p>乐观锁假设并发操作中冲突发生的概率较低，<strong>允许线程先执行操作，在提交时检查数据是否被修改</strong>。<br>如果未被修改，则提交成功；否则，回滚并重试。<strong>乐观锁通常不使用传统锁机制，而是依赖版本控制或原子操作</strong>。</p><p>乐观锁是非阻塞的，线程直接操作共享资源，而无需等待锁。<br>通过版本号、时间戳或CAS（Compare-And-Swap）检查数据是否被修改。</p><blockquote><p>适用于读多场景，高并发低冲突。<br>如缓存更新、计数器</p></blockquote><h2 id="阻塞锁和非阻塞锁（等待机制）"><a href="#阻塞锁和非阻塞锁（等待机制）" class="headerlink" title="阻塞锁和非阻塞锁（等待机制）"></a>阻塞锁和非阻塞锁（等待机制）</h2><h3 id="阻塞锁（Blocking-Lock）"><a href="#阻塞锁（Blocking-Lock）" class="headerlink" title="阻塞锁（Blocking Lock）"></a>阻塞锁（Blocking Lock）</h3><p>阻塞锁是指当线程尝试获取锁时，如果锁已被其他线程占用，当前线程会进入阻塞状态（挂起），等待锁释放。<br>阻塞状态通常由操作系统管理，线程被放入等待队列，暂停执行，直到被唤醒。</p><p><strong>锁不可用时，线程被挂起，释放CPU资源。</strong><br>但通常涉及线程的上下文切换（从用户态到内核态），开销较高。<br>线程唤醒和重新调度可能引入延迟。</p><blockquote><p>适用于需要强一致性、长时间持有锁或高冲突场景。<br>互斥锁、读写锁、条件锁都属于阻塞锁。</p></blockquote><h3 id="非阻塞锁（Non-Blocking-Lock）"><a href="#非阻塞锁（Non-Blocking-Lock）" class="headerlink" title="非阻塞锁（Non-Blocking Lock）"></a>非阻塞锁（Non-Blocking Lock）</h3><p>非阻塞锁是指当线程尝试获取锁时，如果锁不可用，线程不会进入阻塞状态，而是立即返回（失败）或通过忙等待（busy-waiting）继续尝试。<br>非阻塞锁通常基于原子操作实现，尽量避免操作系统介入。</p><p><strong>锁不可用时，线程要么立即返回，要么短暂自旋（循环尝试）。</strong><br>基于原子操作（如CAS、Test-and-Set），通常在用户态完成。<br>自旋可能浪费CPU资源，但避免上下文切换。</p><blockquote><p>适用于需要高吞吐量、短锁持有时间、冲突概率较低的场景。<br>自旋锁、乐观锁属于非阻塞锁。TryLock机制用于快速失败（尝试获取锁，失败则立即返回）。</p></blockquote><h2 id="可重入锁和非可重入锁（重入性）"><a href="#可重入锁和非可重入锁（重入性）" class="headerlink" title="可重入锁和非可重入锁（重入性）"></a>可重入锁和非可重入锁（重入性）</h2><p><strong>基于锁是否允许同一线程多次获取的特性进行分类。</strong><br>它们在实现线程安全和避免死锁方面有显著差异。</p><h3 id="可重入锁（Reentrant-Lock）"><a href="#可重入锁（Reentrant-Lock）" class="headerlink" title="可重入锁（Reentrant Lock）"></a>可重入锁（Reentrant Lock）</h3><p>可重入锁允许同一线程多次获取同一把锁而不会导致死锁。每次获取锁时，锁内部会记录重入次数，线程必须释放相同次数的锁才能完全解锁。</p><p>同一线程可多次调用Lock()，每次增加锁的计数器。<br>释放时需调用Unlock()与Lock()次数相同，计数器减为0时锁被释放。</p><blockquote><p>适用于复杂逻辑中，同一线程多次进入临界区（递归函数或嵌套调用）的场景。</p></blockquote><h3 id="非可重入锁（Non-Reentrant-Lock）"><a href="#非可重入锁（Non-Reentrant-Lock）" class="headerlink" title="非可重入锁（Non-Reentrant Lock）"></a>非可重入锁（Non-Reentrant Lock）</h3><p>非可重入锁不允许同一线程多次获取同一把锁。如果线程尝试重复加锁，会导致死锁或异常。</p><blockquote><p>适用于简单互斥场景。</p></blockquote><h2 id="公平锁和非公平锁（分配策略）"><a href="#公平锁和非公平锁（分配策略）" class="headerlink" title="公平锁和非公平锁（分配策略）"></a>公平锁和非公平锁（分配策略）</h2><p><strong>根据锁的分配策略分类。</strong><br>区别在于当多个线程（或goroutine）竞争锁时，锁是否按照线程请求的顺序（通常是先到先得）分配。</p><h3 id="公平锁（Fair-Lock）"><a href="#公平锁（Fair-Lock）" class="headerlink" title="公平锁（Fair Lock）"></a>公平锁（Fair Lock）</h3><p>公平锁确保线程按照请求锁的顺序获取锁，通常采用先到先得（FIFO，First-In-First-Out）策略。<br>当锁释放时，等待队列中最先请求的线程优先获得锁。</p><p>线程按请求顺序获取锁，避免线程饥饿（某些线程长期无法获取锁）。<br>维护了一个队列，用于记录线程的请求顺序。在锁被释放时，唤醒队列头部的线程。</p><blockquote><p>适用于需要严格公平性、避免线程饥饿的场景。<br>需要维护队列，性能相对较低。</p></blockquote><h3 id="非公平锁（Non-Fair-Lock）"><a href="#非公平锁（Non-Fair-Lock）" class="headerlink" title="非公平锁（Non-Fair Lock）"></a>非公平锁（Non-Fair Lock）</h3><p><strong>非公平锁不保证线程按请求顺序获取锁。</strong><br>当锁释放时，等待线程和新请求线程竞争锁，操作系统或运行时决定哪个线程获得锁，可能导致后请求的线程优先获取。</p><p>不保证FIFO，可能导致线程饥饿（某些线程长期无法获取锁）。</p><blockquote><p>适用于追求高性能、允许一定程度不公平的场景。</p></blockquote><h2 id="锁会引发的问题"><a href="#锁会引发的问题" class="headerlink" title="锁会引发的问题"></a>锁会引发的问题</h2><h3 id="死锁（deadlock）"><a href="#死锁（deadlock）" class="headerlink" title="死锁（deadlock）"></a>死锁（deadlock）</h3><p>多个线程互相持有对方需要的锁，导致所有线程无法继续执行。</p><p>死锁产生的四个必要条件（梦回操作系统课）：</p><ul><li>互斥条件：一个资源每次只能被一个进程使用。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：进程已获得的资源，在没使用完之前，不能强行剥夺。</li><li>循环等待条件：多个进程之间形成一种互相循环等待资源的关系。</li></ul><p>发生场景：</p><ul><li>多个锁的嵌套获取，且顺序不一致。</li><li>非可重入锁（如sync.Mutex）在同一线程重复加锁。</li></ul><p>解决方法（破坏四个必要条件）：</p><ul><li>统一线程的请求锁的顺序，以保证线程能获取到所需的全部资源而不阻塞，进而保证不发生死锁。</li><li>避免线程持有锁并等待锁。在请求锁时，如果锁被其他线程占用，不等待，而是将之前持有的锁释放，保证其他线程顺利执行。</li></ul><h3 id="活锁（Livelock）"><a href="#活锁（Livelock）" class="headerlink" title="活锁（Livelock）"></a>活锁（Livelock）</h3><p>线程不断尝试获取锁但无法成功，处于活跃但无进展的状态。<br>活锁其实是避免死锁的一种方式——避免线程持续尝试获取锁，而是通过等待或随机退避来避免。</p><p>举个例子：<br>在一个比较窄但允许两人同行的马路上，两个人相对而行，如果两个人相撞<br>死锁是：两个人僵持不动，谁都无法往前走<br>活锁是：两个人都很客气的让路给对方，但是两人同时移动到另一侧，又继续相撞，再移动回来又相撞，一直这样持续下去，那么就会发生活锁</p><p>活锁发生的概率是非常非常低的，两人的移动必须一直保持完全同步才可以，不然很快就可以解锁</p><p>发生场景：</p><ul><li>非阻塞锁（如自旋锁）在高竞争下持续重试。</li><li>两个线程互相礼让锁（如CAS失败后退避）。</li></ul><p>解决方法：</p><ul><li>引入随机退避（如指数退避）。</li><li>限制重试次数，切换到阻塞锁。</li></ul><h3 id="线程饥饿（Starvation）"><a href="#线程饥饿（Starvation）" class="headerlink" title="线程饥饿（Starvation）"></a>线程饥饿（Starvation）</h3><p>死锁或活锁描述的是多个线程的整体状态，线程饥饿描述的是单个线程的状态。<br>饥饿是某些线程长期无法获取锁，导致无法执行。</p><p>发生场景：</p><ul><li>非公平锁（如sync.Mutex）优先新请求线程。</li><li>高优先级线程抢占锁。</li></ul><p>解决方法：</p><ul><li>使用公平锁。</li><li>调整线程优先级或调度策略。</li></ul><h3 id="优先级反转（Priority-Inversion）"><a href="#优先级反转（Priority-Inversion）" class="headerlink" title="优先级反转（Priority Inversion）"></a>优先级反转（Priority Inversion）</h3><p>高优先级线程因等待低优先级线程释放共享资源（如锁）而被阻塞，而低优先级线程可能被其他中优先级线程抢占，导致高优先级线程的执行延迟。<br>这种现象违背了优先级调度原则，可能导致实时系统无法满足时间要求。</p><p>发生场景：</p><ul><li>实时系统中，低优先级线程持有锁，高优先级线程被阻塞。</li></ul><p>解决方法：</p><ul><li>优先级继承（低优先级线程临时提升优先级，确保低优先级的线程优先于中优先级线程运行，尽快释放锁。）</li><li>优先级提升（为每个锁设置最高优先级，持有锁的线程提升到该优先级）</li></ul><h3 id="伪唤醒（Spurious-Wakeup）"><a href="#伪唤醒（Spurious-Wakeup）" class="headerlink" title="伪唤醒（Spurious Wakeup）"></a>伪唤醒（Spurious Wakeup）</h3><p>伪唤醒是指线程在等待条件变量（如条件锁）时，被操作系统或运行时无故唤醒，而条件并未满足。</p><p>伪唤醒是操作系统或并发库实现条件变量时的一种副作用，其原因主要与底层实现和优化相关。<br>操作系统可能设计为允许伪唤醒，在<code>Signal()</code>或<code>Broadcast()</code>时唤醒多个等待线程，而不是精确唤醒一个。以提高效率或简化同步原语的实现，防止复杂场景下的死锁或错误。<br>伪唤醒是条件变量实现的“不可避免副作用”，标准（如POSIX、C++）明确允许其存在。<br>设计上，条件变量不保证“仅当条件满足时唤醒”，因此在使用条件锁时需要额外的处理。</p><p>解决方法：</p><ul><li>使用循环检查条件</li></ul><p>由单次检查条件改为循环检查条件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">if</span> !condition() &#123;</span><br><span class="line">    cond.Wait()</span><br><span class="line">&#125;</span><br><span class="line">mu.Unlock()</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">for</span> !condition() &#123;</span><br><span class="line">    cond.Wait()</span><br><span class="line">&#125;</span><br><span class="line">mu.Unlock()</span><br></pre></td></tr></table></figure><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>ABA问题是指在并发环境中，线程读取共享变量的值为A，准备通过CAS更新时，变量可能被其他线程修改为B后再改回A。由于CAS只检查值是否为A，线程误认为变量未被修改，执行更新操作，导致逻辑错误。</p><ul><li>可能导致数据不一致（如无锁栈中重复使用已释放的内存）。</li><li>破坏程序逻辑，尤其在涉及指针或资源管理的场景。</li></ul><p>任何基于CAS操作的并发控制机制，比如非阻塞锁（自旋锁、乐观锁）、无锁数据结构等，都会引发ABA问题。<br>涉及内存重用（如指针回收后重新分配相同地址）也会引发。</p><p>ABA问题的核心是CAS无法区分“值未变”和“值变回原值”。</p><p>解决方法：</p><ul><li>版本号&#x2F;时间戳：CAS检查值和版本，两次CAS，分别比较。</li><li>双字CAS（Compare-And-Swap-Double），同时比较两个值（如值和版本号）：单次CAS，需要硬件支持DCAS。</li><li>垃圾回收：垃圾回收可以避免指针立即重用，降低ABA问题风险。</li><li>Tagged Pointers：在指针中嵌入版本信息，CAS操作检查整个指针（值+版本），避免ABA问题，复杂实现。</li><li>避免指针重用：使用新分配内存或对象池，避免值恢复原状。</li><li>阻塞锁：如sync.Mutex，完全避免ABA。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在并发编程中，锁是用于同步线程、避免数据竞争和确保线程安全的重要机制。&lt;/p&gt;
&lt;h2 id=&quot;互斥锁（Mutex）&quot;&gt;&lt;a href=&quot;#互斥锁（Mutex）&quot; class=&quot;headerlink&quot; title=&quot;互斥锁（Mutex）&quot;&gt;&lt;/a&gt;互斥锁（Mutex）&lt;/h</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://cooooing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并发" scheme="https://cooooing.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="锁" scheme="https://cooooing.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>时间轮</title>
    <link href="https://cooooing.github.io/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/%E6%97%B6%E9%97%B4%E8%BD%AE/"/>
    <id>https://cooooing.github.io/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/%E6%97%B6%E9%97%B4%E8%BD%AE/</id>
    <published>2025-07-23T14:29:39.000Z</published>
    <updated>2025-07-23T14:29:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>时间轮（Timing Wheel）是一种高效的时间管理数据结构，广泛应用于网络协议、操作系统、定时任务调度等领域。<br>时间轮的核心思想是将时间划分为多个“槽”（slot），每个槽对应一个时间单位，并通过指针的旋转来管理定时任务。</p><h2 id="时间轮的两种设计"><a href="#时间轮的两种设计" class="headerlink" title="时间轮的两种设计"></a>时间轮的两种设计</h2><p>时间轮由多个时间槽组成，每个时间槽对应一个时间单位（如1毫秒、1秒等），是它所支持的最小粒度。<br>时间轮的核心是一个环形数组，数组的每个元素代表一个时间槽。时间轮有一个指针，指向当前的时间槽，随着时间的推进，指针会顺时针移动，类似于钟表的指针。</p><ol><li><strong>初始化</strong>：时间轮初始化时，所有时间槽为空。</li><li><strong>添加任务</strong>：当需要添加一个定时任务时，系统会根据任务的延迟时间计算出它应该被放置在哪个时间槽中。例如，如果当前指针指向第 <code>n</code> 个槽，任务的延迟时间为 <code>t</code>，每个槽的时间单位为 <code>Δt</code>，则任务应被放置在 <code>(n + t / Δt) % N</code> 个槽中（其中 <code>N</code> 是时间轮的总槽数）。</li><li><strong>指针移动</strong>：每隔一个时间单位（如1毫秒），指针向前移动一个槽。</li><li><strong>任务执行</strong>：当指针到达某个槽时，该槽中的所有任务都会被执行。</li></ol><p>为了支持更长的定时任务，有两个拓展时间轮的设计。多层时间轮和记录圈数的时间轮。</p><p><strong>多层时间轮模仿了现实世界中的时钟结构：秒针、分针、时针分别代表不同层级的时间单位。每一层时间轮负责一个时间单位（如秒、分、小时），低层时间轮每完成一圈，上层时间轮前进一格。</strong></p><p>例如：<br>第一层：每个槽代表1秒，共60槽（代表1分钟）<br>第二层：每个槽代表1分钟，共60槽（代表1小时）<br>第三层：每个槽代表1小时，共24槽（代表1天）</p><p>每隔一个时间单位（如1秒），最底层时间轮指针移动<br>如果最底层完成一圈，第二层移动一格<br>如果第二层完成一圈，第三层移动一格<br>每当最底层的指针移动到某个槽时，执行该槽中的所有任务。<br>当其他层的指针移动到某个槽时，将该槽中的任务加入下一层的时间轮。<strong>高层轮的任务只是“占位符”，真正的执行在最底层（秒轮）进行。</strong></p><p>例如一个任务在 1小时2分钟3秒后执行。当前时间为21:30:02，任务在22:32:05执行。</p><table><thead><tr><th>层级</th><th>槽号</th><th>说明</th></tr></thead><tbody><tr><td>时轮</td><td>22</td><td>1小时后触发，触发后将任务推进到分轮</td></tr><tr><td>分轮</td><td>32</td><td>32分钟后触发，触发后将任务推进到秒轮</td></tr><tr><td>秒轮</td><td>5</td><td>5秒后执行最终任务</td></tr></tbody></table><p>它支持非常长延时的任务，并且内存占用较低，时间复杂度为O(1)。但实现复杂，需要处理多级时间轮联动。</p><p><strong>记录圈数的时间轮在每个槽中不仅记录任务，还记录该任务需要等待的圈数（round）。指针每移动一圈，所有任务的圈数减一，当圈数为零时执行任务。</strong></p><p>它是一个固定大小的时间轮（如32或64个槽）。每个槽是一个任务列表，每个任务额外记录圈数。</p><p>每次指针移动一个槽<br>遍历当前槽中所有任务：如果任务的round &gt; 0，round -&#x3D; 1，如果 round &#x3D;&#x3D; 0，执行任务</p><p>它的结构简单易于实现，支持较长的延迟，时间复杂度也为O(1)。但它每次移动指针时需要遍历当前槽中的所有任务。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这里实现记录圈数方式的时间轮。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> timewheel</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;container/list&quot;</span></span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/orcaman/concurrent-map/v2&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/panjf2000/ants/v2&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/sirupsen/logrus&quot;</span></span><br><span class="line"><span class="string">&quot;runtime/debug&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// TimeWheel 核心结构体</span></span><br><span class="line"><span class="keyword">type</span> TimeWheel <span class="keyword">struct</span> &#123;</span><br><span class="line">interval          time.Duration <span class="comment">// 时间轮的精度</span></span><br><span class="line">slots             []*list.List  <span class="comment">// 时间轮每个位置存储的Task列表</span></span><br><span class="line">ticker            *time.Ticker  <span class="comment">// 时间轮的计时器</span></span><br><span class="line">currentPos        <span class="type">int</span>           <span class="comment">// 时间轮当前的位置</span></span><br><span class="line">slotNums          <span class="type">int</span>           <span class="comment">// 时间轮的齿轮数 interval*slotNums就是时间轮转一圈走过的时间</span></span><br><span class="line">addTaskChannel    <span class="keyword">chan</span> *Task</span><br><span class="line">removeTaskChannel <span class="keyword">chan</span> *Task</span><br><span class="line">stopChannel       <span class="keyword">chan</span> <span class="type">bool</span></span><br><span class="line">taskRecords       cmap.ConcurrentMap[<span class="type">string</span>, *list.Element] <span class="comment">// Map结构来存储Task对象，key是Task.key，value是Task在双向链表中的存储对象list.Element</span></span><br><span class="line">isRunning         <span class="type">bool</span></span><br><span class="line">pool              *ants.Pool <span class="comment">// 协程池</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Job 需要执行的Job的函数结构体</span></span><br><span class="line"><span class="keyword">type</span> Job <span class="function"><span class="keyword">func</span><span class="params">(task *Task)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Task 时间轮上需要执行的任务</span></span><br><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> &#123;</span><br><span class="line">Key         <span class="type">string</span>        <span class="comment">// 用来标识task对象，是唯一的</span></span><br><span class="line">Interval    time.Duration <span class="comment">// 任务周期</span></span><br><span class="line">Times       <span class="type">int</span>           <span class="comment">// 任务需要执行的次数，如果需要一直执行，设置成-1</span></span><br><span class="line">Job         Job           <span class="comment">// 任务需要执行的Job</span></span><br><span class="line">createdTime time.Time     <span class="comment">// 任务的创建时间</span></span><br><span class="line">pos         <span class="type">int</span>           <span class="comment">// 任务在轮的位置</span></span><br><span class="line">circle      <span class="type">int</span>           <span class="comment">// 任务需要在轮走多少圈才能执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ErrDuplicateTaskKey is an definedError for duplicate task key</span></span><br><span class="line"><span class="keyword">var</span> ErrDuplicateTaskKey = errors.New(<span class="string">&quot;duplicate task key&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ErrTaskKeyNotFount is an definedError when task key is not found</span></span><br><span class="line"><span class="keyword">var</span> ErrTaskKeyNotFount = errors.New(<span class="string">&quot;task key doesn&#x27;t existed in task list, please check your input&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewTimeWheel 初始化一个TimeWheel对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTimeWheel</span><span class="params">(interval time.Duration, slotNums <span class="type">int</span>)</span></span> *TimeWheel &#123;</span><br><span class="line"><span class="keyword">if</span> interval &lt;= <span class="number">0</span> || slotNums &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">pool, err := ants.NewPool(</span><br><span class="line"><span class="number">16</span>,</span><br><span class="line">ants.WithPreAlloc(<span class="literal">true</span>),</span><br><span class="line">ants.WithNonblocking(<span class="literal">true</span>),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.Errorf(<span class="string">&quot;init [timewhell] ants pool failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">tw := &amp;TimeWheel&#123;</span><br><span class="line">interval:          interval,</span><br><span class="line">slots:             <span class="built_in">make</span>([]*list.List, slotNums),</span><br><span class="line">currentPos:        <span class="number">0</span>,</span><br><span class="line">slotNums:          slotNums,</span><br><span class="line">addTaskChannel:    <span class="built_in">make</span>(<span class="keyword">chan</span> *Task, <span class="number">16</span>),</span><br><span class="line">removeTaskChannel: <span class="built_in">make</span>(<span class="keyword">chan</span> *Task, <span class="number">16</span>),</span><br><span class="line">stopChannel:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>),</span><br><span class="line">taskRecords:       cmap.New[*list.Element](),</span><br><span class="line">isRunning:         <span class="literal">false</span>,</span><br><span class="line">pool:              pool,</span><br><span class="line">&#125;</span><br><span class="line">tw.initSlots()</span><br><span class="line"><span class="keyword">return</span> tw</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start 启动时间轮</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimeWheel)</span></span> Start() &#123;</span><br><span class="line">tw.ticker = time.NewTicker(tw.interval)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(tw *TimeWheel)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-tw.ticker.C:</span><br><span class="line">tw.checkAndRunTask()</span><br><span class="line"><span class="keyword">case</span> task := &lt;-tw.addTaskChannel:</span><br><span class="line">tw.addTask(task, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">case</span> task := &lt;-tw.removeTaskChannel:</span><br><span class="line">tw.removeTask(task)</span><br><span class="line"><span class="keyword">case</span> &lt;-tw.stopChannel:</span><br><span class="line">tw.ticker.Stop()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(tw)</span><br><span class="line">tw.isRunning = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop 关闭时间轮</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimeWheel)</span></span> Stop() &#123;</span><br><span class="line">tw.stopChannel &lt;- <span class="literal">true</span></span><br><span class="line">tw.isRunning = <span class="literal">false</span></span><br><span class="line">tw.pool.Release()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IsRunning 检查全局时间轮是否在正常运行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimeWheel)</span></span> IsRunning() <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> tw.isRunning</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exist 检查任务是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimeWheel)</span></span> Exist(key <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">_, ok := tw.taskRecords.Get(key)</span><br><span class="line"><span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetTaskTimes 获取任务剩余执行次数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimeWheel)</span></span> GetTaskTimes(key <span class="type">string</span>) <span class="type">int</span> &#123;</span><br><span class="line">t, ok := tw.taskRecords.Get(key)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t.Value.(*Task).Times</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddTask 向时间轮添加固定周期任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimeWheel)</span></span> AddTask(task *Task) <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> task.Interval &lt;= <span class="number">0</span> || task.Key == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;invalid task params&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查Task.Key是否已经存在</span></span><br><span class="line">_, ok := tw.taskRecords.Get(task.Key)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="keyword">return</span> ErrDuplicateTaskKey</span><br><span class="line">&#125;</span><br><span class="line">task.createdTime = time.Now()</span><br><span class="line">tw.addTaskChannel &lt;- task</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RemoveTask 从时间轮删除任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimeWheel)</span></span> RemoveTask(key <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> key == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查该Task是否存在</span></span><br><span class="line">val, ok := tw.taskRecords.Get(key)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> ErrTaskKeyNotFount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task := val.Value.(*Task)</span><br><span class="line">tw.removeTaskChannel &lt;- task</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化时间轮，每个轮上的卡槽用一个双向队列表示，便于插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimeWheel)</span></span> initSlots() &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; tw.slotNums; i++ &#123;</span><br><span class="line">tw.slots[i] = list.New()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查该轮点位上的Task，看哪个需要执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimeWheel)</span></span> checkAndRunTask() &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取该轮位置的双向链表</span></span><br><span class="line">currentList := tw.slots[tw.currentPos]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> currentList != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">for</span> item := currentList.Front(); item != <span class="literal">nil</span>; &#123;</span><br><span class="line">task, ok := item.Value.(*Task)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">item = item.Next()</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">next := item.Next()</span><br><span class="line"><span class="keyword">if</span> task.circle &gt; <span class="number">0</span> &#123;</span><br><span class="line">task.circle--</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> task.Job != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 使用协程池执行任务</span></span><br><span class="line">err := tw.pool.Submit(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">stack := debug.Stack()</span><br><span class="line">logrus.Errorf(<span class="string">&quot;task %v panic: %v %s\n&quot;</span>, task.Key, err, <span class="type">string</span>(stack))</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">task.Job(task)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.Errorf(<span class="string">&quot;task %v submit failed: %v\n&quot;</span>, task.Key, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">logrus.Warnf(<span class="string">&quot;The task %s don&#x27;t have job to run\n&quot;</span>, task.Key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tw.taskRecords.Remove(task.Key)</span><br><span class="line">currentList.Remove(item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> task.Times &lt; <span class="number">0</span> &#123;</span><br><span class="line">tw.addTask(task, <span class="literal">true</span>) <span class="comment">// 无限次，继续添加</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> task.Times &gt; <span class="number">1</span> &#123;</span><br><span class="line">task.Times--</span><br><span class="line">tw.addTask(task, <span class="literal">true</span>) <span class="comment">// 剩余次数大于1，继续添加</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">item = next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 轮前进一步</span></span><br><span class="line">tw.currentPos = (tw.currentPos + <span class="number">1</span>) % tw.slotNums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加任务的内部函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimeWheel)</span></span> addTask(task *Task, byInterval <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> pos, circle <span class="type">int</span></span><br><span class="line"><span class="comment">// 使用任务周期或创建时间生成</span></span><br><span class="line"><span class="keyword">if</span> byInterval &#123;</span><br><span class="line">pos, circle = tw.getPosAndCircleByInterval(task.Interval)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pos, circle = tw.getPosAndCircleByCreatedTime(task.createdTime, task.Interval)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task.circle = circle</span><br><span class="line">task.pos = pos</span><br><span class="line"></span><br><span class="line">element := tw.slots[pos].PushBack(task)</span><br><span class="line">tw.taskRecords.Set(task.Key, element)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除任务的内部函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimeWheel)</span></span> removeTask(task *Task) &#123;</span><br><span class="line">val, ok := tw.taskRecords.Get(task.Key)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">tw.taskRecords.Remove(task.Key)</span><br><span class="line"><span class="keyword">if</span> t, ok := val.Value.(*Task); ok &amp;&amp; t.pos &lt; tw.slotNums &#123;</span><br><span class="line">tw.slots[t.pos].Remove(val)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数通过任务的周期来计算下次执行的位置和圈数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimeWheel)</span></span> getPosAndCircleByInterval(d time.Duration) (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">delayMs := <span class="type">int</span>(d.Milliseconds())</span><br><span class="line">intervalMs := <span class="type">int</span>(tw.interval.Milliseconds())</span><br><span class="line">ticks := delayMs / intervalMs</span><br><span class="line">circle := ticks / tw.slotNums</span><br><span class="line">pos := (tw.currentPos + ticks) % tw.slotNums</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特殊case，当计算的位置和当前位置重叠时，因为当前位置已经走过了，所以circle需要减一</span></span><br><span class="line"><span class="keyword">if</span> pos == tw.currentPos &amp;&amp; circle != <span class="number">0</span> &#123;</span><br><span class="line">circle--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pos, circle</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数用任务的创建时间来计算下次执行的位置和圈数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimeWheel)</span></span> getPosAndCircleByCreatedTime(createdTime time.Time, d time.Duration) (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">delayMs := <span class="type">int</span>(d.Milliseconds())</span><br><span class="line">intervalMs := <span class="type">int</span>(tw.interval.Milliseconds())</span><br><span class="line">ticksPassed := <span class="type">int</span>(time.Since(createdTime).Milliseconds()) / intervalMs</span><br><span class="line">totalTicks := delayMs / intervalMs</span><br><span class="line">remainingTicks := totalTicks - ticksPassed</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> remainingTicks &lt;= <span class="number">0</span> &#123;</span><br><span class="line">remainingTicks = <span class="number">1</span> <span class="comment">// 防止立即过期</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">circle := remainingTicks / tw.slotNums</span><br><span class="line">pos := (tw.currentPos + remainingTicks) % tw.slotNums</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特殊case，当计算的位置和当前位置重叠时，因为当前位置已经走过了，所以circle需要减一</span></span><br><span class="line"><span class="keyword">if</span> pos == tw.currentPos &amp;&amp; circle != <span class="number">0</span> &#123;</span><br><span class="line">circle--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pos, circle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;catventure-idle-server/internal/common/timewheel&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/sirupsen/logrus&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTimeWheel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">tw := timewheel.NewTimeWheel(time.Second, <span class="number">60</span>)</span><br><span class="line">tw.Start()</span><br><span class="line"></span><br><span class="line">err = tw.AddTask(&amp;timewheel.Task&#123;</span><br><span class="line">Key:      <span class="string">&quot;test1&quot;</span>,</span><br><span class="line">Interval: time.Second * <span class="number">5</span>,</span><br><span class="line">Times:    <span class="number">-1</span>,</span><br><span class="line">Job: <span class="function"><span class="keyword">func</span><span class="params">(task *timewheel.Task)</span></span> &#123;</span><br><span class="line">logrus.Infof(<span class="string">&quot;task %s run at %s\n&quot;</span>, task.Key, time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.Errorf(<span class="string">&quot;add task failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">err = tw.AddTask(&amp;timewheel.Task&#123;</span><br><span class="line">Key:      <span class="string">&quot;test2&quot;</span>,</span><br><span class="line">Interval: time.Second * <span class="number">1</span>,</span><br><span class="line">Times:    <span class="number">10</span>,</span><br><span class="line">Job: <span class="function"><span class="keyword">func</span><span class="params">(task *timewheel.Task)</span></span> &#123;</span><br><span class="line">logrus.Infof(<span class="string">&quot;task %s run at %s\n&quot;</span>, task.Key, time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.Errorf(<span class="string">&quot;add task failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second * <span class="number">30</span>) <span class="comment">// 休眠30s，查看运行结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   TestTimeWheel</span><br><span class="line">time=&quot;2025-07-24T22:24:57+08:00&quot; level=info msg=&quot;task test2 run at 2025-07-24 22:24:57\n&quot;</span><br><span class="line">time=&quot;2025-07-24T22:24:58+08:00&quot; level=info msg=&quot;task test2 run at 2025-07-24 22:24:58\n&quot;</span><br><span class="line">time=&quot;2025-07-24T22:24:59+08:00&quot; level=info msg=&quot;task test2 run at 2025-07-24 22:24:59\n&quot;</span><br><span class="line">time=&quot;2025-07-24T22:25:00+08:00&quot; level=info msg=&quot;task test2 run at 2025-07-24 22:25:00\n&quot;</span><br><span class="line">time=&quot;2025-07-24T22:25:00+08:00&quot; level=info msg=&quot;task test1 run at 2025-07-24 22:25:00\n&quot;</span><br><span class="line">time=&quot;2025-07-24T22:25:01+08:00&quot; level=info msg=&quot;task test2 run at 2025-07-24 22:25:01\n&quot;</span><br><span class="line">time=&quot;2025-07-24T22:25:02+08:00&quot; level=info msg=&quot;task test2 run at 2025-07-24 22:25:02\n&quot;</span><br><span class="line">time=&quot;2025-07-24T22:25:03+08:00&quot; level=info msg=&quot;task test2 run at 2025-07-24 22:25:03\n&quot;</span><br><span class="line">time=&quot;2025-07-24T22:25:04+08:00&quot; level=info msg=&quot;task test2 run at 2025-07-24 22:25:04\n&quot;</span><br><span class="line">time=&quot;2025-07-24T22:25:05+08:00&quot; level=info msg=&quot;task test2 run at 2025-07-24 22:25:05\n&quot;</span><br><span class="line">time=&quot;2025-07-24T22:25:05+08:00&quot; level=info msg=&quot;task test1 run at 2025-07-24 22:25:05\n&quot;</span><br><span class="line">time=&quot;2025-07-24T22:25:10+08:00&quot; level=info msg=&quot;task test1 run at 2025-07-24 22:25:10\n&quot;</span><br><span class="line">time=&quot;2025-07-24T22:25:15+08:00&quot; level=info msg=&quot;task test1 run at 2025-07-24 22:25:15\n&quot;</span><br><span class="line">time=&quot;2025-07-24T22:25:20+08:00&quot; level=info msg=&quot;task test1 run at 2025-07-24 22:25:20\n&quot;</span><br><span class="line">--- PASS: TestTimeWheel (30.00s)</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;时间轮（Timing Wheel）是一种高效的时间管理数据结构，广泛应用于网络协议、操作系统、定时任务调度等领域。&lt;br&gt;时间轮的核心思想是</summary>
      
    
    
    
    <category term="编程记录" scheme="https://cooooing.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="go" scheme="https://cooooing.github.io/tags/go/"/>
    
    <category term="定时任务" scheme="https://cooooing.github.io/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
    <category term="算法" scheme="https://cooooing.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="时间轮" scheme="https://cooooing.github.io/tags/%E6%97%B6%E9%97%B4%E8%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>烟雨西湖</title>
    <link href="https://cooooing.github.io/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E7%83%9F%E9%9B%A8%E8%A5%BF%E6%B9%96/"/>
    <id>https://cooooing.github.io/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E7%83%9F%E9%9B%A8%E8%A5%BF%E6%B9%96/</id>
    <published>2025-06-29T09:57:54.000Z</published>
    <updated>2025-06-29T09:57:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>来杭州一个月了，总算是去了次西湖。<br>五月中到杭州来，碰到朋友换工作六月中来杭州。算是他乡遇故知了，缘分。<br>于是在一个周日的雨天，一起去西湖。（为什么是雨天呢，我也不知道。可能雨中的西湖更有意境吧</p><p>在江城站会合，先去吃了片川儿垫垫肚子。<br>然后准备去鼓楼。</p><p>这是望仙阁上拍的，可以看到吴山上的寺庙和鼓楼堂（基督教堂）。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E7%83%9F%E9%9B%A8%E8%A5%BF%E6%B9%96/%E6%9C%9B%E4%BB%99%E9%98%811.jpg"                        alt="望仙阁1"                 ><br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E7%83%9F%E9%9B%A8%E8%A5%BF%E6%B9%96/%E6%9C%9B%E4%BB%99%E9%98%812.jpg"                        alt="望仙阁2"                 ></p><p>后面是鼓楼，进去是南宋书房，有很多文创和冰箱贴。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E7%83%9F%E9%9B%A8%E8%A5%BF%E6%B9%96/%E5%8D%97%E5%AE%8B%E4%B9%A6%E6%88%BF1.jpg"                        alt="南宋书房1"                 ><br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E7%83%9F%E9%9B%A8%E8%A5%BF%E6%B9%96/%E5%8D%97%E5%AE%8B%E4%B9%A6%E6%88%BF2.jpg"                        alt="南宋书房2"                 ><br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E7%83%9F%E9%9B%A8%E8%A5%BF%E6%B9%96/%E9%BC%93%E6%A5%BC.jpg"                        alt="鼓楼"                 ></p><p>再往里就是河坊街，正常景区的商业街。很多小吃，还有中药店（叶种德堂）。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E7%83%9F%E9%9B%A8%E8%A5%BF%E6%B9%96/%E5%8F%B6%E7%A7%8D%E5%BE%B7%E5%A0%82.jpg"                        alt="叶种德堂"                 ></p><p>朱炳仁铜雕艺术博物馆，全是铜雕的工艺品。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E7%83%9F%E9%9B%A8%E8%A5%BF%E6%B9%96/%E6%9C%B1%E7%82%B3%E4%BB%81%E9%93%9C%E9%9B%95%E8%89%BA%E6%9C%AF%E5%8D%9A%E7%89%A9%E9%A6%86.jpg"                        alt="朱炳仁铜雕艺术博物馆"                 ></p><p>杭州博物馆，杭州出土的文物，历史等。杭州现在有大大小小两百多家博物馆。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E7%83%9F%E9%9B%A8%E8%A5%BF%E6%B9%96/%E6%9D%AD%E5%B7%9E%E5%8D%9A%E7%89%A9%E9%A6%861.jpg"                        alt="杭州博物馆1"                 ><br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E7%83%9F%E9%9B%A8%E8%A5%BF%E6%B9%96/%E6%9D%AD%E5%B7%9E%E5%8D%9A%E7%89%A9%E9%A6%862.jpg"                        alt="杭州博物馆2"                 ></p><p>博物馆逛了很久，出来后两三点左右，去吃了蟹黄面。第一口很鲜，非常不错。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E7%83%9F%E9%9B%A8%E8%A5%BF%E6%B9%96/%E8%9F%B9%E9%BB%84%E9%9D%A21.jpg"                        alt="蟹黄面1"                 ><br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E7%83%9F%E9%9B%A8%E8%A5%BF%E6%B9%96/%E8%9F%B9%E9%BB%84%E9%9D%A22.jpg"                        alt="蟹黄面2"                 ><br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E7%83%9F%E9%9B%A8%E8%A5%BF%E6%B9%96/%E8%9F%B9%E9%BB%84%E9%9D%A23.jpg"                        alt="蟹黄面3"                 ></p><p>再然后就是西湖了。断桥残雪、苏堤。雨天人还是挺多，不过雨天的意境肯定也不一样。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E7%83%9F%E9%9B%A8%E8%A5%BF%E6%B9%96/%E8%A5%BF%E6%B9%961.jpg"                        alt="西湖1"                 ><br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E7%83%9F%E9%9B%A8%E8%A5%BF%E6%B9%96/%E8%A5%BF%E6%B9%962.jpg"                        alt="西湖2"                 ><br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E7%83%9F%E9%9B%A8%E8%A5%BF%E6%B9%96/%E8%A5%BF%E6%B9%963.jpg"                        alt="西湖3"                 ><br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E7%83%9F%E9%9B%A8%E8%A5%BF%E6%B9%96/%E8%A5%BF%E6%B9%964.jpg"                        alt="西湖4"                 ></p><p>烟雨朦胧的感觉<br>最后，全都淋湿了。不过也很久没有这么淋过雨了，还是挺舒服的。</p><p>20公里！<br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E7%83%9F%E9%9B%A8%E8%A5%BF%E6%B9%96/%E6%AD%A5%E6%95%B0.png"                        alt="步数"                 ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;来杭州一个月了，总算是去了次西湖。&lt;br&gt;五月中到杭州来，碰到朋友换工作六月中来杭州。算是他乡遇故知了，缘分。&lt;br&gt;于是在一个周日的雨天，一起去西湖。（为什么是雨天呢，我也不知道。可能雨中的西湖更有意境吧&lt;/p&gt;
&lt;p&gt;在江城站会合，先去吃了片川儿垫垫肚子。&lt;br&gt;然后准</summary>
      
    
    
    
    <category term="记录生活" scheme="https://cooooing.github.io/categories/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="旅游" scheme="https://cooooing.github.io/tags/%E6%97%85%E6%B8%B8/"/>
    
    <category term="西湖" scheme="https://cooooing.github.io/tags/%E8%A5%BF%E6%B9%96/"/>
    
  </entry>
  
  <entry>
    <title>记第一次离职</title>
    <link href="https://cooooing.github.io/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%A6%BB%E8%81%8C/"/>
    <id>https://cooooing.github.io/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%A6%BB%E8%81%8C/</id>
    <published>2025-06-11T15:14:33.000Z</published>
    <updated>2025-06-11T15:14:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>很久没有写博客了，回顾下近况吧。</p><p>最大的变动就是工作了，劳动节前提了离职，5月16号上完最后一天半。然后就开始了两周的休息。<br>第一周主要去医院做了体检，和朋友吃了个饭。也是告别待了快两年的南京（两年了也没怎么把南京的景点玩玩，有点可惜<br>周一体检，周四拿到体检报告。除了口腔有点问题（智齿有点阻生，浅龋和1度牙结石），其他都非常正常。也许得找个时间去看看牙，之前根管治疗的牙还没有补。</p><p>回到工作相关，没记错的话，是在23年9月26号开始实习，24年7月1号签的劳动合同，到今年5月16号离职结束。也是待了快二十个月（对于一份工作来说，感觉是有些短<br>跟同事相处的感觉也是很不错了，和同事一起租房住了十个月（血亏两个月房租<br>下面是娟姐送的抱枕<br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%A6%BB%E8%81%8C/%E6%8A%B1%E6%9E%95.jpg"                        alt="抱枕"                 ></p><p>关于什么时候决定离开，比实际要早的很多。<br>最现实的就是我能在南京拿到的薪资比其他的城市低（上海杭州这些互联网发达的地方）。<br>其次重要的是个人的成长，其实早就一眼看到头了。或许我继续待在那里三年五年，多少会接触到新的东西，但对于我来说有些太慢了。<br>四月份左右去用户现场碰到我的 leader，他还会问我最近学了什么。说<strong>人的技术热情在刚工作的两三年是最高的，成长也是最快的。后面就不会再有了。</strong><br>这段我还是比较认同的，在刚工作的时候，接触到企业协作，与个人做事是完全不一样的。越大的企业确实如此吧。<br>为了适应工作，肯定会多去学习。但随着工作的深入，如果不是有兴趣支持，这份热情很快就会消磨。（当兴趣爱好成为工作，很容易消磨掉兴趣。肯定有人说过不要将兴趣爱好当成工作的话</p><p>话说回来，当时在看 Kafka（也记了两篇笔记）。<strong>他和我说的另一个主题大概就是要关注架构层面的设计，使用层面都差不多，就是如何使用API，看着文档很快就能上手。</strong><br>这个怎么说呢，我觉得架构层面需要服务具体的业务，同时也跟并发编程一样，需要长时间的运行才能暴露出足够多的问题。<br>但更加关注架构层面肯定也是没有问题的，和并发编程一样，思考各种可能出现的情况，会有什么问题，怎么解决。<br>架构层面其实很难离开分布式和微服务，虽然我认为大部分公司单体的架构已经足够使用。<br>这些都多少会影响我后面的学习方向，go的学习应该是很早之前了，真正想java转go可能只是今年年初。但语言只是微不足道的一部分…（这里省略吧，后续的方向暂时还没有想好</p><p>关于新的工作，它其实没有我想象中那样。<br>新的工作是在杭州的一个小公司，相比上家，在人员配置和开发流程上差的是非常大的。感觉是第一次组建开发团队。<br>用go写了两周，不得不感慨java生态上的全面。java的繁琐其实也不是java本身，印象中有句话是这么说的：<strong>复杂度不会消失，只会被转移到系统的各个地方。</strong><br>大概是<a class="link"   href="https://en.wikipedia.org/wiki/Law_of_conservation_of_complexity" >泰斯勒定律（Tesler’s Law），又称复杂度守恒定律（Law of Conservation of Complexity）<i class="fas fa-external-link-alt"></i></a><br>spring是个非常厉害的框架，它的抽象程度也是非常之高（当初还去读源码，太不自量力了）。它将系统配置、拓展性等大部分业务无关的复杂度都隐藏在了框架内部，使得对业务的开发变得非常简单，关注的点也非常少。</p><p>新同事是三年经验的go开发，最近和他的话题主要在 go、docker 和 kubernetes。<br>今天下班的路上，也许是看出了我的迷茫，跟我说了一些云原生的方向。kubernetes、服务网格 istio、链路之类的东西，都在云原生方向之中。<br>看来 kubernetes 是要深度使用的了，虽然我觉得大部分业务都用不上。我现在倒是更倾向单体架构，到单机扛不住的时候可以上分布式（这个需要单体开发时就注意分布式部分，否则改造会比较麻烦），到分布式服务太多运维管理上顶不住的时候才是上kubernetes的时候。<br>倒也是符合架构的发展历史，不管是架构还是框架、中间件都是为了解决对应具体问题而出现的解决方案。分布式与微服务还是有区别的，微服务大概就是服务划分、拆分之后的各种服务的分布式，服务间的依赖通过rpc解耦。（描述得比较抽象了</p><p>最后，写到这里已经不早了，该结束了。<br>对于以后，大方向已经定下来了。具体什么方向可能还得探索下。<br>另，希望新工作顺利。也许会留在杭州。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很久没有写博客了，回顾下近况吧。&lt;/p&gt;
&lt;p&gt;最大的变动就是工作了，劳动节前提了离职，5月16号上完最后一天半。然后就开始了两周的休息。&lt;br&gt;第一周主要去医院做了体检，和朋友吃了个饭。也是告别待了快两年的南京（两年了也没怎么把南京的景点玩玩，有点可惜&lt;br&gt;周一体检，周</summary>
      
    
    
    
    <category term="记录生活" scheme="https://cooooing.github.io/categories/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="工作" scheme="https://cooooing.github.io/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes本地环境搭建及应用部署</title>
    <link href="https://cooooing.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kubernetes%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/"/>
    <id>https://cooooing.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kubernetes%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/</id>
    <published>2025-04-23T14:01:51.000Z</published>
    <updated>2025-04-23T14:01:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础环境准备（可选）"><a href="#基础环境准备（可选）" class="headerlink" title="基础环境准备（可选）"></a>基础环境准备（可选）</h2><h3 id="虚拟机配置"><a href="#虚拟机配置" class="headerlink" title="虚拟机配置"></a>虚拟机配置</h3><p>基础环境这里选择 multipass 虚拟机。（但只是使用它创建虚拟机）<br>当然，如果有真实物理机，并且他们网络是直通的，那可以省去很多配置的麻烦。这里大部分关于虚拟机的配置应该都可以省略。<br>但很可惜，我并没有那么多机器或者云服务器。但好在我的电脑（windows11）内存有64G，足够我随意的折腾。</p><p>创建三台虚拟机（一主二从）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multipass launch --name=master --cpus=2 --m=4096MiB -d 20G 24.04</span><br><span class="line">multipass launch --name=worker1 --cpus=2 --m=4096MiB -d 20G 24.04</span><br><span class="line">multipass launch --name=worker2 --cpus=2 --m=4096MiB -d 20G 24.04</span><br></pre></td></tr></table></figure><h3 id="基础网络配置（固定ip配置）"><a href="#基础网络配置（固定ip配置）" class="headerlink" title="基础网络配置（固定ip配置）"></a>基础网络配置（固定ip配置）</h3><p>这里我需要为每台虚拟机都设置一个固定ip，防止机器重启后ip会发生变化，导致需要频繁改一些配置。<strong>Multipass 默认通过 NAT 网络 + DHCP 动态分配 IP</strong><br>将宿主机ip固定为192.168.1.5<br>master 节点的ip为 192.168.1.10<br>worker1 节点的ip为 192.168.1.11<br>worker2 节点的ip为 192.168.1.12</p><p>这里以 master 节点为例，展示配置过程。</p><p>首先打开<strong>Hyper-V 管理器</strong>，右侧<strong>虚拟交换机管理器</strong>，新建虚拟交换机。如下图：<br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kubernetes%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E4%BA%A4%E6%8D%A2%E6%9C%BA.png"                        alt="新建虚拟交换机.png"                 ></p><p>保存之后，来到<strong>网络适配器</strong>，为刚创建的虚拟交换机设置一个固定的ip。<br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kubernetes%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/%E7%BD%91%E7%BB%9C%E9%80%82%E9%85%8D%E5%99%A8.png"                        alt="网络适配器.png"                 ></p><p>修改<code>/etc/netplan/50-cloud-init.yaml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">network:</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">ethernets:</span></span><br><span class="line">    <span class="attr">eth0:</span></span><br><span class="line">      <span class="attr">dhcp4:</span> <span class="literal">no</span></span><br><span class="line">      <span class="attr">addresses:</span> [ <span class="number">192.168</span><span class="number">.1</span><span class="number">.10</span><span class="string">/24</span> ]</span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">to:</span> <span class="string">default</span></span><br><span class="line">          <span class="attr">via:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">      <span class="attr">nameservers:</span></span><br><span class="line">        <span class="attr">addresses:</span> [ <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span> ]</span><br></pre></td></tr></table></figure><p>应用更改并验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">应用更改</span></span><br><span class="line">sudo netplan apply</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">应用更改</span></span><br><span class="line">sudo netplan --debug apply</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查 IP 是否生效</span></span><br><span class="line">ip a show eth0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试网络连通性</span></span><br><span class="line">ping 192.168.1.1</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@master:/etc/netplan$ ip a show eth0</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000</span><br><span class="line">    link/ether 52:54:00:29:3e:e9 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.1.10/24 brd 192.168.1.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 2409:8a20:2a0:6c60:5054:ff:fe29:3ee9/64 scope global dynamic mngtmpaddr noprefixroute</span><br><span class="line">       valid_lft 198387sec preferred_lft 111987sec</span><br><span class="line">    inet6 fe80::5054:ff:fe29:3ee9/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">ubuntu@master:/etc/netplan$ ping 192.168.1.1</span><br><span class="line">PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.1.1: icmp_seq=1 ttl=64 time=7.33 ms</span><br><span class="line">64 bytes from 192.168.1.1: icmp_seq=2 ttl=64 time=3.45 ms</span><br><span class="line">64 bytes from 192.168.1.1: icmp_seq=3 ttl=64 time=3.77 ms</span><br><span class="line">64 bytes from 192.168.1.1: icmp_seq=4 ttl=64 time=4.16 ms</span><br><span class="line">^C</span><br><span class="line">--- 192.168.1.1 ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 3006ms</span><br><span class="line">rtt min/avg/max/mdev = 3.449/4.675/7.326/1.550 ms</span><br></pre></td></tr></table></figure><h3 id="配置域名"><a href="#配置域名" class="headerlink" title="配置域名"></a>配置域名</h3><p>在三台虚拟机的 <code>/etc/hosts</code> 文件末尾添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.10 master</span><br><span class="line">192.168.1.11 worker1</span><br><span class="line">192.168.1.12 worker2</span><br></pre></td></tr></table></figure><h3 id="配置ssh登录"><a href="#配置ssh登录" class="headerlink" title="配置ssh登录"></a>配置ssh登录</h3><p>这里配置ssh密码登录，以方便外部宿主机连接使用。（因为修改为固定ip后，multipass将无法连接到虚拟机）</p><p>设置密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd ubuntu</span><br></pre></td></tr></table></figure><p>修改<code>/etc/ssh/sshd_config</code>配置中的以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 是否允许使用密码登录 SSH</span><br><span class="line">PasswordAuthentication yes</span><br><span class="line"># 是否允许使用公钥认证登录 SSH</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line"># 是否启用 PAM（Pluggable Authentication Modules，可插拔认证模块）</span><br><span class="line">UsePAM no</span><br></pre></td></tr></table></figure><blockquote><p>注意：是否包含<code>Include /etc/ssh/sshd_config.d/*.conf</code>配置<br>它支持包含其他配置文件，从而实现配置的模块化和可维护性。<strong>所有配置会合并，顺序按文件名排序加载，后加载的内容会覆盖前面的设置。</strong></p></blockquote><p>重启 ssh 服务应用更改后，就可以在宿主机使用配好的固定ip进行ssh登录了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart ssh</span><br></pre></td></tr></table></figure><h3 id="配置全局代理"><a href="#配置全局代理" class="headerlink" title="配置全局代理"></a>配置全局代理</h3><p>Linux中，设置全系统代理（包括 GUI 图形界面 + CLI），需要修改<code>/etc/environment</code>文件；仅为 shell 用户（终端）设置代理，需要修改<code>/etc/profile</code>文件；为单用户设置代理，需要修改<code>~/.bashrc</code>文件。</p><p><code>/etc/environment</code>文件添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http_proxy=&quot;http://192.168.1.5:7890&quot;</span><br><span class="line">https_proxy=&quot;http://192.168.1.5:7890&quot;</span><br><span class="line">all_proxy=&quot;socks5://192.168.1.5:7890&quot;</span><br><span class="line">no_proxy=&quot;localhost,127.0.0.1,::1&quot;</span><br></pre></td></tr></table></figure><p>重启应用更改。</p><p><code>/etc/profile</code>或者<code>~/.bashrc</code>文件添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://192.168.1.5:7890</span><br><span class="line">export https_proxy=http://192.168.1.5:7890</span><br><span class="line">export all_proxy=socks5://192.168.1.5:7890</span><br><span class="line">export no_proxy=&quot;localhost,127.0.0.1,::1&quot;</span><br></pre></td></tr></table></figure><p><code>source /etc/profile</code>或者<code>source ~/.bashrc</code>应用更改。</p><p><strong>取消代理：<code>unset http_proxy https_proxy all_proxy</code></strong></p><p>验证代理是否生效，可以使用<code>curl -v https://www.google.com</code><br>会返回包含类似<code>Connected to 192.168.1.5 (192.168.1.5) port 7890</code>的内容，如下（上述命令返回过长，这里以本地服务为例）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@master:~$ curl -v http://192.168.1.5:8000/api/user/v1/helloworld/ubuntu</span><br><span class="line">* Uses proxy env variable no_proxy == &#x27;localhost,127.0.0.1,::1&#x27;</span><br><span class="line">* Uses proxy env variable http_proxy == &#x27;http://192.168.1.5:7890&#x27;</span><br><span class="line">*   Trying 192.168.1.5:7890...</span><br><span class="line">* Connected to 192.168.1.5 (192.168.1.5) port 7890</span><br><span class="line">&gt; GET http://192.168.1.5:8000/api/user/v1/helloworld/ubuntu HTTP/1.1</span><br><span class="line">&gt; Host: 192.168.1.5:8000</span><br><span class="line">&gt; User-Agent: curl/8.5.0</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt; Proxy-Connection: Keep-Alive</span><br><span class="line">&gt;</span><br><span class="line">&lt; HTTP/1.1 200 OK</span><br><span class="line">&lt; Content-Length: 26</span><br><span class="line">&lt; Connection: keep-alive</span><br><span class="line">&lt; Content-Type: application/json</span><br><span class="line">&lt; Date: Wed, 23 Apr 2025 15:34:03 GMT</span><br><span class="line">&lt; Keep-Alive: timeout=4</span><br><span class="line">&lt; Proxy-Connection: keep-alive</span><br><span class="line">&lt;</span><br><span class="line">* Connection #0 to host 192.168.1.5 left intact</span><br><span class="line">&#123;&quot;message&quot;:&quot;Hello ubuntu&quot;&#125;</span><br></pre></td></tr></table></figure><h2 id="kubernetes-环境搭建"><a href="#kubernetes-环境搭建" class="headerlink" title="kubernetes 环境搭建"></a>kubernetes 环境搭建</h2><h3 id="部署-Server"><a href="#部署-Server" class="headerlink" title="部署 Server"></a>部署 Server</h3><p>这里使用 <a class="link"   href="https://docs.k3s.io/zh/" >K3s - 轻量级 Kubernetes<i class="fas fa-external-link-alt"></i></a> 部署。<br>与 Kubernetes 不同，这里的 Master 节点叫 Server 节点，而 Slave 节点叫 Agent 节点。</p><p>部署 Server 节点 <code>curl -sfL https://get.k3s.io | sh -</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@master:~$ curl -sfL https://get.k3s.io | sh -</span><br><span class="line">[INFO]  Finding release for channel stable</span><br><span class="line">[INFO]  Using v1.32.3+k3s1 as release</span><br><span class="line">[INFO]  Downloading hash https://github.com/k3s-io/k3s/releases/download/v1.32.3+k3s1/sha256sum-amd64.txt</span><br><span class="line">[INFO]  Downloading binary https://github.com/k3s-io/k3s/releases/download/v1.32.3+k3s1/k3s</span><br><span class="line">[INFO]  Verifying binary download</span><br><span class="line">[INFO]  Installing k3s to /usr/local/bin/k3s</span><br><span class="line">[INFO]  Skipping installation of SELinux RPM</span><br><span class="line">[INFO]  Creating /usr/local/bin/kubectl symlink to k3s</span><br><span class="line">[INFO]  Creating /usr/local/bin/crictl symlink to k3s</span><br><span class="line">[INFO]  Creating /usr/local/bin/ctr symlink to k3s</span><br><span class="line">[INFO]  Creating killall script /usr/local/bin/k3s-killall.sh</span><br><span class="line">[INFO]  Creating uninstall script /usr/local/bin/k3s-uninstall.sh</span><br><span class="line">[INFO]  env: Creating environment file /etc/systemd/system/k3s.service.env</span><br><span class="line">[INFO]  systemd: Creating service file /etc/systemd/system/k3s.service</span><br><span class="line">[INFO]  systemd: Enabling k3s unit</span><br><span class="line">Created symlink /etc/systemd/system/multi-user.target.wants/k3s.service → /etc/systemd/system/k3s.service.</span><br><span class="line">[INFO]  systemd: Starting k3s</span><br></pre></td></tr></table></figure><p>查看节点运行状态<code>kubectl get node</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@master:~$ sudo kubectl get node</span><br><span class="line">NAME     STATUS   ROLES                  AGE   VERSION</span><br><span class="line">master   Ready    control-plane,master   78s   v1.32.3+k3s1</span><br></pre></td></tr></table></figure><p>获取 node-token <code>cat /var/lib/rancher/k3s/server/node-token</code> 在部署 Agent 节点的时候需要用到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@master:~$ sudo cat /var/lib/rancher/k3s/server/node-token</span><br><span class="line">K104869223bb6e5c3c1bb95bc7dcc505cb2d5576cf2253e9bd0df1b3a7852f91397::server:368a64fba85ad0718fe841967df1717f</span><br></pre></td></tr></table></figure><h3 id="部署-Agent"><a href="#部署-Agent" class="headerlink" title="部署 Agent"></a>部署 Agent</h3><p>部署 Agent 节点 <code>curl -sfL https://get.k3s.io | K3S_URL=https://server:6443 K3S_TOKEN=token sh -</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@worker1:~$ curl -sfL https://get.k3s.io | K3S_URL=https://master:6443 K3S_TOKEN=K104869223bb6e5c3c1bb95bc7dcc505cb2d5576cf2253e9bd0df1b3a7852f91397::server:368a64fba85ad0718fe841967df1717f sh -</span><br><span class="line">[INFO]  Finding release for channel stable</span><br><span class="line">[INFO]  Using v1.32.3+k3s1 as release</span><br><span class="line">[INFO]  Downloading hash https://github.com/k3s-io/k3s/releases/download/v1.32.3+k3s1/sha256sum-amd64.txt</span><br><span class="line">[INFO]  Downloading binary https://github.com/k3s-io/k3s/releases/download/v1.32.3+k3s1/k3s</span><br><span class="line">[INFO]  Verifying binary download</span><br><span class="line">[INFO]  Installing k3s to /usr/local/bin/k3s</span><br><span class="line">[INFO]  Skipping installation of SELinux RPM</span><br><span class="line">[INFO]  Creating /usr/local/bin/kubectl symlink to k3s</span><br><span class="line">[INFO]  Creating /usr/local/bin/crictl symlink to k3s</span><br><span class="line">[INFO]  Creating /usr/local/bin/ctr symlink to k3s</span><br><span class="line">[INFO]  Creating killall script /usr/local/bin/k3s-killall.sh</span><br><span class="line">[INFO]  Creating uninstall script /usr/local/bin/k3s-agent-uninstall.sh</span><br><span class="line">[INFO]  env: Creating environment file /etc/systemd/system/k3s-agent.service.env</span><br><span class="line">[INFO]  systemd: Creating service file /etc/systemd/system/k3s-agent.service</span><br><span class="line">[INFO]  systemd: Enabling k3s-agent unit</span><br><span class="line">Created symlink /etc/systemd/system/multi-user.target.wants/k3s-agent.service → /etc/systemd/system/k3s-agent.service.</span><br><span class="line">[INFO]  systemd: Starting k3s-agent</span><br></pre></td></tr></table></figure><p>节点都部署完后，节点状态如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@master:~$ sudo kubectl get node</span><br><span class="line">NAME      STATUS   ROLES                  AGE   VERSION</span><br><span class="line">master    Ready    control-plane,master   18m   v1.32.3+k3s1</span><br><span class="line">worker1   Ready    &lt;none&gt;                 29s   v1.32.3+k3s1</span><br><span class="line">worker2   Ready    &lt;none&gt;                 5s    v1.32.3+k3s1</span><br></pre></td></tr></table></figure><p>设置 K3S_URL 参数会使 K3s 以 worker 模式运行。 K3s agent 会在所提供的 URL 上向监听的 K3s 服务器注册。</p><p>到这里，Kubernetes 环境搭建完成。</p><h2 id="创建-Deployment"><a href="#创建-Deployment" class="headerlink" title="创建 Deployment"></a>创建 Deployment</h2><p>创建<code>nginx-deployment.yaml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义 Deployment 基本信息</span></span><br><span class="line"><span class="attr">metadata.name:</span> <span class="string">给这个</span> <span class="string">Deployment</span> <span class="string">起个名字。</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># Deployment 所使用的 API 版本，K8s 1.9+ 都是 apps/v1。</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span> <span class="comment"># 资源类型是 Deployment。</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span> <span class="comment"># Deployment 的名字。</span></span><br><span class="line"><span class="comment"># 定义副本数量和 Pod 选择器</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span> <span class="comment"># 创建副本数量</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span> <span class="comment"># Deployment 会管理所有 带有标签 app=nginx 的 Pod。它必须和后面的模板里的 labels 保持一致。</span></span><br><span class="line">  <span class="comment"># 定义 Pod 模板（template）</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span> <span class="comment"># 为 Pod 打上 app=nginx 标签，方便 selector 识别。</span></span><br><span class="line">    <span class="comment"># 定义容器信息</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span> <span class="comment"># 容器名称</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:latest</span> <span class="comment"># 镜像名称</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span> <span class="comment"># 容器端口</span></span><br></pre></td></tr></table></figure><p>使用 <code>kubectl apply</code> 命令创建 Deployment：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@master:~/apps$ sudo kubectl apply -f nginx-deployment.yaml</span><br><span class="line">deployment.apps/nginx created</span><br></pre></td></tr></table></figure><p>使用<code>kubectl get deployment</code>查看运行状态，使用<code>kubectl get pods</code>查看 Pod 状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@master:~/apps$ sudo kubectl get deployment</span><br><span class="line">NAME    READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx   2/2     2            2           17s</span><br><span class="line">ubuntu@master:~/apps$ sudo kubectl get pods -l app=nginx</span><br><span class="line">NAME                   READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-96b9d695-gfjvq   1/1     Running   0          25s</span><br><span class="line">nginx-96b9d695-w5qxx   1/1     Running   0          25s</span><br></pre></td></tr></table></figure><p>可以看到 Deployment 创建 Pod 的命名规则：<code>${DeploymentName}-${DeploymentUid}-${Hash}</code>。</p><p>使用 <code>kubectl get pod -o wide</code> 查看 Pod 运行状态和 IP 地址，可以看到 nginx 被创建了两个 Pod 副本，分别部署在了 worker1 和 worker2 上面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@master:~/apps$ sudo kubectl get pod -o wide</span><br><span class="line">NAME                   READY   STATUS    RESTARTS   AGE     IP          NODE      NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-96b9d695-gfjvq   1/1     Running   0          8m42s   10.42.2.3   worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-96b9d695-w5qxx   1/1     Running   0          8m42s   10.42.1.3   worker1   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><p>此时的 nginx 还不能被外部访问，他们的 IP 是 Cluster 的内部私有 IP，只能在集群内部访问。<br><strong>并且这些 IP 是浮动的，Pod 重启后，IP 也会变化。</strong><br>这时就需要创建 Service 来解决这个问题。</p><h2 id="创建-Service"><a href="#创建-Service" class="headerlink" title="创建 Service"></a>创建 Service</h2><p>Service 是 Kubernetes 中一种网络抽象，用于为一组 Pod 提供统一访问入口。<br>简单来说，Pod 是会变化的（比如被删除、替换），而 Service 提供一个 固定 IP &#x2F; 名称 &#x2F; 端口，始终指向一组后端 Pod。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1 # 使用 v1 API，Service 资源的标准版本</span><br><span class="line">kind: Service # 声明该资源类型为 Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-service # Service 的名字，供集群中引用、DNS 名称生成等使用</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort  # 设置 Service 类型为 NodePort，支持通过任意节点的 IP + nodePort 端口访问服务</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx    # 选择所有标签为 app=nginx 的 Pod</span><br><span class="line">  ports:</span><br><span class="line">    - port: 80         # Service 自己监听的端口，供集群内其他 Pod 调用这个服务时使用</span><br><span class="line">      targetPort: 80   # 转发到后端 Pod 的哪个端口（nginx 监听的端口）</span><br><span class="line">      nodePort: 30080  # 外部访问时的端口（可不写，系统会自动分配 30000~32767）</span><br></pre></td></tr></table></figure><p>使用 <code>kubectl apply</code> 命令创建 Service，使用 <code>kubectl get service</code> 查看运行状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@master:~/apps/nginx$ sudo kubectl apply -f nginx-service.yaml</span><br><span class="line">service/nginx-service created</span><br><span class="line">ubuntu@master:~/apps/nginx$ sudo kubectl get service</span><br><span class="line">NAME            TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">kubernetes      ClusterIP   10.43.0.1       &lt;none&gt;        443/TCP        72m</span><br><span class="line">nginx-service   NodePort    10.43.119.114   &lt;none&gt;        80:30080/TCP   2m57s</span><br></pre></td></tr></table></figure><p>到这里，已经可以使用节点 node 外部的 IP + nodePort 访问到 nginx 了。<br>但是，访问 nginx 的时候，IP 是 node 的 IP，没有一个统一的入口。</p><h2 id="配置应用打包流程"><a href="#配置应用打包流程" class="headerlink" title="配置应用打包流程"></a>配置应用打包流程</h2><p>经过上面 nginx 部署的测试，现在k8s集群已经是可用状态了。下面要将本地编写的应用打包为镜像，并上传到镜像仓库，再通过 yaml 配置部署到 k8s 集群中。</p><p>这里使用的本地项目使用 go-kratos 构建的微服务项目。<br>这是一个大仓项目，目录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">BBS</span><br><span class="line">├── .github</span><br><span class="line">├── app</span><br><span class="line">│   ├── backend</span><br><span class="line">│   │   ├── common</span><br><span class="line">│   │   │   ├── api</span><br><span class="line">│   │   │   │   ├── common</span><br><span class="line">│   │   │   │   │   ├── v1</span><br><span class="line">│   │   │   │   │   │   ├── error_reason.pb.go</span><br><span class="line">│   │   │   │   │   │   └── error_reason.proto</span><br><span class="line">│   │   │   │   ├── user</span><br><span class="line">│   │   │   │   │   ├── v1</span><br><span class="line">│   │   │   │   │   │   ├── demo.pb.go</span><br><span class="line">│   │   │   │   │   │   ├── demo.proto</span><br><span class="line">│   │   │   │   │   │   ├── demo_grpc.pb.go</span><br><span class="line">│   │   │   │   │   │   └── demo_http.pb.go</span><br><span class="line">│   │   │   ├── third_party</span><br><span class="line">│   │   ├── user</span><br><span class="line">│   │   │   ├── cmd</span><br><span class="line">│   │   │   │   ├── user</span><br><span class="line">│   │   │   │   │   ├── main.go</span><br><span class="line">│   │   │   │   │   ├── wire.go</span><br><span class="line">│   │   │   │   │   └── wire_gen.go</span><br><span class="line">│   │   │   ├── configs</span><br><span class="line">│   │   │   │   ├── config.yaml</span><br><span class="line">│   │   │   ├── internal</span><br><span class="line">│   │   │   ├── Dockerfile</span><br><span class="line">│   │   │   ├── Makefile</span><br><span class="line">│   │   ├── go.mod</span><br><span class="line">│   │   ├── go.sum</span><br><span class="line">│   │   ├── openapi.yaml</span><br><span class="line">│   ├── frontend</span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure><p>基于这个目录结构，来修改 应用构建文件<code>Makefile</code>、Docker镜像构建文件<code>Dockerfile</code>、github action 文件<code>user-build.yaml</code>。</p><p>首先是 <code>Makefile</code> 文件：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局变量定义</span></span><br><span class="line">GOHOSTOS := <span class="variable">$(<span class="built_in">shell</span> go env GOHOSTOS)</span></span><br><span class="line">GOPATH := <span class="variable">$(<span class="built_in">shell</span> go env GOPATH)</span></span><br><span class="line">VERSION := latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目目录结构定义 - 使用更可靠的路径获取方式</span></span><br><span class="line">ROOT_DIR := <span class="variable">$(<span class="built_in">realpath</span> $(<span class="built_in">dir</span> $(<span class="built_in">lastword</span> <span class="variable">$(MAKEFILE_LIST)</span>)</span>)/..)</span><br><span class="line">COMMON_DIR := <span class="variable">$(ROOT_DIR)</span>/common</span><br><span class="line">USER_DIR := <span class="variable">$(ROOT_DIR)</span>/user</span><br><span class="line">API_DIR := <span class="variable">$(COMMON_DIR)</span>/api</span><br><span class="line">THIRD_PARTY_DIR := <span class="variable">$(COMMON_DIR)</span>/third_party</span><br><span class="line">INTERNAL_DIR := <span class="variable">$(ROOT_DIR)</span>/user/internal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据操作系统设置查找命令</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(GOHOSTOS)</span>, windows)</span><br><span class="line">    Git_Bash := <span class="variable">$(<span class="built_in">subst</span> \,/,$(<span class="built_in">subst</span> cmd\,bin\bash.exe,$(<span class="built_in">dir</span> $(<span class="built_in">shell</span> where git)</span>)))</span><br><span class="line">    FIND_CMD := <span class="variable">$(Git_Bash)</span> -c <span class="string">&quot;find&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    FIND_CMD := find</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Proto 文件查找</span></span><br><span class="line">INTERNAL_PROTO_FILES := <span class="variable">$(<span class="built_in">shell</span> <span class="variable">$(FIND_CMD)</span> <span class="variable">$(INTERNAL_DIR)</span> -name &#x27;*.proto&#x27; 2&gt;/dev/null)</span></span><br><span class="line">API_PROTO_FILES := <span class="variable">$(<span class="built_in">shell</span> <span class="variable">$(FIND_CMD)</span> <span class="variable">$(API_DIR)</span> -name &#x27;*.proto&#x27; 2&gt;/dev/null)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 工具安装</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: init</span></span><br><span class="line"><span class="section">init:</span></span><br><span class="line">@echo <span class="string">&quot;Installing required tools...&quot;</span></span><br><span class="line">go install google.golang.org/protobuf/cmd/protoc-gen-go@latest</span><br><span class="line">go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest</span><br><span class="line">go install github.com/go-kratos/kratos/cmd/kratos/v2@latest</span><br><span class="line">go install github.com/go-kratos/kratos/cmd/protoc-gen-go-http/v2@latest</span><br><span class="line">go install github.com/google/gnostic/cmd/protoc-gen-openapi@latest</span><br><span class="line">go install github.com/google/wire/cmd/wire@latest</span><br><span class="line"></span><br><span class="line"><span class="comment">## 内部 Proto 生成</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: config</span></span><br><span class="line"><span class="section">config:</span></span><br><span class="line">@echo <span class="string">&quot;Generating internal protobuf files...&quot;</span></span><br><span class="line">@test -n <span class="string">&quot;<span class="variable">$(INTERNAL_PROTO_FILES)</span>&quot;</span> || (echo <span class="string">&quot;No proto files found in <span class="variable">$(INTERNAL_DIR)</span>&quot;</span> &amp;&amp; exit 1)</span><br><span class="line">protoc --proto_path=<span class="variable">$(INTERNAL_DIR)</span> \</span><br><span class="line">       --proto_path=<span class="variable">$(THIRD_PARTY_DIR)</span> \</span><br><span class="line">       --go_out=paths=source_relative:<span class="variable">$(INTERNAL_DIR)</span> \</span><br><span class="line">       <span class="variable">$(INTERNAL_PROTO_FILES)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## API Proto 生成</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: api</span></span><br><span class="line"><span class="section">api:</span></span><br><span class="line">@echo <span class="string">&quot;Generating API protobuf files...&quot;</span></span><br><span class="line">@test -n <span class="string">&quot;<span class="variable">$(API_PROTO_FILES)</span>&quot;</span> || (echo <span class="string">&quot;No proto files found in <span class="variable">$(API_DIR)</span>&quot;</span> &amp;&amp; exit 1)</span><br><span class="line">protoc --proto_path=<span class="variable">$(API_DIR)</span> \</span><br><span class="line">       --proto_path=<span class="variable">$(THIRD_PARTY_DIR)</span> \</span><br><span class="line">       --go_out=paths=source_relative:<span class="variable">$(API_DIR)</span> \</span><br><span class="line">       --go-http_out=paths=source_relative:<span class="variable">$(API_DIR)</span> \</span><br><span class="line">       --go-grpc_out=paths=source_relative:<span class="variable">$(API_DIR)</span> \</span><br><span class="line">       --openapi_out=fq_schema_naming=true,default_response=false:<span class="variable">$(API_DIR)</span> \</span><br><span class="line">       <span class="variable">$(API_PROTO_FILES)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 构建应用</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: build</span></span><br><span class="line"><span class="section">build:</span></span><br><span class="line">@echo <span class="string">&quot;Building application...&quot;</span></span><br><span class="line">@mkdir -p <span class="variable">$(ROOT_DIR)</span>/bin/</span><br><span class="line">@cd <span class="variable">$(USER_DIR)</span> &amp;&amp; \</span><br><span class="line">go build -ldflags <span class="string">&quot;-X main.Version=<span class="variable">$(VERSION)</span>&quot;</span> -o <span class="variable">$(ROOT_DIR)</span>/bin/server ./cmd/user/...</span><br><span class="line">@echo <span class="string">&quot;Output binary: <span class="variable">$(ROOT_DIR)</span>/bin/server&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 代码生成</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: generate</span></span><br><span class="line"><span class="section">generate:</span></span><br><span class="line">@echo <span class="string">&quot;Generating code...&quot;</span></span><br><span class="line">@cd <span class="variable">$(USER_DIR)</span> &amp;&amp; \</span><br><span class="line">go generate ./... &amp;&amp; \</span><br><span class="line">go mod tidy</span><br><span class="line"></span><br><span class="line"><span class="comment">## 执行全部任务</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all</span></span><br><span class="line"><span class="section">all: init api config build generate</span></span><br></pre></td></tr></table></figure><p>这里的 VERSION 暂时选择写死了，正常会通过 <code>VERSION := $(shell git describe --tags --always)</code> git 命令来获取最新的标签（tag）或提交哈希（commit hash）。</p><p>然后是 DockerFile 文件：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一阶段：构建Go应用</span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.23</span> as builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /build</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制 go.mod 和 go.sum，提前拉依赖</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> go.mod go.sum ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go mod download</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制 user 和 common 源码</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> user/ ./user/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> common/ ./common/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 user 目录进行构建</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /build/user</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make init &amp;&amp; make generate &amp;&amp; make build</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二阶段：制作小体积运行环境</span></span><br><span class="line"><span class="keyword">FROM</span> debian:stable-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y --no-install-recommends \</span></span><br><span class="line"><span class="language-bash">    ca-certificates netbase &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把可执行文件拷贝进来</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /build/bin/ /app/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /build/user/configs/ /app/configs/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8000</span> <span class="number">9000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/app/server&quot;</span>, <span class="string">&quot;-conf&quot;</span>, <span class="string">&quot;/app/configs/config.yaml&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>最后是 github action 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Docker</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">Push</span> <span class="string">for</span> <span class="string">Go</span> <span class="string">User</span> <span class="string">App</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">workflow_dispatch:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build-and-push:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="comment"># Step 1: Checkout the code</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">Code</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v4</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># Step 2: Set up Go environment + cache</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Go</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-go@v5</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">go-version:</span> <span class="string">&#x27;1.23&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">Go</span> <span class="string">Modules</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/cache@v4</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            ~/.cache/go-build</span></span><br><span class="line"><span class="string">            ~/go/pkg/mod</span></span><br><span class="line"><span class="string"></span>          <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-go-$&#123;&#123;</span> <span class="string">hashFiles(&#x27;**/go.sum&#x27;)</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            $&#123;&#123; runner.os &#125;&#125;-go-</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="comment"># Step 3: Install protoc</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Protobuf</span> <span class="string">Compiler</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          sudo apt-get update</span></span><br><span class="line"><span class="string">          sudo apt-get install -y protobuf-compiler</span></span><br><span class="line"><span class="string">          protoc --version</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="comment"># Step 4: Docker Login</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Docker</span> <span class="string">Login</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">docker/login-action@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">registry:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DOCKER_USERNAME</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">password:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DOCKER_PASSWORD</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># Step 5: Build and Push Docker Image</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">Push</span> <span class="string">Docker</span> <span class="string">Image</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">docker/build-push-action@v5</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">context:</span> <span class="string">app/backend</span></span><br><span class="line">          <span class="attr">file:</span> <span class="string">app/backend/user/Dockerfile</span></span><br><span class="line">          <span class="attr">push:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">tags:</span> <span class="string">|</span></span><br><span class="line">            <span class="string">registry.cn-hangzhou.aliyuncs.com/docker-learn-cooooing/user:latest</span></span><br></pre></td></tr></table></figure><p>其中 secrets.DOCKER_USERNAME 和 secrets.DOCKER_PASSWORD 是 GitHub Secrets，需要在项目设置中配置，用于登录阿里的镜像仓库。<br>目前配置的是手动触发，后续可修改为 push 或者 release 时触发。自动构建最新的镜像推送到阿里的镜像仓库。</p><p>最后回到 kubernetes ，通过 yaml 文件创建 deployment：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">user-service</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">user-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">user-service</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">user-service</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">imagePullSecrets:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">aliyun-registry-secret</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">user</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/docker-learn-cooooing/user:latest</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8000</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9000</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/data/conf</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">limits:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">&quot;512Mi&quot;</span></span><br><span class="line">            <span class="attr">requests:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&quot;100m&quot;</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">&quot;128Mi&quot;</span></span><br><span class="line"><span class="comment">#          readinessProbe: # 就绪探针，确保容器准备好才流量转发</span></span><br><span class="line"><span class="comment">#            httpGet:</span></span><br><span class="line"><span class="comment">#              path: /healthz</span></span><br><span class="line"><span class="comment">#              port: 8000</span></span><br><span class="line"><span class="comment">#            initialDelaySeconds: 5</span></span><br><span class="line"><span class="comment">#            periodSeconds: 10</span></span><br><span class="line"><span class="comment">#          livenessProbe: # 存活探针，崩了自动重启</span></span><br><span class="line"><span class="comment">#            httpGet:</span></span><br><span class="line"><span class="comment">#              path: /healthz</span></span><br><span class="line"><span class="comment">#              port: 8000</span></span><br><span class="line"><span class="comment">#            initialDelaySeconds: 15</span></span><br><span class="line"><span class="comment">#            periodSeconds: 20</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">          <span class="attr">emptyDir:</span> &#123; &#125; <span class="comment"># 这里可以替换成挂载 ConfigMap</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">user-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">user-service</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8000</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">grpc</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">9000</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">9000</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br></pre></td></tr></table></figure><p>它会从阿里镜像仓库拉取镜像，并创建 pod 和 service。<br>其中关于探针的部分被注释掉了，<strong>探针（Probes）是一种用于检测容器健康状况的机制。探针允许Kubernetes定期检查容器是否仍在运行并且按预期工作。根据探针的检查结果，Kubernetes可以决定是否需要重启容器或者进行其他操作。</strong><br>探针需要服务实现一个HTTP端点，Kubernetes 将定期对这个端点发送GET请求。如果端点返回一个成功的状态码（通常是200-399范围内），Kubernetes就会认为容器是健康的。</p><p>这里 service 并没有配置 NodePort，所以目前服务只暴露在 Kubernetes 集群内部，外部访问需要通过 ingress 配置。</p><h2 id="配置-Helm"><a href="#配置-Helm" class="headerlink" title="配置 Helm"></a>配置 Helm</h2><p>Helm 是 Kubernetes 的包管理器。安装过程参考<a class="link"   href="https://helm.sh/zh/docs/" >Helm 文档<i class="fas fa-external-link-alt"></i></a>，这里省略。</p><p>Helm 默认会访问 localhost 的 8080 端口，但是这里使用 k3s，默认的 API Server 地址和端口通常是<code>https://&lt;K3S_SERVER_IP&gt;:6443</code>，所以访问 localhost 的 8080 端口会报错：<br><code>Error: INSTALLATION FAILED: Kubernetes cluster unreachable: Get &quot;http://localhost:8080/version&quot;: dial tcp [::1]:8080: connect: connection refused</code><br>所以需要一些设置：</p><p>Helm 默认会读取 <code>~/.kube/config</code> 文件，但 <strong>K3s 的 <code>kubeconfig</code> 默认存储在 <code>/etc/rancher/k3s/k3s.yaml</code></strong>，需要复制到本地并设置权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/.kube</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> /etc/rancher/k3s/k3s.yaml ~/.kube/config</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> <span class="variable">$USER</span> ~/.kube/config</span><br></pre></td></tr></table></figure><p>使用 <code>helm ls --all-namespaces</code> 测试 Helm 是否能访问 K3s：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@master:~$ helm ls --all-namespaces</span><br><span class="line">NAME            NAMESPACE       REVISION        UPDATED                                 STATUS          CHART                           APP VERSION</span><br><span class="line">traefik         kube-system     1               2025-04-25 08:22:17.95057216 +0000 UTC  deployed        traefik-34.2.1+up34.2.0         v3.3.2     </span><br><span class="line">traefik-crd     kube-system     1               2025-04-25 08:22:02.482297704 +0000 UTC deployed        traefik-crd-34.2.1+up34.2.0     v3.3.2     </span><br></pre></td></tr></table></figure><h2 id="创建-Ingress"><a href="#创建-Ingress" class="headerlink" title="创建 Ingress"></a>创建 Ingress</h2><p>使用 Kubernetes 的 Ingress 来创建一个统一的负载均衡器，从而实现当用户访问不同的域名时，访问后端不同的服务。<br><strong>Ingress 的功能其实很容易理解：所谓 Ingress 就是 Service 的“Service”，这就是它们两者的关系。</strong></p><p>在 Kubernetes（K8s）中，Ingress Controller 默认是 Traefik，它为云原生和动态环境设计，可以监听k8s的资源变化。<br>但这里还是使用 Nginx 作为流量入口管理器，虽然它比较偏静态。</p><p>首先卸载默认的 Traefik：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">helm uninstall traefik -n kube-system</span><br><span class="line">helm uninstall traefik-crd -n kube-system</span><br></pre></td></tr></table></figure><p>然后使用 Helm 安装 Nginx：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx</span><br><span class="line">helm repo update</span><br><span class="line">helm install nginx-ingress ingress-nginx/ingress-nginx -n kube-system</span><br></pre></td></tr></table></figure><p>或者使用 kubectl 安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.12.1/deploy/static/provider/baremetal/deploy.yaml</span><br></pre></td></tr></table></figure><p>使用以下<code>ingress.yaml</code>创建 Ingress 资源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: ingress</span><br><span class="line">  annotations:</span><br><span class="line">    nginx.ingress.kubernetes.io/rewrite-target: /$2 # 路径重写，去掉 /user</span><br><span class="line">    nginx.ingress.kubernetes.io/upstream-hash-by: &quot;$remote_addr&quot; # 负载均衡</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">    - host: &quot;&quot;  # 留空，表示使用 IP 地址</span><br><span class="line">      http:</span><br><span class="line">        paths:</span><br><span class="line">          - path: /user(/|$)(.*)</span><br><span class="line">            pathType: ImplementationSpecific</span><br><span class="line">            backend:</span><br><span class="line">              service:</span><br><span class="line">                name: user-service  # 目标服务名</span><br><span class="line">                port:</span><br><span class="line">                  number: 8000  # user-service 服务的 HTTP 端口</span><br></pre></td></tr></table></figure><p>使用 <code>kubectl apply -f ingress.yaml</code> 创建 Ingress 资源后，就可以通过 <code>http://master/user</code> 访问到后端服务了。</p><p>到这里基本应用的部署就完成了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础环境准备（可选）&quot;&gt;&lt;a href=&quot;#基础环境准备（可选）&quot; class=&quot;headerlink&quot; title=&quot;基础环境准备（可选）&quot;&gt;&lt;/a&gt;基础环境准备（可选）&lt;/h2&gt;&lt;h3 id=&quot;虚拟机配置&quot;&gt;&lt;a href=&quot;#虚拟机配置&quot; class=&quot;he</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://cooooing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Kubernetes" scheme="https://cooooing.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>缓存淘汰算法LRU、LFU</title>
    <link href="https://cooooing.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95LRU%E3%80%81LFU/"/>
    <id>https://cooooing.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95LRU%E3%80%81LFU/</id>
    <published>2025-03-31T03:50:57.000Z</published>
    <updated>2025-03-31T03:50:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存淘汰算法概述"><a href="#缓存淘汰算法概述" class="headerlink" title="缓存淘汰算法概述"></a>缓存淘汰算法概述</h2><p>缓存淘汰算法用于在缓存空间不足时决定哪些数据应该被移除，以腾出空间存储新数据。<br>两种最常用的算法是：</p><ul><li><strong>LRU (Least Recently Used)</strong> - 最近最少使用，根据数据的历史访问记录来进行淘汰数据</li><li><strong>LFU (Least Frequently Used)</strong> - 最不经常使用，根据数据的历史访问频率来淘汰数据</li></ul><h2 id="LRU-最近最少使用-算法"><a href="#LRU-最近最少使用-算法" class="headerlink" title="LRU (最近最少使用) 算法"></a>LRU (最近最少使用) 算法</h2><p>LRU 基于时间局部性原理，认为最近被访问的数据在将来更有可能被再次访问。当缓存满时，LRU 会淘汰最久未被访问的数据。</p><h3 id="Go-实现"><a href="#Go-实现" class="headerlink" title="Go 实现"></a>Go 实现</h3><ul><li>使用哈希表实现 O(1) 的查找</li><li>使用双向链表维护访问顺序</li><li>每次访问数据时，将其移动到链表头部</li><li>淘汰时从链表尾部移除数据</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> utils</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;container/list&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LRUCache 泛型结构体</span></span><br><span class="line"><span class="keyword">type</span> LRUCache[K comparable, V any] <span class="keyword">struct</span> &#123;</span><br><span class="line">capacity <span class="type">int</span></span><br><span class="line">cache    <span class="keyword">map</span>[K]*list.Element</span><br><span class="line">list     *list.List</span><br><span class="line">mu       sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// entry 用于存储键值对</span></span><br><span class="line"><span class="keyword">type</span> entry[K comparable, V any] <span class="keyword">struct</span> &#123;</span><br><span class="line">key   K</span><br><span class="line">value V</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewLRUCache 创建一个新的泛型LRUCache</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLRUCache</span>[<span class="title">K</span> <span class="title">comparable</span>, <span class="title">V</span> <span class="title">any</span>]<span class="params">(capacity <span class="type">int</span>)</span></span> *LRUCache[K, V] &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;LRUCache[K, V]&#123;</span><br><span class="line">capacity: capacity,</span><br><span class="line">cache:    <span class="built_in">make</span>(<span class="keyword">map</span>[K]*list.Element),</span><br><span class="line">list:     list.New(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get 获取键的值，如果不存在返回零值和false</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LRUCache[K, V])</span></span> Get(key K) (V, <span class="type">bool</span>) &#123;</span><br><span class="line">l.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> l.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> elem, ok := l.cache[key]; ok &#123;</span><br><span class="line">l.list.MoveToFront(elem)</span><br><span class="line"><span class="keyword">return</span> elem.Value.(*entry[K, V]).value, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> zero V</span><br><span class="line"><span class="keyword">return</span> zero, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Put 插入或更新键值对</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LRUCache[K, V])</span></span> Put(key K, value V) <span class="type">bool</span> &#123;</span><br><span class="line">l.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> l.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> l.capacity &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> elem, ok := l.cache[key]; ok &#123;</span><br><span class="line">elem.Value.(*entry[K, V]).value = value</span><br><span class="line">l.list.MoveToFront(elem)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> l.list.Len() &gt;= l.capacity &#123;</span><br><span class="line"><span class="comment">// 移除最久未使用的元素</span></span><br><span class="line">back := l.list.Back()</span><br><span class="line"><span class="keyword">if</span> back != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(l.cache, back.Value.(*entry[K, V]).key)</span><br><span class="line">l.list.Remove(back)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newEntry := &amp;entry[K, V]&#123;key, value&#125;</span><br><span class="line">elem := l.list.PushFront(newEntry)</span><br><span class="line">l.cache[key] = elem</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Len 返回缓存中元素的数量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LRUCache[K, V])</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> l.list.Len()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> utils</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLRUCache_EmptyCache</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">cache := NewLRUCache[<span class="type">string</span>, <span class="type">int</span>](<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试空缓存</span></span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;nonexistent&quot;</span>); ok || val != <span class="number">0</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get from empty cache should return zero value, got %v, %v&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> l := cache.Len(); l != <span class="number">0</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Len of empty cache should be 0, got %d&quot;</span>, l)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLRUCache_SingleItem</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">cache := NewLRUCache[<span class="type">string</span>, <span class="type">int</span>](<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试单个元素</span></span><br><span class="line">cache.Put(<span class="string">&quot;one&quot;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;one&quot;</span>); !ok || val != <span class="number">1</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get(&#x27;one&#x27;) = %d, %v, want 1, true&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试替换</span></span><br><span class="line">cache.Put(<span class="string">&quot;two&quot;</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;one&quot;</span>); ok &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get(&#x27;one&#x27;) should be evicted, got %d, %v&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;two&quot;</span>); !ok || val != <span class="number">2</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get(&#x27;two&#x27;) = %d, %v, want 2, true&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLRUCache_EvictionPolicy</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">cache := NewLRUCache[<span class="type">string</span>, <span class="type">int</span>](<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始填充</span></span><br><span class="line">cache.Put(<span class="string">&quot;one&quot;</span>, <span class="number">1</span>)</span><br><span class="line">cache.Put(<span class="string">&quot;two&quot;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问one使其成为最近使用的</span></span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;one&quot;</span>); !ok || val != <span class="number">1</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get(&#x27;one&#x27;) = %d, %v, want 1, true&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加新元素，two应该被淘汰</span></span><br><span class="line">cache.Put(<span class="string">&quot;three&quot;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;two&quot;</span>); ok &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get(&#x27;two&#x27;) should be evicted, got %d, %v&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;one&quot;</span>); !ok || val != <span class="number">1</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get(&#x27;one&#x27;) = %d, %v, want 1, true&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;three&quot;</span>); !ok || val != <span class="number">3</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get(&#x27;three&#x27;) = %d, %v, want 3, true&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLRUCache_UpdateExisting</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">cache := NewLRUCache[<span class="type">string</span>, <span class="type">int</span>](<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">cache.Put(<span class="string">&quot;one&quot;</span>, <span class="number">1</span>)</span><br><span class="line">cache.Put(<span class="string">&quot;one&quot;</span>, <span class="number">11</span>) <span class="comment">// 更新</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;one&quot;</span>); !ok || val != <span class="number">11</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get(&#x27;one&#x27;) = %d, %v, want 11, true&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> l := cache.Len(); l != <span class="number">1</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Len should be 1 after update, got %d&quot;</span>, l)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLRUCache_ZeroCapacity</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">cache := NewLRUCache[<span class="type">string</span>, <span class="type">int</span>](<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">cache.Put(<span class="string">&quot;one&quot;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;one&quot;</span>); ok &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get from zero-capacity cache should return nothing, got %d, %v&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLRUCache_CustomTypes</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> customKey <span class="keyword">struct</span> &#123;</span><br><span class="line">id   <span class="type">int</span></span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cache := NewLRUCache[customKey, <span class="type">string</span>](<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">key1 := customKey&#123;<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>&#125;</span><br><span class="line">key2 := customKey&#123;<span class="number">2</span>, <span class="string">&quot;banana&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">cache.Put(key1, <span class="string">&quot;red&quot;</span>)</span><br><span class="line">cache.Put(key2, <span class="string">&quot;yellow&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(key1); !ok || val != <span class="string">&quot;red&quot;</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get(key1) = %s, %v, want &#x27;red&#x27;, true&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试淘汰</span></span><br><span class="line">cache.Put(customKey&#123;<span class="number">3</span>, <span class="string">&quot;cherry&quot;</span>&#125;, <span class="string">&quot;pink&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(key2); ok &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get(key2) should be evicted, got %s, %v&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLRUCache_ConcurrentAccess</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">cache := NewLRUCache[<span class="type">string</span>, <span class="type">int</span>](<span class="number">100</span>)</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发写入</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">cache.Put(<span class="string">&quot;key&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发读取</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">cache.Get(<span class="string">&quot;key&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&lt;-done</span><br><span class="line">&lt;-done</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终检查</span></span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;key&quot;</span>); !ok &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Key should exist after concurrent access&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> val &lt; <span class="number">0</span> || val &gt;= <span class="number">10000</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Unexpected value after concurrent access: %d&quot;</span>, val)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="LFU-最不经常使用-算法"><a href="#LFU-最不经常使用-算法" class="headerlink" title="LFU (最不经常使用) 算法"></a>LFU (最不经常使用) 算法</h2><p>LFU 基于访问频率，认为访问次数最少的数据在未来被访问的可能性也最小。当缓存满时，LFU 会淘汰访问频率最低的数据。如果有多个数据具有相同的最低频率，则淘汰其中最久未被访问的数据。</p><h3 id="Go-实现-1"><a href="#Go-实现-1" class="headerlink" title="Go 实现"></a>Go 实现</h3><ul><li>使用两个哈希表：一个存储键值对，一个存储频率到键列表的映射</li><li>使用双向链表维护相同频率下的访问顺序</li><li>需要维护一个最小频率变量</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> utils</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;container/list&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LFUCache 泛型结构体</span></span><br><span class="line"><span class="keyword">type</span> LFUCache[K comparable, V any] <span class="keyword">struct</span> &#123;</span><br><span class="line">capacity <span class="type">int</span></span><br><span class="line">minFreq  <span class="type">int</span></span><br><span class="line">items    <span class="keyword">map</span>[K]*list.Element     <span class="comment">// 存储键到元素的映射</span></span><br><span class="line">freqs    <span class="keyword">map</span>[<span class="type">int</span>]*list.List      <span class="comment">// 存储频率到双向链表的映射</span></span><br><span class="line">entries  <span class="keyword">map</span>[K]*cacheEntry[K, V] <span class="comment">// 存储键到entry的映射(辅助快速访问)</span></span><br><span class="line">mu       sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cacheEntry 存储缓存值和频率信息</span></span><br><span class="line"><span class="keyword">type</span> cacheEntry[K comparable, V any] <span class="keyword">struct</span> &#123;</span><br><span class="line">key    K</span><br><span class="line">value  V</span><br><span class="line">freq   <span class="type">int</span></span><br><span class="line">parent *list.Element</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewLFUCache 创建一个新的泛型LFUCache</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLFUCache</span>[<span class="title">K</span> <span class="title">comparable</span>, <span class="title">V</span> <span class="title">any</span>]<span class="params">(capacity <span class="type">int</span>)</span></span> *LFUCache[K, V] &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;LFUCache[K, V]&#123;</span><br><span class="line">capacity: capacity,</span><br><span class="line">items:    <span class="built_in">make</span>(<span class="keyword">map</span>[K]*list.Element),</span><br><span class="line">freqs:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*list.List),</span><br><span class="line">entries:  <span class="built_in">make</span>(<span class="keyword">map</span>[K]*cacheEntry[K, V]),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get 获取键的值，如果不存在返回零值和false</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LFUCache[K, V])</span></span> Get(key K) (V, <span class="type">bool</span>) &#123;</span><br><span class="line">l.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> l.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> elem, ok := l.items[key]; ok &#123;</span><br><span class="line">entry := elem.Value.(*cacheEntry[K, V])</span><br><span class="line">l.incrementFreq(elem, entry)</span><br><span class="line"><span class="keyword">return</span> entry.value, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> zero V</span><br><span class="line"><span class="keyword">return</span> zero, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Put 插入或更新键值对</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LFUCache[K, V])</span></span> Put(key K, value V) <span class="type">bool</span> &#123;</span><br><span class="line">l.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> l.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> l.capacity &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果键已存在，更新值并增加频率</span></span><br><span class="line"><span class="keyword">if</span> elem, ok := l.items[key]; ok &#123;</span><br><span class="line">entry := elem.Value.(*cacheEntry[K, V])</span><br><span class="line">entry.value = value</span><br><span class="line">l.incrementFreq(elem, entry)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果缓存已满，移除最不经常使用且最久未使用的项</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(l.items) &gt;= l.capacity &#123;</span><br><span class="line">l.removeMinFreqItem()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新条目</span></span><br><span class="line">entry := &amp;cacheEntry[K, V]&#123;</span><br><span class="line">key:   key,</span><br><span class="line">value: value,</span><br><span class="line">freq:  <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到频率为1的列表中</span></span><br><span class="line"><span class="keyword">if</span> l.freqs[<span class="number">1</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">l.freqs[<span class="number">1</span>] = list.New()</span><br><span class="line">&#125;</span><br><span class="line">elem := l.freqs[<span class="number">1</span>].PushFront(entry)</span><br><span class="line">entry.parent = elem</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新映射</span></span><br><span class="line">l.items[key] = elem</span><br><span class="line">l.entries[key] = entry</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新最小频率</span></span><br><span class="line">l.minFreq = <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// incrementFreq 增加条目的频率</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LFUCache[K, V])</span></span> incrementFreq(elem *list.Element, entry *cacheEntry[K, V]) &#123;</span><br><span class="line"><span class="comment">// 从当前频率列表中移除</span></span><br><span class="line">l.freqs[entry.freq].Remove(elem)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新频率</span></span><br><span class="line">entry.freq++</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到新频率列表中</span></span><br><span class="line"><span class="keyword">if</span> l.freqs[entry.freq] == <span class="literal">nil</span> &#123;</span><br><span class="line">l.freqs[entry.freq] = list.New()</span><br><span class="line">&#125;</span><br><span class="line">newElem := l.freqs[entry.freq].PushFront(entry)</span><br><span class="line">entry.parent = newElem</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新items映射</span></span><br><span class="line">l.items[entry.key] = newElem</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果旧频率是最小频率且该频率列表现在为空，更新最小频率</span></span><br><span class="line"><span class="keyword">if</span> entry.freq<span class="number">-1</span> == l.minFreq &amp;&amp; l.freqs[entry.freq<span class="number">-1</span>].Len() == <span class="number">0</span> &#123;</span><br><span class="line">l.minFreq = entry.freq</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// removeMinFreqItem 移除最小频率的项</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LFUCache[K, V])</span></span> removeMinFreqItem() &#123;</span><br><span class="line">minList := l.freqs[l.minFreq]</span><br><span class="line"><span class="keyword">if</span> minList == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除列表中的最后一个元素(最久未使用)</span></span><br><span class="line">back := minList.Back()</span><br><span class="line"><span class="keyword">if</span> back == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">entry := back.Value.(*cacheEntry[K, V])</span><br><span class="line">minList.Remove(back)</span><br><span class="line"><span class="built_in">delete</span>(l.items, entry.key)</span><br><span class="line"><span class="built_in">delete</span>(l.entries, entry.key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Len 返回缓存中元素的数量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LFUCache[K, V])</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(l.items)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> utils</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLFUCache_EmptyCache</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">cache := NewLFUCache[<span class="type">string</span>, <span class="type">int</span>](<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试空缓存</span></span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;nonexistent&quot;</span>); ok || val != <span class="number">0</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get from empty cache should return zero value, got %v, %v&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> l := cache.Len(); l != <span class="number">0</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Len of empty cache should be 0, got %d&quot;</span>, l)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLFUCache_SingleItem</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">cache := NewLFUCache[<span class="type">string</span>, <span class="type">int</span>](<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试单个元素</span></span><br><span class="line">cache.Put(<span class="string">&quot;one&quot;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;one&quot;</span>); !ok || val != <span class="number">1</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get(&#x27;one&#x27;) = %d, %v, want 1, true&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试替换</span></span><br><span class="line">cache.Put(<span class="string">&quot;two&quot;</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;one&quot;</span>); ok &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get(&#x27;one&#x27;) should be evicted, got %d, %v&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;two&quot;</span>); !ok || val != <span class="number">2</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get(&#x27;two&#x27;) = %d, %v, want 2, true&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLFUCache_EvictionPolicy</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">cache := NewLFUCache[<span class="type">string</span>, <span class="type">int</span>](<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始填充</span></span><br><span class="line">cache.Put(<span class="string">&quot;one&quot;</span>, <span class="number">1</span>)</span><br><span class="line">cache.Put(<span class="string">&quot;two&quot;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问one增加其频率</span></span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;one&quot;</span>); !ok || val != <span class="number">1</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get(&#x27;one&#x27;) = %d, %v, want 1, true&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加新元素，two应该被淘汰(频率较低)</span></span><br><span class="line">cache.Put(<span class="string">&quot;three&quot;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;two&quot;</span>); ok &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get(&#x27;two&#x27;) should be evicted, got %d, %v&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;one&quot;</span>); !ok || val != <span class="number">1</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get(&#x27;one&#x27;) = %d, %v, want 1, true&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;three&quot;</span>); !ok || val != <span class="number">3</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get(&#x27;three&#x27;) = %d, %v, want 3, true&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再访问three使其频率与one相同</span></span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;three&quot;</span>); !ok || val != <span class="number">3</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get(&#x27;three&#x27;) = %d, %v, want 3, true&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加新元素，one应该被淘汰(相同频率但更久未使用)</span></span><br><span class="line">cache.Put(<span class="string">&quot;four&quot;</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;one&quot;</span>); ok &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get(&#x27;one&#x27;) should be evicted, got %d, %v&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;three&quot;</span>); !ok || val != <span class="number">3</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get(&#x27;three&#x27;) = %d, %v, want 3, true&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;four&quot;</span>); !ok || val != <span class="number">4</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get(&#x27;four&#x27;) = %d, %v, want 4, true&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLFUCache_UpdateExisting</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">cache := NewLFUCache[<span class="type">string</span>, <span class="type">int</span>](<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">cache.Put(<span class="string">&quot;one&quot;</span>, <span class="number">1</span>)</span><br><span class="line">cache.Put(<span class="string">&quot;one&quot;</span>, <span class="number">11</span>) <span class="comment">// 更新</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;one&quot;</span>); !ok || val != <span class="number">11</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get(&#x27;one&#x27;) = %d, %v, want 11, true&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> l := cache.Len(); l != <span class="number">1</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Len should be 1 after update, got %d&quot;</span>, l)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLFUCache_ZeroCapacity</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">cache := NewLFUCache[<span class="type">string</span>, <span class="type">int</span>](<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">cache.Put(<span class="string">&quot;one&quot;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;one&quot;</span>); ok &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get from zero-capacity cache should return nothing, got %d, %v&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLFUCache_MinFrequencyUpdate</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">cache := NewLFUCache[<span class="type">string</span>, <span class="type">int</span>](<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始填充</span></span><br><span class="line">cache.Put(<span class="string">&quot;one&quot;</span>, <span class="number">1</span>)</span><br><span class="line">cache.Put(<span class="string">&quot;two&quot;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问one增加其频率</span></span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;one&quot;</span>); !ok || val != <span class="number">1</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get(&#x27;one&#x27;) = %d, %v, want 1, true&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加新元素，two应该被淘汰(频率较低)</span></span><br><span class="line">cache.Put(<span class="string">&quot;three&quot;</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在minFreq应该是1(three的频率)</span></span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;three&quot;</span>); !ok || val != <span class="number">3</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get(&#x27;three&#x27;) = %d, %v, want 3, true&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次访问three使其频率增加到2</span></span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;three&quot;</span>); !ok || val != <span class="number">3</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get(&#x27;three&#x27;) = %d, %v, want 3, true&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加新元素，应该淘汰one(因为three频率更高)</span></span><br><span class="line">cache.Put(<span class="string">&quot;four&quot;</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;one&quot;</span>); ok &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get(&#x27;one&#x27;) should be evicted, got %d, %v&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLFUCache_CustomTypes</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> customKey <span class="keyword">struct</span> &#123;</span><br><span class="line">id   <span class="type">int</span></span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cache := NewLFUCache[customKey, <span class="type">string</span>](<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">key1 := customKey&#123;<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>&#125;</span><br><span class="line">key2 := customKey&#123;<span class="number">2</span>, <span class="string">&quot;banana&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">cache.Put(key1, <span class="string">&quot;red&quot;</span>)</span><br><span class="line">cache.Put(key2, <span class="string">&quot;yellow&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问key1增加其频率</span></span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(key1); !ok || val != <span class="string">&quot;red&quot;</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get(key1) = %s, %v, want &#x27;red&#x27;, true&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加新元素，key2应该被淘汰(频率较低)</span></span><br><span class="line">cache.Put(customKey&#123;<span class="number">3</span>, <span class="string">&quot;cherry&quot;</span>&#125;, <span class="string">&quot;pink&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(key2); ok &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Get(key2) should be evicted, got %s, %v&quot;</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLFUCache_ConcurrentAccess</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">cache := NewLFUCache[<span class="type">string</span>, <span class="type">int</span>](<span class="number">100</span>)</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发写入</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">cache.Put(<span class="string">&quot;key&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发读取</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">cache.Get(<span class="string">&quot;key&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&lt;-done</span><br><span class="line">&lt;-done</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终检查</span></span><br><span class="line"><span class="keyword">if</span> val, ok := cache.Get(<span class="string">&quot;key&quot;</span>); !ok &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Key should exist after concurrent access&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> val &lt; <span class="number">0</span> || val &gt;= <span class="number">10000</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Unexpected value after concurrent access: %d&quot;</span>, val)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="LRU-和-LFU-的比较"><a href="#LRU-和-LFU-的比较" class="headerlink" title="LRU 和 LFU 的比较"></a>LRU 和 LFU 的比较</h2><table><thead><tr><th>特性</th><th>LRU</th><th>LFU</th></tr></thead><tbody><tr><td>淘汰策略</td><td>淘汰最久未使用的</td><td>淘汰使用频率最低的</td></tr><tr><td>实现复杂度</td><td>相对简单</td><td>相对复杂</td></tr><tr><td>适用场景</td><td>访问模式随时间变化不大</td><td>访问频率差异明显的场景</td></tr><tr><td>对突发流量</td><td>可能淘汰热点数据</td><td>对新数据不友好</td></tr><tr><td>内存消耗</td><td>较低</td><td>较高</td></tr></tbody></table><ul><li><strong>LRU</strong> 实现简单，适合大多数通用场景，对突发流量友好。</li><li><strong>LFU</strong> 适合访问模式相对稳定的场景，能更好地保留高频访问数据。</li></ul><p>另外，还有 LRU 和 LFU 的变体和混合算法以及FIFO（First in First out），先进先出，最先进入的数据，最先被淘汰等算法，以不同的淘汰策略适应不同的应用场景。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;缓存淘汰算法概述&quot;&gt;&lt;a href=&quot;#缓存淘汰算法概述&quot; class=&quot;headerlink&quot; title=&quot;缓存淘汰算法概述&quot;&gt;&lt;/a&gt;缓存淘汰算法概述&lt;/h2&gt;&lt;p&gt;缓存淘汰算法用于在缓存空间不足时决定哪些数据应该被移除，以腾出空间存储新数据。&lt;br&gt;两种最</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://cooooing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="go" scheme="https://cooooing.github.io/tags/go/"/>
    
    <category term="算法" scheme="https://cooooing.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="缓存" scheme="https://cooooing.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
    <category term="LRU" scheme="https://cooooing.github.io/tags/LRU/"/>
    
    <category term="LFU" scheme="https://cooooing.github.io/tags/LFU/"/>
    
  </entry>
  
  <entry>
    <title>oracle通过经纬度过滤范围内数据</title>
    <link href="https://cooooing.github.io/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/oracle%E9%80%9A%E8%BF%87%E7%BB%8F%E7%BA%AC%E5%BA%A6%E8%BF%87%E6%BB%A4%E8%8C%83%E5%9B%B4%E5%86%85%E6%95%B0%E6%8D%AE/"/>
    <id>https://cooooing.github.io/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/oracle%E9%80%9A%E8%BF%87%E7%BB%8F%E7%BA%AC%E5%BA%A6%E8%BF%87%E6%BB%A4%E8%8C%83%E5%9B%B4%E5%86%85%E6%95%B0%E6%8D%AE/</id>
    <published>2025-03-26T02:54:15.000Z</published>
    <updated>2025-03-26T02:54:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><p>今天的需求是在地图上撒了很多点，右击这个点时，可以选择一个半径，呈现在这个半径范围内的点。<br>和之前一个在地图上框选多边形区域的需求一样，需要通过经纬度来计算过滤数据。</p><p>这里是通过 Oracle 的空间运算符实现的。<br>主要使用下面两个：</p><ol><li><a class="link"   href="https://docs.oracle.com/en/database/oracle/oracle-database/23/spatl/sdo_within_distance.html" >SDO_WITHIN_DISTANCE<i class="fas fa-external-link-alt"></i></a><br>Identifies the set of spatial objects that are within some specified distance of a given object, such as an area of interest or point of interest.<br>标识位于给定对象（如感兴趣区域或感兴趣点）的某个指定距离内的空间对象集。</li><li><a class="link"   href="https://docs.oracle.com/en/database/oracle/oracle-database/23/spatl/sdo_inside.html" >SDO_INSIDE<i class="fas fa-external-link-alt"></i></a><br>Checks if any geometries in a table have the INSIDE topological relationship with a specified geometry. Equivalent to specifying the SDO_RELATE operator with ‘mask&#x3D;INSIDE’.<br>检查表中的任何几何是否与指定几何具有 INSIDE 拓扑关系。等效于使用 ‘mask&#x3D;INSIDE’ 指定 SDO_RELATE 运算符。</li></ol><h2 id="需求实现"><a href="#需求实现" class="headerlink" title="需求实现"></a>需求实现</h2><p>首先需要确保表中有经纬度的字段和数据，并且不为空。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delete</span><br><span class="line">from T_GIS</span><br><span class="line">where LONGITUDE is null</span><br><span class="line">   or LATITUDE is null;</span><br></pre></td></tr></table></figure><p>然后需要新建一个字段，为存储空间类型。存储经纬度转换后的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table T_GIS</span><br><span class="line">    add POINT_GEOMETRY SDO_GEOMETRY</span><br></pre></td></tr></table></figure><p>将转换后的经纬度存储到这个字段中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">UPDATE T_GIS a</span><br><span class="line">SET a.POINT_GEOMETRY = SDO_GEOMETRY(</span><br><span class="line">        2001, -- 点类型</span><br><span class="line">        8307, -- WGS84 坐标系</span><br><span class="line">        SDO_POINT_TYPE(a.LONGITUDE, a.LATITUDE, NULL), -- 点坐标</span><br><span class="line">        NULL, -- 无元素信息</span><br><span class="line">        NULL -- 无坐标数组</span><br><span class="line">                       )</span><br><span class="line">where LONGITUDE is not null</span><br><span class="line">  and LATITUDE is not null;</span><br></pre></td></tr></table></figure><p>然后需要为这个字段创建空间索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX T_GIS_SPATIAL_IDX;</span><br><span class="line"></span><br><span class="line">CREATE INDEX T_GIS_SPATIAL_IDX</span><br><span class="line">    ON T_GIS (POINT_GEOMETRY)</span><br><span class="line">    INDEXTYPE IS MDSYS.SPATIAL_INDEX;</span><br></pre></td></tr></table></figure><p>然后就可以使用 SDO_WITHIN_DISTANCE 来查询了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from T_GIS a</span><br><span class="line">where a.POINT_GEOMETRY is not null</span><br><span class="line">  and a.LONGITUDE is not null</span><br><span class="line">  and a.LATITUDE is not null</span><br><span class="line">  and SDO_WITHIN_DISTANCE(</span><br><span class="line">              a.POINT_GEOMETRY,</span><br><span class="line">              SDO_GEOMETRY(</span><br><span class="line">                      2001, -- 点类型</span><br><span class="line">                      8307, -- WGS84 坐标系</span><br><span class="line">                      SDO_POINT_TYPE(104.48060937499996, 36.30556423523153, NULL), -- 点坐标 (经度, 纬度, 高度)</span><br><span class="line">                      NULL, -- 无元素信息</span><br><span class="line">                      NULL -- 无坐标数组</span><br><span class="line">              ),</span><br><span class="line">              &#x27;DISTANCE=1000&#x27;</span><br><span class="line">      ) = &#x27;TRUE&#x27;;</span><br></pre></td></tr></table></figure><p>如果报错，可以使用下面的语句查看异常数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM T_GIS</span><br><span class="line">WHERE SDO_GEOM.VALIDATE_GEOMETRY_WITH_CONTEXT(POINT_GEOMETRY, 0.005) != &#x27;TRUE&#x27;;</span><br></pre></td></tr></table></figure><h2 id="WGS84-坐标系"><a href="#WGS84-坐标系" class="headerlink" title="WGS84 坐标系"></a>WGS84 坐标系</h2><p>WGS84（<strong>World Geodetic System 1984</strong>）是目前全球最广泛使用的 <strong>大地坐标系（Geodetic Coordinate System）</strong>，由美国国防部（DoD）制定，用于 <strong>GPS 定位、地图绘制、GIS 系统</strong> 等场景。</p><ul><li>WGS84 是一个 <strong>地球参考坐标系</strong>，用于描述地球表面点的位置（经度、纬度、高程）。</li><li>它基于 <strong>椭球体模型</strong>（参考椭球），并定义了地球的形状、大小和重力场。</li></ul><h3 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h3><table><thead><tr><th>参数</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td><strong>椭球体长半轴（a）</strong></td><td>6,378,137 米</td><td>赤道半径</td></tr><tr><td><strong>椭球体短半轴（b）</strong></td><td>6,356,752.3142 米</td><td>极半径</td></tr><tr><td><strong>扁率（f）</strong></td><td>1&#x2F;298.257223563</td><td><code>f = (a - b) / a</code></td></tr><tr><td><strong>第一偏心率平方（e²）</strong></td><td>0.00669437999014</td><td>用于坐标转换</td></tr><tr><td><strong>地球自转角速度（ω）</strong></td><td>7.292115 × 10⁻⁵ rad&#x2F;s</td><td>影响重力场计算</td></tr><tr><td><strong>地心引力常数（GM）</strong></td><td>3.986004418 × 10¹⁴ m³&#x2F;s²</td><td>用于卫星轨道计算</td></tr></tbody></table><h3 id="坐标表示"><a href="#坐标表示" class="headerlink" title="坐标表示"></a>坐标表示</h3><p>WGS84 使用 <strong>经度（Longitude）、纬度（Latitude）、高程（Height）</strong> 表示位置：</p><ul><li><strong>经度（λ）</strong>：东经（0°<del>180°E）或西经（0°</del>180°W）。</li><li><strong>纬度（φ）</strong>：北纬（0°<del>90°N）或南纬（0°</del>90°S）。</li><li><strong>高程（h）</strong>：相对于 WGS84 椭球面的高度（单位：米）。</li></ul><h3 id="WGS84-的常见用途"><a href="#WGS84-的常见用途" class="headerlink" title="WGS84 的常见用途"></a>WGS84 的常见用途</h3><ol><li>GPS 定位<ul><li>全球定位系统（GPS）默认使用 WGS84 坐标系。</li><li>手机、车载导航、无人机等设备的定位数据通常基于 WGS84。</li></ul></li><li>地图服务<ul><li><strong>Google Maps、百度地图、高德地图</strong> 等在线地图的底层数据采用 WGS84。</li><li>但部分地图（如中国 GCJ-02）会对 WGS84 进行加密偏移。</li></ul></li><li>GIS 和空间数据库<ul><li><strong>Oracle Spatial、PostGIS、ArcGIS</strong> 等支持 WGS84 坐标系。</li><li>在 Oracle 中，WGS84 的 SRID（空间参考 ID）通常为：<ul><li><strong>4326</strong>（标准 WGS84，经纬度顺序：纬度, 经度）</li><li><strong>8307</strong>（WGS84，经纬度顺序：经度, 纬度）</li></ul></li></ul></li></ol><h3 id="WGS84-与其他坐标系的区别"><a href="#WGS84-与其他坐标系的区别" class="headerlink" title="WGS84 与其他坐标系的区别"></a>WGS84 与其他坐标系的区别</h3><p>WGS84 是全通通用的、无偏移的 GPS 原始数据，美国标准。GPS、谷歌地图等使用。<br>GCJ-02 对 WGS84 进行非线性偏移。在中国国内使用，高德地图、腾讯地图等使用。<br>CGCS2000 是中国标准，中国官方测绘。</p><blockquote><p>注：CGCS2000 和 WGS84 在 <strong>厘米级精度</strong> 下可以视为一致，但在高精度测量（如卫星定位）时需转换。</p></blockquote><h2 id="Oracle-Spatial-函数（部分）"><a href="#Oracle-Spatial-函数（部分）" class="headerlink" title="Oracle Spatial 函数（部分）"></a>Oracle Spatial 函数（部分）</h2><h3 id="SDO-GEOMETRY"><a href="#SDO-GEOMETRY" class="headerlink" title="SDO_GEOMETRY"></a>SDO_GEOMETRY</h3><p>SDO_GEOMETRY 是 Oracle Spatial 的核心数据类型，用于存储空间数据。</p><p>基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SDO_GEOMETRY(</span><br><span class="line">    geometry_type  NUMBER,        -- 几何类型代码</span><br><span class="line">    srid          NUMBER,        -- 空间参考系ID</span><br><span class="line">    point         SDO_POINT_TYPE,-- 点坐标(仅用于点类型)</span><br><span class="line">    elem_info     SDO_ELEM_INFO_ARRAY, -- 元素定义数组</span><br><span class="line">    ordinates     SDO_ORDINATE_ARRAY   -- 坐标值数组</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>几何类型代码</p><table><thead><tr><th>代码</th><th>类型说明</th></tr></thead><tbody><tr><td>2001</td><td>点</td></tr><tr><td>2002</td><td>线</td></tr><tr><td>2003</td><td>多边形</td></tr><tr><td>2005</td><td>多点集合</td></tr><tr><td>2006</td><td>多线集合</td></tr><tr><td>2007</td><td>多多边形集合</td></tr></tbody></table><p>创建点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 创建WGS84坐标系的点(经度120.5，纬度30.2)</span><br><span class="line">SELECT SDO_GEOMETRY(</span><br><span class="line">    2001,         -- 点类型</span><br><span class="line">    8307,         -- WGS84坐标系SRID</span><br><span class="line">    SDO_POINT_TYPE(120.5, 30.2, NULL), -- 经度,纬度,高程</span><br><span class="line">    NULL,</span><br><span class="line">    NULL</span><br><span class="line">) FROM dual;</span><br></pre></td></tr></table></figure><p>创建线</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 创建由三个点组成的线</span><br><span class="line">SELECT SDO_GEOMETRY(</span><br><span class="line">    2002,  -- 线类型</span><br><span class="line">    8307,</span><br><span class="line">    NULL,</span><br><span class="line">    SDO_ELEM_INFO_ARRAY(1, 2, 1), -- 简单线</span><br><span class="line">    SDO_ORDINATE_ARRAY(120,30, 121,31, 122,30) -- 三个点坐标</span><br><span class="line">) FROM dual;</span><br></pre></td></tr></table></figure><p>创建多边形</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 创建四边形(必须闭合)</span><br><span class="line">SELECT SDO_GEOMETRY(</span><br><span class="line">    2003,  -- 多边形类型</span><br><span class="line">    8307,</span><br><span class="line">    NULL,</span><br><span class="line">    SDO_ELEM_INFO_ARRAY(1, 1003, 1), -- 外多边形</span><br><span class="line">    SDO_ORDINATE_ARRAY(120,30, 121,30, 121,31, 120,31, 120,30) -- 闭合坐标</span><br><span class="line">) FROM dual;</span><br></pre></td></tr></table></figure><h3 id="SDO-WITHIN-DISTANCE-函数详解"><a href="#SDO-WITHIN-DISTANCE-函数详解" class="headerlink" title="SDO_WITHIN_DISTANCE 函数详解"></a>SDO_WITHIN_DISTANCE 函数详解</h3><p>用于查询在指定距离范围内的空间对象。</p><p>基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SDO_WITHIN_DISTANCE(</span><br><span class="line">    geometry1  SDO_GEOMETRY,  -- 要检查的几何对象</span><br><span class="line">    geometry2  SDO_GEOMETRY,  -- 参考几何对象</span><br><span class="line">    params     VARCHAR2       -- 距离参数</span><br><span class="line">) RETURN VARCHAR2;</span><br></pre></td></tr></table></figure><p>参数说明</p><ul><li><code>params</code> 格式：<code>&#39;distance=&lt;数值&gt; unit=&lt;单位&gt;&#39;</code><ul><li><code>distance</code>：距离值</li><li><code>unit</code>：单位(默认为坐标系单位，WGS84为米)</li></ul></li></ul><p>查询某点1公里范围内的所有商店</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.store_id, s.store_name</span><br><span class="line">FROM stores s</span><br><span class="line">WHERE SDO_WITHIN_DISTANCE(</span><br><span class="line">    s.location,  -- 商店位置字段</span><br><span class="line">    SDO_GEOMETRY(2001, 8307, SDO_POINT_TYPE(120.5, 30.2, NULL), NULL, NULL), -- 中心点</span><br><span class="line">    &#x27;distance=1000&#x27;  -- 1公里范围内</span><br><span class="line">) = &#x27;TRUE&#x27;;</span><br></pre></td></tr></table></figure><p>查询某区域500米内的所有道路</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT r.road_id, r.road_name</span><br><span class="line">FROM roads r, regions reg</span><br><span class="line">WHERE reg.region_id = 101</span><br><span class="line">AND SDO_WITHIN_DISTANCE(</span><br><span class="line">    r.geom,      -- 道路几何</span><br><span class="line">    reg.geom,    -- 区域几何</span><br><span class="line">    &#x27;distance=500&#x27;  -- 500米内</span><br><span class="line">) = &#x27;TRUE&#x27;;</span><br></pre></td></tr></table></figure><h3 id="SDO-INSIDE"><a href="#SDO-INSIDE" class="headerlink" title="SDO_INSIDE"></a>SDO_INSIDE</h3><p>用于判断一个几何对象是否完全包含在另一个几何对象内部。</p><p>基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SDO_INSIDE(</span><br><span class="line">    geometry1  SDO_GEOMETRY,  -- 要检查的几何对象</span><br><span class="line">    geometry2  SDO_GEOMETRY,  -- 容器几何对象</span><br><span class="line">    tol        NUMBER         -- 容差</span><br><span class="line">) RETURN VARCHAR2;</span><br></pre></td></tr></table></figure><p>查询完全在某个区域内的所有建筑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT b.building_id, b.building_name</span><br><span class="line">FROM buildings b, city_zones z</span><br><span class="line">WHERE z.zone_id = 5</span><br><span class="line">AND SDO_INSIDE(</span><br><span class="line">    b.geometry,  -- 建筑几何</span><br><span class="line">    z.geometry,  -- 区域几何</span><br><span class="line">    0.05         -- 容差</span><br><span class="line">) = &#x27;TRUE&#x27;;</span><br></pre></td></tr></table></figure><p>检查点是否在多边形内</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">    CASE </span><br><span class="line">        WHEN SDO_INSIDE(</span><br><span class="line">            SDO_GEOMETRY(2001, 8307, SDO_POINT_TYPE(120.3, 30.5, NULL), NULL, NULL),</span><br><span class="line">            polygon_geom,</span><br><span class="line">            0.01</span><br><span class="line">        ) = &#x27;TRUE&#x27; THEN &#x27;Inside&#x27;</span><br><span class="line">        ELSE &#x27;Outside&#x27;</span><br><span class="line">    END AS position_status</span><br><span class="line">FROM administrative_areas</span><br><span class="line">WHERE area_id = 101;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Start&quot;&gt;&lt;a href=&quot;#Start&quot; class=&quot;headerlink&quot; title=&quot;Start&quot;&gt;&lt;/a&gt;Start&lt;/h2&gt;&lt;p&gt;今天的需求是在地图上撒了很多点，右击这个点时，可以选择一个半径，呈现在这个半径范围内的点。&lt;br&gt;和之前一个在地图上</summary>
      
    
    
    
    <category term="编程记录" scheme="https://cooooing.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="oracle" scheme="https://cooooing.github.io/tags/oracle/"/>
    
    <category term="经纬度" scheme="https://cooooing.github.io/tags/%E7%BB%8F%E7%BA%AC%E5%BA%A6/"/>
    
    <category term="地图" scheme="https://cooooing.github.io/tags/%E5%9C%B0%E5%9B%BE/"/>
    
    <category term="WGS84坐标系" scheme="https://cooooing.github.io/tags/WGS84%E5%9D%90%E6%A0%87%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>《apache Kafka实战》读书笔记-producer、consumer和设计原理</title>
    <link href="https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8Aapache%20Kafka%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-producer%E3%80%81consumer%E5%92%8C%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/"/>
    <id>https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8Aapache%20Kafka%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-producer%E3%80%81consumer%E5%92%8C%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/</id>
    <published>2025-03-12T14:56:21.000Z</published>
    <updated>2025-03-12T14:56:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>springboot 开发参考 <a class="link"   href="https://docs.spring.io/spring-kafka/reference/quick-tour.html" >Spring for Apache Kafka\Introduction\Quick Tour<i class="fas fa-external-link-alt"></i></a></p><h2 id="第四章-producer开发"><a href="#第四章-producer开发" class="headerlink" title="第四章 - producer开发"></a>第四章 - producer开发</h2><h3 id="producer概览"><a href="#producer概览" class="headerlink" title="producer概览"></a>producer概览</h3><p>Kafka producer 是负责向 Kafka 写入数据的应用程序。</p><p>Kafka producer在设计上要比consumer简单一些，因为它不涉及复杂的组管理操作，即每个producer都是独立进行工作的，与其他producer实例之间没有关联，因此它受到的牵绊自然也要少得多，实现起来也要简单得多。<br><strong>producer的首要功能就是向某个 topic的某个分区发送一条消息</strong>，所以它首先需要确认到底要向 topic 的哪个分区写入消息——这就是分区器（partitioner）要做的事情。<br>Kafka producer 提供了一个默认的分区器。对于每条待发送的消息而言，如果该消息指定了 key，那么该 partitioner 会根据 key的哈希值来选择目标分区；<br>若这条消息没有指定 key，则 partitioner 使用轮询的方式确认目标分区——这样可以最大限度地确保消息在所有分区上的均匀性。<br>当然producer的API赋予了用户自行指定目标分区的权力，即用户可以在消息发送时跳过partitioner直接指定要发送到的分区。<br>另外，producer 也允许用户实现自定义的分区策略而非使用默认的 partitioner，这样用户可以很灵活地根据自身的业务需求确定不同的分区策略。</p><p>通过 partitioner，我们就可以确信具有相同 key的所有消息都会被路由到相同的分区中。<br>这有助于实现一些特定的业务需求，比如可以利用局部性原理，将某些producer发送的消息固定地发送到相同机架上的分区从而减少网络传输的开销等。<br>如果没有指定key，那么所有消息会被均匀地发送到所有分区，而这通常也是最合理的分区策略。</p><p>确认了目标分区后，producer 要做的第二件事情就是要寻找这个分区对应的 leader，也就是该分区leader副本所在的Kafka broker。<br>每个topic分区都由若干个副本组成，其中的一个副本充当leader的角色，也只有leader才能够响应clients发送过来的请求，而剩下的副本中有一部分副本会与 leader副本保持同步，即所谓的 ISR。<br>因此在发送消息时，producer 也就有了多种选择来实现消息发送。比如不等待任何副本的响应便返回成功，或者只是等待 leader副本响应写入操作之后再返回成功等。</p><p>在java中，producer首先使用一个线程（用户主线程，也就是用户启动 producer的线程）将待发送的消息封装进一个 ProducerRecord 类实例。<br>然后将其序列化之后发送给 partitioner，再由后者确定了目标分区后一同发送到位于 producer程序中的一块内存缓冲区中。<br>而 producer的另一个工作线程（I&#x2F;O发送线程，也称 Sender线程）则负责实时地从该缓冲区中提取出准备就绪的消息封装进一个批次（batch），统一发送给对应的broker。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8Aapache%20Kafka%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-producer%E3%80%81consumer%E5%92%8C%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/Java%E7%89%88%E6%9C%ACproducer%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"                        alt="Java版本producer工作流程.png"                 ></p><h3 id="消息分区机制"><a href="#消息分区机制" class="headerlink" title="消息分区机制"></a>消息分区机制</h3><p>随 Kafka 发布的默认partitioner会尽力确保具有相同key的所有消息都会被发送到相同的分区上；若没有为消息指定 key，则该 partitioner会选择轮询的方式来确保消息在 topic的所有分区上均匀分配。<br>自定义分区策略实现<code>org.apache.kafka.clients.producer.Partitioner</code>接口即可：</p><ol><li><strong><code>int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster)</code></strong> 计算消息的目标分区。<ul><li><code>topic</code>: 主题名称。</li><li><code>key/value</code>: 消息的键值（可能为 <code>null</code>）。</li><li><code>keyBytes/valueBytes</code>: 序列化后的键值字节数组。</li><li><code>cluster</code>: 当前集群元数据（如可用分区信息）。</li></ul></li><li><strong><code>void close()</code></strong> 区器时释放资源（如网络连接或线程池）。</li><li><strong><code>void configure(Map&lt;String, ?&gt; configs)</code></strong> 分区器时调用，传递生产者的配置参数（如 <code>partitioner.class</code> 中配置的自定义参数）。</li></ol><h3 id="消息序列化"><a href="#消息序列化" class="headerlink" title="消息序列化"></a>消息序列化</h3><p>在网络中发送数据都是以字节的方式。<br>序列化器（serializer）负责在 producer 发送前将消息转换成字节数组；而与之相反，解序列化器（deserializer）则用于将 consumer 接收到的字节数组转换成相应的对象。</p><p>Kafka 支持用户自定义消息序列化。若要编写一个自定义的 serializer，需要实现 <code>org.apache.kafka.common.serialization.Serializer</code> 接口：</p><ol><li><strong><code>void configure(Map&lt;String, ?&gt; configs, boolean isKey)</code></strong> 初始化序列化器，读取生产者&#x2F;消费者的配置参数（如编码格式、压缩类型等）。<ul><li><code>configs</code>: Kafka 配置（如 <code>ProducerConfig</code> 或 <code>ConsumerConfig</code> 中的键值对）。</li><li><code>isKey</code>: 标记当前序列化的是键（Key）还是值（Value）。</li></ul></li><li><strong><code>byte[] serialize(String topic, T data)</code></strong> 将对象 <code>data</code> 序列化为字节数组。<ul><li><code>topic</code>: 目标主题名称（某些序列化器可能依赖主题元数据）。</li><li><code>data</code>: 待序列化的对象（可能是 <code>null</code>）。</li></ul></li><li><strong><code>void close()</code></strong> 关闭序列化器时释放资源（如文件句柄、网络连接等）。</li></ol><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>对于 producer而言，interceptor使得用户在消息发送前以及 producer回调逻辑前有机会对消息做一些定制化需求，比如修改消息等。<br>同时，producer 允许用户指定多个 interceptor 按序作用于同一条消息从而形成一个拦截链（interceptor chain）。interceptor 的实现接口是<code>org.apache.kafka.clients.producer.ProducerInterceptor</code></p><h3 id="无消息丢失配置"><a href="#无消息丢失配置" class="headerlink" title="无消息丢失配置"></a>无消息丢失配置</h3><p>Java 版本 producer 用户采用异步发送机制。KafkaProducer.send 方法仅仅把消息放入缓冲区中，由一个专属 I&#x2F;O 线程负责从缓冲区中提取消息并封装进消息 batch中，然后发送出去。<br>显然，这个过程中存在着数据丢失的窗口：若 I&#x2F;O线程发送之前 producer崩溃，则存储缓冲区中的消息全部丢失了。这是producer需要处理的很重要的问题。</p><p>producer 的另一个问题就是消息的乱序。如果发送两条消息 record1 和 record2。<br>由于某些原因（比如瞬时的网络抖动）导致 record1未发送成功，同时 Kafka 又配置了重试机制以及max.in.flight.requests.per.connection大于1（默认值是5）。<br>那么producer重试 record1成功后，record1在日志中的位置反而位于 record2之后，这样造成了消息的乱序。</p><p>很容易想到的一个方案就是：既然异步发送可能丢失数据，改成同步发送似乎是一个不错的主意。但是性能会很差，并不推荐在实际场景中使用。<br>因此最好能有一份配置，既使用异步方式还能有效地避免数据丢失，即使出现producer崩溃的情况也不会有问题。</p><h4 id="生产者（Producer）配置"><a href="#生产者（Producer）配置" class="headerlink" title="生产者（Producer）配置"></a>生产者（Producer）配置</h4><ol><li><strong><code>block.on.buffer.full = true</code>（已过时）</strong><ul><li>替代参数：<code>max.block.ms</code>（Kafka 0.9+ 后使用）</li><li>作用：当生产者缓冲区（内存）满时，阻塞生产者线程（而非丢弃消息），直到缓冲区有空间或超时。</li><li>配置原因：防止因生产者发送速度过快导致缓冲区溢出，从而丢失消息。</li><li>注意：在高版本 Kafka 中，此参数已被 <code>max.block.ms</code> 替代，需设置为一个较大的值（如 <code>max.block.ms=60000</code>）。</li></ul></li><li><strong><code>acks = all</code> 或 <code>acks = -1</code></strong><ul><li>作用：要求所有 ISR（In-Sync Replicas，同步副本）确认消息写入后，生产者才认为发送成功。</li><li>配置原因：确保消息至少被写入 Leader 和所有 ISR 副本的磁盘，避免 Leader 副本宕机后消息丢失。</li></ul></li><li><strong><code>retries = Integer.MAX_VALUE</code></strong><ul><li>作用：设置生产者无限重试发送失败的消息。</li><li>配置原因：应对网络抖动、Broker 临时不可用等场景，确保消息最终成功写入。</li><li>注意：需结合 <code>delivery.timeout.ms</code>（默认 120 秒）控制总重试时间，避免无限阻塞。</li></ul></li><li><strong><code>max.in.flight.requests.per.connection = 1</code></strong><ul><li>作用：限制单个连接上未确认的请求数最多为 1。</li><li>配置原因：防止因网络问题导致消息乱序重试时覆盖先前未确认的消息（如启用重试可能导致消息顺序错乱）。</li><li>权衡：降低吞吐量，但保证消息顺序性和可靠性。</li></ul></li><li><strong>使用带回调的 <code>send()</code> 方法：<code>KafkaProducer.send(record, callback)</code></strong><ul><li>作用：通过回调函数处理发送结果（成功或失败）。</li><li>配置原因：<ul><li>可捕获发送异常（如网络错误、序列化失败）。</li><li>在回调中执行重试或日志记录，确保消息不丢失。</li></ul></li></ul></li><li><strong>Callback 逻辑中显式关闭 Producer：<code>close(0)</code></strong><ul><li>作用：在发生不可恢复错误时，立即关闭生产者。</li><li>配置原因：<ul><li>避免继续发送可能失败的消息，防止数据丢失（如 Broker 永久不可用）。</li><li><code>close(0)</code> 表示立即关闭，不等待未完成请求。</li></ul></li><li>注意：需谨慎使用，仅在极端场景下关闭生产者（如关键业务不允许任何丢失）。</li></ul></li></ol><h4 id="Broker-配置"><a href="#Broker-配置" class="headerlink" title="Broker 配置"></a>Broker 配置</h4><ol><li><strong><code>unclean.leader.election.enable = false</code></strong><ul><li>作用：禁止非 ISR 副本（不同步的副本）参与 Leader 选举。</li><li>配置原因：<ul><li>若允许非 ISR 副本成为 Leader，可能丢失已提交但未同步到该副本的消息。</li><li>确保只有同步副本成为 Leader，避免数据丢失。</li></ul></li></ul></li><li><strong><code>replication.factor &gt;= 3</code></strong><ul><li>作用：每个分区的副本数设置为大于 3。<ul><li>配置原因：<ul><li>提供高冗余，即使多个 Broker 宕机，分区仍可用。</li><li>结合 <code>min.insync.replicas</code> 确保写入足够副本。</li></ul></li></ul></li></ul></li><li><strong><code>min.insync.replicas &gt; 1</code></strong><ul><li>作用：定义消息写入至少 2 个副本（包括 Leader）后才视为“已提交”。</li><li>配置原因：<ul><li>若写入副本数不足，生产者会收到 <code>NotEnoughReplicasException</code>，触发重试。</li><li>防止仅写入 Leader 后 Leader 宕机导致消息丢失。</li><li><strong>只有在 producer 端 acks 被设置成all或-1时，这个参数才有意义。</strong></li></ul></li></ul></li><li><strong><code>replication.factor &gt; min.insync.replicas</code></strong><ul><li>配置原因：<ul><li>确保在部分副本不可用时（如维护、故障），仍有足够 ISR 副本满足 <code>min.insync.replicas</code>。</li><li>例如：<code>replication.factor=3</code> 且 <code>min.insync.replicas=2</code>，允许 1 个副本离线不影响写入。</li></ul></li></ul></li></ol><h4 id="消费者（Consumer）配置"><a href="#消费者（Consumer）配置" class="headerlink" title="消费者（Consumer）配置"></a>消费者（Consumer）配置</h4><ol><li><strong><code>enable.auto.commit = false</code></strong><ul><li>作用：关闭消费者自动提交偏移量（offset）。</li><li>配置原因：<ul><li>自动提交可能导致消息未处理完成但偏移量已提交，若消费者崩溃，消息会丢失。</li><li>需手动调用 <code>commitSync()</code> 或 <code>commitAsync()</code>，确保消息处理完成后再提交偏移量。</li></ul></li></ul></li></ol><h3 id="消息压缩"><a href="#消息压缩" class="headerlink" title="消息压缩"></a>消息压缩</h3><p>数据压缩显著地降低了磁盘占用或带宽占用，从而有效地提升了 I&#x2F;O密集型应用的性能。<br>不过引入压缩同时会消耗额外的 CPU时钟周期，因此<strong>压缩是 I&#x2F;O性能和 CPU资源的平衡（trade-off）</strong>。</p><p>Kafka 压缩特性就是——producer 端压缩，broker 端保持，consumer 端解压缩。所谓的 broker 端保持是指 broker 端在通常情况下不会进行解压缩操作，它只是原样保存消息而已。<br>这里的“通常情况下”表示要满足一定的条件。如果有些前置条件不满足（比如需要进行消息格式的转换等），那么broker端就需要对消息进行解压缩然后再重新压缩。</p><p>如何调优 producer的压缩性能。</p><p>首先判断是否启用压缩的依据是 I&#x2F;O资源消耗与CPU资源消耗的对比。<br>如果生产环境中的I&#x2F;O资源非常紧张，比如producer程序消耗了大量的网络带宽或 broker端的磁盘占用率非常高，而 producer端的 CPU资源非常富裕，那么就可以考虑为producer开启消息压缩。<br>反之则不需要设置消息压缩以节省宝贵的CPU时钟周期。<br>其次，压缩的性能与 producer 端的 batch 大小息息相关。通常情况下我们可以认为 batch越大需要压缩的时间就越长。<br>batch大小越大，压缩时间就越长，不过时间的增长不是线性的，而是越来越平缓的。<br>如果发现压缩很慢，说明系统的瓶颈在用户主线程而不是 I&#x2F;O发送线程，因此可以考虑增加多个用户线程同时发送消息，这样通常能显著地提升producer吞吐量。</p><h2 id="第五章-consumer开发"><a href="#第五章-consumer开发" class="headerlink" title="第五章 - consumer开发"></a>第五章 - consumer开发</h2><h3 id="consumer概览"><a href="#consumer概览" class="headerlink" title="consumer概览"></a>consumer概览</h3><p>Kafka消费者（consumer）是从Kafka读取数据的应用。若干个 consumer订阅Kafka集群中的若干个 topic并从 Kafka接收属于这些 topic的消息。</p><p>消费者组：</p><blockquote><p>Consumers label themselves with a consumer group name,and each record published to a topic is delivered to one consumer instance within each subscribing consumer group.<br>消费者使用一个消费者组名（即 group.id）来标记自己，topic 的每条消息都只会被发送到每个订阅它的消费者组的一个消费者实例上。</p></blockquote><ol><li>一个 consumer group 可能有若干个 consumer实例（一个 group 只有一个实例也是允许的）。</li><li>对于同一个 group 而言，topic 的每条消息只能被发送到 group 下的一个 consumer 实例上。</li><li>topic 消息可以被发送到多个group中。</li></ol><p>前面说过 Kafka 同时支持基于队列和基于发布&#x2F;订阅的两种消息引擎模型。事实上 Kafka 就是通过 consumer group 实现的对这两种模型的支持。</p><ul><li>所有 consumer 实例都属于相同 group —— 实现基于队列的模型。每条消息只会被一个consumer实例处理。</li><li>consumer 实例都属于不同 group —— 实现基于发布&#x2F;订阅的模型。极端的情况是每个consumer 实例都设置完全不同的 group，这样 Kafka 消息就会被广播到所有 consumer实例上。</li></ul><p>consumer group是用于实现高伸缩性、高容错性的consumer机制。<br>组内多个 consumer实例可以同时读取 Kafka消息，而且一旦有某个 consumer“挂”了，consumer group会立即将已崩溃 consumer负责的分区转交给其他 consumer来负责。<br>从而保证整个 group 可以继续工作，不会丢失数据——这个过程被称为重平衡（rebalance）。</p><h3 id="位移（offset）"><a href="#位移（offset）" class="headerlink" title="位移（offset）"></a>位移（offset）</h3><p>这里 offset 指代的是 consumer端的 offset，与分区日志中的 offset是不同的含义。<br>每个 consumer 实例都会为它消费的分区维护属于自己的位置信息来记录当前消费了多少条消息。被称为 位移（offset）。<br>很多消息引擎都把消费端的 offset 保存在服务器端（broker）。这样做的好处当然是实现简单，但会有以下3个方面的问题。</p><ul><li>broker从此变成了有状态的，增加了同步成本，影响伸缩性。</li><li>需要引入应答机制（acknowledgement）来确认消费成功。</li><li>由于要保存许多 consumer 的 offset，故必然引入复杂的数据结构，从而造成不必要的资源浪费。</li></ul><p>Kafka 选择让 consumer group保存 offset，只需要简单地保存一个长整型数据。<br>同时 Kafka consumer 还引入了检查点机制（checkpointing）定期对offset进行持久化，从而简化了应答机制的实现。</p><p><strong>consumer客户端需要定期地向Kafka集群汇报自己消费数据的进度，这一过程被称为位移提交（offset commit）。</strong><br>位移提交这件事情对于 consumer 而言非常重要，它不仅表征了consumer 端的消费进度，同时也直接决定了 consumer 端的消费语义保证。</p><p>Kafka consumer 最开始会将位移提交到 Zookeeper，但这种方式并不好，ZooKeeper本质上只是一个协调服务组件，它并不适合作为位移信息的存储组件，毕竟频繁高并发的读&#x2F;写操作并不是 ZooKeeper擅长的事情。<br>所以在新版本中consumer把位移提交到 Kafka 的一个内部 topic（__consumer_offsets）上。该topic是一个内部topic，通常不能直接操作该topic。</p><p><strong>消费者组重平衡（consumer group rebalance）本质上是一种协议，规定了一个 consumer group下所有 consumer如何达成一致来分配订阅 topic的所有分区。</strong><br>假设我们有一个 consumer group，它有20个 consumer实例。该 group订阅了一个具有100个分区的 topic。<br>那么正常情况下，consumer group平均会为每个 consumer分配5个分区，即每个 consumer负责读取5个分区的数据。这个分配过程就被称作rebalance。</p><h3 id="消息轮询"><a href="#消息轮询" class="headerlink" title="消息轮询"></a>消息轮询</h3><p>Kafka的 consumer是用来读取消息的，而且要能够同时读取多个 topic的多个分区的消息。<br>若要实现并行的消息读取，一种方法是使用多线程的方式，为每个要读取的分区都创建一个专有的线程去消费；<br>另一种方法是采用类似于 Linux I&#x2F;O模型的 poll或 select等，使用一个线程来同时管理多个 Socket 连接，即同时与多个 broker 通信实现消息的并行读取。</p><p>一旦 consumer 订阅了 topic，所有的消费逻辑包括 coordinator 的协调、消费者组的rebalance以及数据的获取都会在主逻辑poll方法的一次调用中被执行。<br>这样用户很容易使用一个线程来管理所有的consumer I&#x2F;O操作。</p><p>consumer 订阅 topic 之后通常以事件循环的方式来获取订阅方案并开启消息读取。<br>仅仅是写一个循环，然后重复性地调用poll方法。剩下所有的工作都交给poll方法完成。每次poll方法返回的都是订阅分区上的一组消息。当然如果某些分区没有准备好，某次 poll 返回的就是空的消息集合。<br>poll方法根据当前consumer的消费位移返回消息集合。当poll首次被调用时，新的消费者组会被创建并根据对应的位移重设策略（auto.offset.reset）来设定消费者组的位移。<br>一旦consumer 开始提交位移，每个后续的 rebalance 完成后都会将位置设置为上次已提交的位移。传递给 poll 方法的超时设定参数用于控制 consumer 等待消息的最大阻塞时间。<br>由于某些原因，broker端有时候无法立即满足consumer端的获取请求（比如consumer要求至少一次获取1MB的数据，但 broker 端无法立即全部给出），那么此时 consumer 端将会阻塞以等待数据不断累积并最终满足 consumer需求。<br>如果用户不想让 consumer一直处于阻塞状态，则需要给定一个超时时间。因此poll方法返回满足以下任意一个条件即可返回。</p><ul><li>要么获取了足够多的可用数据。</li><li>要么等待时间超过了指定的超时设置。</li></ul><h3 id="位移管理"><a href="#位移管理" class="headerlink" title="位移管理"></a>位移管理</h3><p>offset 对于 consumer 非常重要，因为它是实现消息交付语义保证（message delivery semantic） 的基石。常见的3种消息交付语义保证如下。</p><ul><li>最多一次（at most once）处理语义：消息可能丢失，但不会被重复处理。</li><li>最少一次（at least once）处理语义：消息不会丢失，但可能被处理多次。</li><li>精确一次（exactly once）处理语义：消息一定会被处理且只会被处理一次。</li></ul><p>若consumer在消息消费之前就提交位移，那么便可以实现 at most once——因为若consumer 在提交位移与消息消费之间崩溃，则 consumer 重启后会从新的 offset 位置开始消费，前面的那条消息就丢失了。<br>若提交位移在消息消费之后，则可实现 at least once 语义。</p><p>除了offset，还有其他位置信息：</p><ul><li>上次提交位移（last committed offset）:consumer最近一次提交的offset值。</li><li>当前位置（current position）:consumer已读取但尚未提交时的位置。</li><li>水位（watermark）：也被称为高水位（high watermark），严格来说它不属于consumer 管理的范围，而是属于分区日志的概念。对于处于水位之下的所有消息，consumer 都是可以读取的，consumer 无法读取水位以上的消息。</li><li>日志终端位移（Log End Offset,LEO）：也被称为日志最新位移。同样不属于consumer 范畴，而是属于分区日志管辖。它表示了某个分区副本当前保存消息对应的最大的位移值。值得注意的是，正常情况下 LEO不会比水位值小。事实上，只有分区所有副本都保存了某条消息，该分区的leader副本才会向上移动水位值。</li></ul><p><strong>consumer最多只能读取到水位值标记的消息，而不能读取尚未完全被“写入成功”的消息，即位于水位值之上的消息。</strong></p><p>consumer 会在 Kafka 集群的所有 broker 中选择一个 broker 作为 consumer group 的coordinator，用于实现组成员管理、消费分配方案制定以及提交位移等。<br>当消费者组首次启动时，由于没有初始的位移信息，coordinator 必须为其确定初始位移值，这就是 consumer 参数 auto.offset.reset的作用。<br>通常情况下，consumer 要么从最早的位移开始读取，要么从最新的位移开始读取。</p><p>当 consumer运行了一段时间之后，它必须要提交自己的位移值。<br>如果 consumer崩溃或被关闭，它负责的分区就会被分配给其他 consumer，因此一定要在其他 consumer 读取这些分区前就做好位移提交工作，否则会出现消息的重复消费。</p><p>consumer 提交位移的主要机制是通过向所属的 coordinator 发送位移提交请求来实现的。每个位移提交请求都会往 __consumer_offsets 对应分区上追加写入一条消息。<br>消息的 key 是group.id、topic和分区的元组，而 value就是位移值。如果 consumer为同一个 group的同一个topic 分区提交了多次位移，那么 __consumer_offsets 对应的分区上就会有若干条 key 相同但value 不同的消息，但显然我们只关心最新一次提交的那条消息。<br>从某种程度来说，只有最新提交的位移值是有效的，其他消息包含的位移值其实都已经过期了。Kafka通过压实（compact）策略来处理这种消息使用模式。</p><p>默认情况下，consumer是自动提交位移的，自动提交间隔是5秒。这就是说若不做特定的设置，consumer程序在后台自动提交位移。通过设置<code>auto.commit.interval.ms</code>参数可以控制自动提交的间隔。</p><table><thead><tr><th></th><th>使用方法</th><th>优势</th><th>劣势</th><th>交付语义保证</th><th>使用场景</th></tr></thead><tbody><tr><td>自动提交</td><td>默认不用配置或显式设置enable.auto.commit&#x3D;ture</td><td>开发成本低，简单易用</td><td>无法实现精确控制，位移提交失败后不易处理</td><td>可能造成消息丢失，最多实现“最少一次”处理语义</td><td>对消息交付语义无需求，容忍一定的消息丢失</td></tr><tr><td>手动提交</td><td>设置enable.auto.commit&#x3D;false;手动调用commitSync或commitAsync提交位移</td><td>可精确控制位移提交行为</td><td>额外的开发成本，须自行处理位移提交</td><td>易实现“最少一次”处理语义，依赖外部状态可实现“精确一次”处理语义</td><td>消息处理逻辑重，不允许消息丢失，至少要求“最少一次”处理语义</td></tr></tbody></table><p>手动提交位移 API 进一步细分为同步手动提交和异步手动提交，即 commitSync 和commitAsync 方法。<br>如果调用的是 commitSync，用户程序会等待位移提交结束才执行下一条语句命令。<br>相反地，若是调用 commitAsync，则是一个异步非阻塞调用。consumer在后续 poll调用时轮询该位移提交的结果。<br>特别注意的是，这里的异步提交位移不是指 consumer 使用单独的线程进行位移提交。实际上 consumer 依然会在用户主线程的 poll 方法中不断轮询这次异步提交的结果。只是该提交发起时此方法是不会阻塞的，因而被称为异步提交。</p><h3 id="重平衡（rebalance）"><a href="#重平衡（rebalance）" class="headerlink" title="重平衡（rebalance）"></a>重平衡（rebalance）</h3><p>consumer group的rebalance本质上是一组协议，它规定了一个consumer group是如何达成一致来分配订阅 topic的所有分区的。<br>假设某个组下有20个 consumer实例，该组订阅了一个有着100个分区的 topic。正常情况下，Kafka会为每个 consumer平均分配5个分区。这个分配过程就被称为 rebalance。<br>当 consumer成功地执行 rebalance后，组订阅 topic的每个分区只会分配给组内的一个consumer实例。</p><h4 id="rebalance-触发条件"><a href="#rebalance-触发条件" class="headerlink" title="rebalance 触发条件"></a>rebalance 触发条件</h4><p>组rebalance触发的条件有以下3个。</p><ul><li>组成员发生变更，比如新 consumer 加入组，或已有 consumer 主动离开组，再或是已有consumer崩溃时则触发rebalance。</li><li>组订阅 topic 数发生变更，比如使用基于正则表达式的订阅，当匹配正则表达式的新topic被创建时则会触发rebalance。</li><li>组订阅 topic 的分区数发生变更，比如使用命令行脚本增加了订阅topic的分区数。</li></ul><p>如果一个 group 下的 consumer 处理消息的逻辑过重，并且事件的处理时间波动很大，非常不稳定。会导致 coordinator 会经常性地认为某个 consumer 已经挂掉，引发 rebalance。<br>这时需要仔细调优consumer 参数 request.timeout.ms、max.poll.records 和 max.poll.interval.ms，以避免不必要的rebalance出现。</p><h4 id="rebalance-分区分配"><a href="#rebalance-分区分配" class="headerlink" title="rebalance 分区分配"></a>rebalance 分区分配</h4><p>在 rebalance时 group下所有的 consumer都会协调在一起共同参与分区分配。<br>Kafka 新版本 consumer 默认提供了3种分配策略，分别是 range 策略、round-robin策略和sticky策略。</p><p>range策略主要是基于范围的思想。它将单个 topic 的所有分区按照顺序排列，然后把这些分区划分成固定大小的分区段并依次分配给每个 consumer。<br>round-robin策略则会把所有 topic的所有分区顺序摆开，然后轮询式地分配给各个consumer。<br>sticky策略有效地避免了上述两种策略完全无视历史分配方案的缺陷，采用了“有黏性”的策略对所有 consumer 实例进行分配，可以规避极端情况下的数据倾斜并且在两次rebalance间最大限度地维持了之前的分配方案。</p><p>通常意义上认为，如果 group 下所有 consumer 实例的订阅是相同，那么使用 round-robin会带来更公平的分配方案，否则使用range策略的效果更好。<br>新版本 consumer 默认的分配策略是 range。用户根据consumer参数<code>partition.assignment.strategy</code>来进行设置。<br>另外Kafka支持自定义的分配策略，用户可以创建自己的consumer分配器（assignor）。</p><h4 id="rebalance-generation"><a href="#rebalance-generation" class="headerlink" title="rebalance generation"></a>rebalance generation</h4><p>某个consumer group可以执行任意次rebalance。为了更好地隔离每次rebalance上的数据，新版本 consumer设计了 rebalance generation用于标识某次 rebalance。<br>generation这个词类似于JVM分代垃圾收集器中“分代”（严格来说，JVM GC使用的是 generational）的概念。<br>在consumer中它是一个整数，通常从0开始。Kafka引入consumer generation主要是为了保护consumer group的，特别是防止无效offset提交。<br>比如上一届的 consumer成员由于某些原因延迟提交了 offset，但 rebalance之后该 group产生了新一届的group成员，而这次延迟的offset提交携带的是旧的generation信息，因此这次提交会被consumer group拒绝。</p><h4 id="rebalance协议"><a href="#rebalance协议" class="headerlink" title="rebalance协议"></a>rebalance协议</h4><p>rebalance 本质上是一组协议。group 与 coordinator 共同使用这组协议完成group的rebalance。</p><ul><li>JoinGroup请求：consumer请求加入组。</li><li>SyncGroup请求：group leader把分配方案同步更新到组内所有成员中。</li><li>Heartbeat请求：consumer定期向coordinator汇报心跳表明自己依然存活。</li><li>LeaveGroup请求：consumer主动通知coordinator该consumer即将离组。</li><li>DescribeGroup 请求：查看组的所有信息，包括成员信息、协议信息、分配方案以及订阅信息等。该请求类型主要供管理员使用。coordinator不使用该请求执行rebalance。</li></ul><h4 id="rebalance流程"><a href="#rebalance流程" class="headerlink" title="rebalance流程"></a>rebalance流程</h4><p>consumer group在执行rebalance之前必须首先确定coordinator所在的broker，并创建与该broker 相互通信的 Socket 连接。<br>确定 coordinator 的算法与确定 offset 被提交到__consumer_offsets目标分区的算法是相同的。算法如下。</p><ul><li>计算 Math.abs（groupID.hashCode） % offsets.topic.num.partitions参数值（默认是 50），假设是10。</li><li>寻找__consumer_offsets分区10的leader副本所在的broker，该broker即为这个group的coordinator。<br>成功连接 coordinator之后便可以执行 rebalance操作。目前 rebalance主要分为两步：加入组和同步更新分配方案。</li><li><strong>加入组</strong>：这一步中组内所有 consumer（即 group.id 相同的所有 consumer 实例）向coordinator发送 JoinGroup请求。<br>当收集全 JoinGroup请求后，coordinator从中选择一个consumer担任group的leader，并把所有成员信息以及它们的订阅信息发送给leader。<br>特别需要注意的是，group 的 leader 和 coordinator 不是一个概念。leader 是某个consumer 实例，coordinator 通常是 Kafka 集群中的一个 broker。另外 leader 而非coordinator负责为整个group的所有成员制定分配方案。</li><li><strong>同步更新分配方案</strong>：这一步中 leader 开始制定分配方案，即根据前面提到的分配策略决定每个consumer都负责哪些topic的哪些分区。<br>一旦分配完成，leader会把这个分配方案封装进 SyncGroup 请求并发送给 coordinator。比较有意思的是，组内所有成员都会发送 SyncGroup请求，不过只有 leader发送的 SyncGroup请求中包含了分配方案。<br>coordinator 接收到分配方案后把属于每个 consumer 的方案单独抽取出来作为SyncGroup请求的response返还给各自的consumer。</li></ul><p><strong>consumer group分配方案是在 consumer端执行的。</strong> Kafka将这个权力下放给客户端主要是因为这样做可以有更好的灵活性。<br>比如在这种机制下用户可以自行实现类似于 Hadoop 那样的机架感知（rack-aware）分配方案。同一个机架上的分区数据被分配给相同机架上的 consumer，减少网络传输的开销。<br>而且，即使以后分区策略发生了变更，也只需要重启 consumer 应用即可，不必重启Kafka服务器。</p><h4 id="rebalance监听器"><a href="#rebalance监听器" class="headerlink" title="rebalance监听器"></a>rebalance监听器</h4><p>新版本 consumer 默认把位移提交到__consumer_offsets 中。其实，Kafka 也支持用户把位移提交到外部存储中，比如数据库中。<br>若要实现这个功能，用户就必须使用 rebalance监听器。使用 rebalance监听器的前提是用户使用consumer group。如果使用的是独立consumer或是直接手动分配分区，那么rebalance监听器是无效的。</p><p>rebalance 监听器有一个主要的接口回调类 ConsumerRebalanceListener，里面就两个方法onPartitionsRevoked和onPartitionAssigned。<br>在 coordinator 开启新一轮 rebalance 前 onPartitionsRevoked 方法会被调用，而 rebalance 完成后会调用 onPartitionsAssigned 方法。</p><blockquote><p>鉴于 consumer 通常都要求 rebalance 在很短的时间内完成，千万不要在 rebalance监听器的两个方法中放入执行时间很长的逻辑，特别是一些阻塞方法，如各种阻塞队列的take或poll等。</p></blockquote><h3 id="解序列化"><a href="#解序列化" class="headerlink" title="解序列化"></a>解序列化</h3><p>解序列化（deserializer）或称反序列化与前面的序列化（serializer）是互逆的操作。<br>Kafka consumer从broker端获取消息的格式是字节数组，consumer需要把它还原回指定的对象类型，而这个对象类型通常都是与序列化对象类型一致的。<br>比如 serializer 把一个字符串序列化成字节数组，consumer使用对应的deserializer把字节数组还原回字符串。</p><h3 id="多线程消费实例"><a href="#多线程消费实例" class="headerlink" title="多线程消费实例"></a>多线程消费实例</h3><p>KafkaConsumer 是非线程安全的。它和 KafkaProducer 不同，后者是线程安全的。</p><p>实现多线程消费consumer的一种方式是创建多个线程来消费 topic 数据。每个线程都会创建专属于该线程的KafkaConsumer实例。<br>另一种方式是将消息的获取与消息的处理解耦，把后者放入单独的工作者线程中，即所谓的 worker线程中。同时在全局维护一个或若干个 consumer 实例执行消息获取任务。</p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>方法1（每个线程维护专属KafkaConsumer)</td><td>实现简单；速度较快，因为无线程间交互开销：方便位移管理；易于维护分区间的消息消费顺序</td><td>Socket连接开销大；consumer数受限于topic分区数，扩展性差；broker端处理负载高（因为发往broker的请求数多）；rebalance可能性增大</td></tr><tr><td>方法2（全局consumer+多worker线程）</td><td>消息获取与处理解耦；可独立扩展consumer数和worker数，伸缩性好</td><td>实现负载；难于维护分区内的消息顺序；处理链路变长，导致位移管理困难；worker线程异常可能导致消费数据丢失</td></tr></tbody></table><h3 id="独立consumer"><a href="#独立consumer" class="headerlink" title="独立consumer"></a>独立consumer</h3><p>group自动帮用户执行分区分配和 rebalance。对于需要有多个 consumer 共同读取某个 topic 的需求来说，使用group 是非常方便的。<br>但有的时候用户依然有精确控制消费的需求，比如严格控制某个consumer固定地消费哪些分区。比如：</p><ul><li>如果进程自己维护分区的状态，那么它就可以固定消费某些分区而不用担心消费状态丢失的问题。</li><li>如果进程本身已经是高可用且能够自动重启恢复错误（比如使用YARN和Mesos等容器调度框架），那么它就不需要让Kafka来帮它完成错误检测和状态恢复。</li></ul><p>以上两种情况中 consumer group 都是无用武之地的，取而代之的是被称为独立 consumer （standalone consumer）的角色。<br>standalone consumer 间彼此独立工作互不干扰。任何一个consumer崩溃都不影响其他standalone consumer的工作。</p><h2 id="第六章-Kafka设计原理"><a href="#第六章-Kafka设计原理" class="headerlink" title="第六章 - Kafka设计原理"></a>第六章 - Kafka设计原理</h2><h3 id="broker端设计架构"><a href="#broker端设计架构" class="headerlink" title="broker端设计架构"></a>broker端设计架构</h3><p>broker是Apache Kafka最重要的组件，本质上它是一个功能载体（或服务载体），承载了绝大多数的Kafka服务。<br>事实上，大多数的消息队列框架都有broker或与之类似的角色。一个broker 通常是以服务器的形式出现的，对用户而言，broker 的主要功能就是持久化消息以及将消息队列中的消息从发送端传输到消费端。<br>Kafka的broker负责持久化producer端发送的消息，同时还为consumer端提供消息。</p><h4 id="消息设计"><a href="#消息设计" class="headerlink" title="消息设计"></a>消息设计</h4><p>这里先提及一下 Kafka的消息集合以及消息层次的概念。<br>事实上，无论是哪个版本的 Kafka，它的消息层次都分为两层：消息集合（message set）和消息。</p><p>一个消息集合包含若干个日志项，而每个日志项都封装了实际的消息和一组元数据信息。<br>Kafka 日志文件就是由一系列消息集合日志项构成的。Kafka 不会在消息层面上直接操作，它总是在消息集合上进行写入操作。<br>每个消息集合中的日志项由一条“浅层”消息和日志项头部组成。</p><ul><li>浅层消息（shallow message）：如果没有启用消息压缩，那么这条浅层消息就是消息本身；否则，Kafka会将多条消息压缩到一起统一封装进这条浅层消息的 value字段。<br>此时该浅层消息被称为包装消息（或外部消息，即 wrapper消息），而value字段中包含的消息则被称为内部消息，即 inner消息。V0、V1 版本中的日志项只能包含一条浅层消息。</li><li>日志项头部（log entry header）：头部由8字节的位移（offset）字段加上4字节的长度（size）字段构成。注意这里的 offset非consumer端的offset，它是指该消息在 Kafka分区日志中的 offset。<br>同样地，如果是未压缩消息，该 offset就是消息的 offset；否则该字段表示 wrapper消息中最后一条 inner消息的 offset。<br>因此，从 V0、V1 版本消息集合日志项中搜寻该日志项的起始位移（base offset 或 starting offset）是一件非常困难的事情，因为在该过程中Kafka需要深度遍历所有inner消息，这也就意味着broker端需要执行解压缩的操作，可见代价之高。</li></ul><p>上面V0、V1版本消息集合在设计上的一些缺陷：</p><ul><li>空间利用率不高：不论key和value长度是多少，它总是使用4字节固定长度来保存这部分信息。<br>例如，这两个版本保存100或是1000都是使用4字节，但其实我们只需要7位就足以保存100这个数字了，也就是说，只用1字节就足够，另外3字节纯属浪费。</li><li>只保存最新消息位移：如前所述，若启用压缩，这个版本中的 offset 是消息集合中最后一条消息的offset。<br>如果用户想要获取第1条消息的位移，必须要把所有的消息全部解压缩装入内存，然后反向遍历才能获取，显然这个代价是很大的。</li><li>冗余的消息级 CRC校验：为每条消息都执行 CRC 校验有些“鸡肋”。即使在网络传输过程中没有出现恶意篡改，我们也不能想当然地认为在 producer 端发送的消息到consumer 端时其 CRC 值是不变的。<br>若用户指定时间戳类型是 LOG_APPEND_TIME，broker 将使用当前时间戳覆盖掉消息已有时间戳，那么当 broker 端对消息进行时间戳更新后，CRC 就需要重新计算从而发生变化；<br>再如，broker 端进行消息格式转换（broker 端和 clients 端要求版本不一致时会发生消息格式转换，不过这对用户而言是完全透明的）也会带来 CRC值的变化。<br>所以对每条消息都执行 CRC 校验实际上没有必要，不仅浪费空间，还占用了宝贵的CPU时间片。</li><li>未保存消息长度：每次需要单条消息的总字节数信息时都需要计算得出，没有使用单独字段来保存。<br>每次计算时为了避免对现有数据结构的破坏，都需要大量的对象副本，解序列化效率很低。</li></ul><p>V2版本依然分为消息和消息集合两个维度，只不过消息集合的提法被消息批次所取代。下面是V2版本消息的格式：</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8Aapache%20Kafka%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-producer%E3%80%81consumer%E5%92%8C%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/V2%E7%89%88%E6%9C%AC%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F.png"                        alt="V2版本消息格式.png"                 ></p><p>“可变长度”表示 Kafka会根据具体的值来确定到底需要几字节保存。为了在序列化时降低使用的字节数，V2版本借鉴了Google ProtoBuffer中的Zig-zag编码方式，使得绝对值较小的整数占用比较少的字节。<br>Zig-zag编码方式主要的思想就是将一个有符号32位整数编码成一个无符号整数，同时各个数字围绕0依次编码。</p><table><thead><tr><th>编码前</th><th>编码后</th></tr></thead><tbody><tr><td>0</td><td>0</td></tr><tr><td>-1</td><td>1</td></tr><tr><td>1</td><td>2</td></tr><tr><td>-2</td><td>3</td></tr><tr><td>2</td><td>4</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>这种编码方式可使用较少的字节来保存绝对值很小的负数。而不用保存32位整数的补码，浪费很多位的空间。</p><p>由于可能使用多字节来编码一个数字，Zig-zag 会固定地将每个字节的第1位留作特殊用途，来表明该字节是否是某个数编码的最后一个字节。<br>即最高位若是1，则表明编码尚未结束，还需要读取后面的字节来获取完整编码；若是0，则表示下一个字节是新的编码。<br>鉴于这个原因，Zig-zag 中每个字节只有7位可用于实际的编码任务，因此单个字节只能编码0～127之间的无符号整数。</p><p>V2版本的消息格式变化：</p><ul><li>增加消息总长度字段：在消息格式的头部增加该字段，一次性计算出消息总字节数后保存在该字段中，而不需要像之前版本一样每次重新计算。<br>Kafka 操作消息时可直接获取总字节数，直接创建出等大小的 ByteBuffer，然后分别装填其他字段，简化了消息处理过程。<br>总字节数的引入还实现了消息遍历时的快速跳跃和过滤，省去了很多空间拷贝的开销。</li><li>保存时间戳增量（timestamp delta）：不再需要使用8字节来保存时间戳信息，而是使用一个可变长度保存与 batch 起始时间戳的差值。差值通常都是很小的，故需要的字节数也是很少的，从而节省了空间。</li><li>保存位移增量（offset delta）：与时间戳增量类似，保存消息位移与外层 batch 起始位移的差值，而不再固定保存8字节的位移值，进一步节省消息总字节数。</li><li>增加消息头部（message headers）：V2 版本中每条消息都必须有一个头部数组，里面的每个头部信息只包含两个字段：头部 key和头部 value，类型分别是 String和 byte[]。<br>增加头部信息主要是为了满足用户的一些定制化需求，比如，做集群间的消息路由之用或承载消息的一些特定元数据信息。</li><li>去除消息级 CRC 校验：V2 版本不再为每条消息计算 CRC32 值，而是对整个消息batch进行CRC校验。</li><li>废弃attribute字段：V0、V1版本格式都有一个attribute字段，V2版本的消息正式废弃了这个字段。<br>原先保存在 attribute字段中的压缩类型、时间戳等信息都统一保存在外层的batch格式字段中，但V2版本依然保留了单字节的attribute字段留作以后扩展使用。</li></ul><p>V2版本的消息batch格式：</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8Aapache%20Kafka%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-producer%E3%80%81consumer%E5%92%8C%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/V2%E7%89%88%E6%9C%AC%E6%B6%88%E6%81%AFbatch%E6%A0%BC%E5%BC%8F.png"                        alt="V2版本消息batch格式.png"                 ></p><ul><li>CRC值从消息层面被移除，被放入batch这一层。</li><li>batch层面上增加了一个双字节 attribute字段，同时废弃了消息级别的 attribute字段。<br>在这个双字节的 attribute字段中，最低的 3位依然保存压缩类型，第 4位依然保存时间戳类型，而第5、6位分别保存0.11.0.0版本新引入的事务类型和控制类型。</li><li>PID、producer epoch和序列号等信息都是0.11.0.0版本为了实现幂等性 producer和支持事务而引入的。<br>PID表示一个幂等性producer的ID值，producer epoch表示某个PID携带的当前版本号。<br>broker使用 PID和 epoch来确定当前合法的 producer实例，并以此阻止过期 producer向 broker生产消息。<br>序列号的引入主要是为了实现消息生产的幂等性。Kafka依靠它来辨别消息是否已成功提交，从而防止出现重复生产消息。</li></ul><h4 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h4><p>Kafka 是分布式的消息引擎集群环境，它支持自动化的服务发现与成员管理。<br>Kafka 是依赖 Apache ZooKeeper 实现的。每当一个broker启动时，它会将自己注册到ZooKeeper下的一个节点。</p><p>Kafka 4.0 彻底移除了 Zookeeper，默认允许在 KRaft 模式下，大大简化了集群的部署和管理，消除了集成 ZooKeeper 的复杂性。<br>这部分略。</p><h4 id="副本与ISR设计"><a href="#副本与ISR设计" class="headerlink" title="副本与ISR设计"></a>副本与ISR设计</h4><p>个 Kafka分区本质上就是一个备份日志，即利用多份相同的备份共同提供冗余机制来保持系统高可用性。这些备份在 Kafka 中被称为副本（replica）。<br>Kafka 把分区的所有副本均匀地分配到所有broker上，并从这些副本中挑选一个作为leader副本对外提供服务，而其他副本被称为 follower副本，只能被动地向 leader副本请求数据，从而保持与 leader副本的同步。</p><p>假如 leader 副本永远工作正常，那么其实不需要 follower 副本。但现实总是残酷的，Kafka leader 副本所在的 broker 可能因为各种各样的原因而随时宕机。<br>一旦发生这种情况，follower副本会竞相争夺成为新leader的权力。显然不是所有的follower都有资格去竞选leader。<br>follower 会被动地向 leader 请求数据。但对于那些落后 leader 进度太多的 follower 而言，它们是没有资格竞选 leader 的，毕竟它们手中握有的数据太旧了，如果允许它们成为 leader，会造成数据丢失，而这对 clients 而言是灾难性的。鉴于这个原因，Kafka引入了ISR的概念。</p><p>所谓 ISR，就是 Kafka集群动态维护的一组同步副本集合（in-sync replicas）。每个 topic分区都有自己的ISR列表，ISR中的所有副本都与leader保持同步状态。<br>值得注意的是，leader副本总是包含在ISR中的，只有ISR中的副本才有资格被选举为leader。而producer写入的一条 Kafka 消息只有被 ISR 中的所有副本都接收到，才被视为 “已提交”状态。<br>由此可见，若ISR中有N个副本，那么该分区最多可以忍受N-1个副本崩溃而不丢失已提交消息。</p><h5 id="follower副本同步"><a href="#follower副本同步" class="headerlink" title="follower副本同步"></a>follower副本同步</h5><p>follower副本只做一件事情：向 leader副本请求数据。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8Aapache%20Kafka%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-producer%E3%80%81consumer%E5%92%8C%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/%E5%89%AF%E6%9C%AC%E5%90%84%E7%A7%8D%E4%BD%8D%E7%BD%AE%E4%BF%A1%E6%81%AF.png"                        alt="副本各种位置信息.png"                 ></p><ul><li>起始位移（base offset）：表示该副本当前所含第一条消息的offset。</li><li>高水印值（high watermark,HW）：副本高水印值。它保存了该副本最新一条已提交消息的位移。<br>leader 分区的 HW 值决定了副本中已提交消息的范围，也确定了consumer能够获取的消息上限，超过 HW值的所有消息都被视为“未提交成功的”，因而consumer是看不到的。另外值得注意的是，不是只有leader副本才有HW值。实际上每个 follower副本都有 HW值，只不过只有<br>leader副本的 HW值才能决定 clients能看到的消息数量罢了。</li><li>日志末端位移（log end offset,LEO）：副本日志中下一条待写入消息的 offset。所有副本都需要维护自己的LEO信息。每当leader副本接收到producer端推送的消息，它会更新自己的LEO（通常是加1）。<br>同样，follower副本向leader副本请求到数据后也会增加自己的 LEO。事实上只有 ISR中的所有副本都更新了对应的 LEO之后，leader副本才会向右移动HW值表明消息写入成功。</li></ul><p>假设当前Kafka集群当前只有一个topic，该topic只有一个分区，分区共有3个副本，因此ISR中也是这3个副本。该topic当前没有任何数据。由于没有任何数据，因此3个副本的LEO都是0,HW值是0。<br>现有一个producer向broker1所在的leader副本发送了一条消息，接下来会发生什么呢？</p><ol><li>broker1上的leader副本接收到消息，把自己的LEO值更新为1。</li><li>broker2和broker3上的follower副本各自发送请求给broker1。</li><li>broker1分别把该消息推送给follower副本。</li><li>follower副本接收到消息后各自更新自己的LEO为1。</li><li>leader副本接收到其他 follower副本的数据请求响应（response）之后，更新 HW值为1。此时位移为0的这条消息可以被consumer消费。</li></ol><p>对于设置了 acks&#x3D;-1 的 producer而言，只有完整地做完上面所有的5步操作，producer才能正常返回，这也标志着这条消息发送成功。</p><h5 id="ISR设计"><a href="#ISR设计" class="headerlink" title="ISR设计"></a>ISR设计</h5><p>0.9.0.0版本之前，Kafka提供了一个参数replica.lag.max.messages，用于控制follower副本落后 leader副本的消息数。<br>一旦超过这个消息数，则视为该 follower为“不同步”状态，从而需要被Kafka“踢出”ISR。</p><p>但在消息不稳定时，比如 出现 producer 的瞬时高峰流量、网络IO导致 follower 请求消息速度变慢、进程卡住等情况，会导致 follower 不断地被踢出 ISR，然后重新加回 ISR，造成了与 leader不同步、再同步、又不同步、再次同步的情况发生。</p><p>所以在0.9.0.0版本之后，Kafka去掉了之前的 replica.lag.max.messages参数，改用统一的参数同时检测由于慢以及进程卡壳而导致的滞后（lagging）——即 follower副本落后 leader副本的时间间隔。<br>这个唯一的参数就是 replica.lag.time.max.ms，默认值是 10 秒。对于“请求速度追不上”的情况，检测机制也发生了变化——如果一个 follower副本落后 leader的时间持续性地超过了这个参数值，那么该 follower 副本就是“不同步”的。<br>这样即使出现producer瞬时峰值流量，只要 follower 不是持续性落后，它就不会反复地在 ISR 中移进、移出。</p><h4 id="水印（watermark）和leader-epoch"><a href="#水印（watermark）和leader-epoch" class="headerlink" title="水印（watermark）和leader epoch"></a>水印（watermark）和leader epoch</h4><p>水印也被称为高水印或高水位，通常被用在流式处理领域（著名的框架如Apache Storm、Apache Flink和Apache Spark等），以表征元素或事件在基于时间层面上的进度。<br>一个比较经典的表述为：流式系统保证在水印t时刻，创建时间（event time） &#x3D; t＇且t＇ ≤ t的所有事件都已经到达或被观测到。在 Kafka中，水印的概念反而与时间无关，而与位置信息相关。<br>严格来说，它表示的就是位置信息，即位移（offset）。</p><p>一个 Kafka 分区下通常存在多个副本（replica）用于实现数据冗余，进一步实现高可用性。如前所述，副本根据角色不同分为如下3类。</p><ul><li>leader副本：响应clients端读&#x2F;写请求的副本。</li><li>follower副本：被动地备份leader副本上的数据，不能响应clients端的读&#x2F;写请求。</li><li>ISR副本集合：包含leader副本和所有与leader副本保持同步的follower副本。</li></ul><p>每个Kafka副本对象都持有两个重要的属性：日志末端位移（log end offset，下称LEO）和高水印（HW）。注意是<strong>所有的副本</strong> ，而不止是leader副本。以下是这两个属性的解释。</p><ul><li>LEO：日志末端位移，记录了该副本对象底层日志文件中下一条消息的位移值。<br>举一个例子，若 LEO&#x3D;10，那么表示在该副本日志上已经保存了10条消息，位移范围是[0,9]。另外，Kafka对leader副本和follower副本的LEO更新机制是不同的，后面会详细讨论。</li><li>HW：任何一个副本对象的 HW值一定不大于其 LEO值，而小于或等于 HW 值的所有消息被认为是“已提交的”或“已备份的”（replicated）。<br>Kafka对 leader副本和 follower副本的 HW值更新机制也是不同的，后面内容将会讨论它们的不同。</li></ul><p>如果把 LEO和 HW看作两个指针，那么它们定位的机制是不同的：<strong>任意时刻，HW指向的是实实在在的消息，而 LEO总是指向下一条待写入消息，也就是说 LEO指向的位置上是没有消息的！</strong></p><h5 id="LEO更新机制"><a href="#LEO更新机制" class="headerlink" title="LEO更新机制"></a>LEO更新机制</h5><p>首先是Kafka如何更新follower副本的LEO属性。<br>follower副本只是被动地向leader副本请求数据，具体表现为 follower副本不停地向 leader副本所在的 broker发送 FETCH请求，一旦获取消息，便写入自己的日志中进行备份。</p><p>follower 副本的 LEO 是何时更新的呢？严格来说，Kafka 设计了两套 follower 副本LEO 属性：<br>一套 LEO 值保存在 follower 副本所在 broker 的缓存上；另一套 LEO 值保存在leader副本所在 broker的缓存上，换句话说，leader副本所在机器的缓存上保存了该分区下所有follower副本的LEO属性值（当然也包括它自己的LEO）。</p><p>保存两套值是因为Kafka需要利用前者帮助follower副本自身更新HW值，而同时还需要使用后者来确定leader副本的HW值，即分区HW。</p><ol><li>follower副本端的follower副本LEO何时更新？<br>follower副本端的 follower副本 LEO值就是指该副本对象底层日志的LEO值，也就是说，每当新写入一条消息，其 LEO值就会加 1。<br>在 follower发送 FETCH请求后，leader将数据返回给 follower，此时 follower开始向底层 log写数据，从而自动更新其LEO值。</li><li>leader副本端的follower副本LEO何时更新？<br>leader副本端的follower副本LEO的更新发生在leader处理follower FETCH请求时。<br>一旦leader接收到follower发送的FETCH请求，它首先会从自己的log中读取相应的数据，但是在给follower返回数据之前它先去更新follower的LEO（即上面所说的第二套LEO值）。</li><li>最后是leader副本更新 LEO的机制和时机。和 follower更新 LEO道理相同，leader写log时就会自动更新它自己的LEO值。</li></ol><h5 id="HW更新机制"><a href="#HW更新机制" class="headerlink" title="HW更新机制"></a>HW更新机制</h5><p>follower 更新 HW 发生在其更新LEO之后，一旦follower向log写完数据，它就会尝试更新HW值。<br>具体算法就是比较当前LEO值与FETCH响应中leader的HW值，取两者的小者作为新的HW值。<br>这告诉我们一个事实：如果follower的LEO值超过了leader的HW值，那么follower HW值是不会越过leader HW值的。</p><p>比起follower副本的HW属性，leader副本HW值的更新更重要，因为它直接影响了分区数据对于 consumer的可见性 。</p><p>下面四种情况会尝试更新分区 HW值：</p><ul><li>副本成为leader副本时：当某个副本成为分区的leader副本，Kafka会尝试更新分区HW。这是显而易见的道理，毕竟分区leader发生了变更，这个副本的状态是一定要检查的。</li><li>broker 出现崩溃导致副本被踢出 ISR 时：若有 broker崩溃，则必须查看是否会波及此分区，因此检查分区HW值是否需要更新是有必要的。</li><li>producer 向 leader 副本写入消息时：因为写入消息会更新 leader的 LEO，故有必要再查看HW值是否也需要更新。</li><li>leader 处理follower FETCH 请求时：当leader处理follower的FETCH请求时，首先会从底层的log读取数据，之后再尝试更新分区HW值。</li></ul><p>基于水印的备份机制会造成 <strong>数据丢失</strong> 和 <strong>数据不一致&#x2F;数据离散</strong> 的风险。<br>因为 HW 值被用于衡量副本备份的成功与否，以及在出现崩溃时作为日志截断的依据，但 HW 值的更新是异步延迟的，特别是需要额外的 FETCH 请求处理流程才能更新，故这中间发生的任何崩溃都可能导致 HW 值的过期。<br>鉴于这些原因，Kafka 0.11.0.0引入了leader epoch来取代HW值。leader端多开辟一段内存区域专门保存leader的epoch信息，这样即使出现上面的两个场景，Kafka也能很好地规避这些问题。</p><p>所谓领导者epoch（leader epoch），实际上是一对值（epoch,offset）。epoch表示leader的版本号，从0开始，当leader变更过1次时，epoch就会加1，而offset则对应于该epoch版本的leader写入第一条消息的位移。<br>假设存在两对值（0,0）和（1,120），那么表示第一个leader从位移0开始写入消息，共写了120条，即[0,119]；而第二个leader版本号是1，从位移120处开始写入消息。</p><p>每个leader broker中会保存这样一个缓存，并定期写入一个检查点文件中。<br>当leader写底层 log 时，它会尝试更新整个缓存——如果这个 leader 首次写消息，则会在缓存中增加一个条目，否则就不做更新。<br>而每次副本重新成为 leader时会查询这部分缓存，获取对应 leader版本的位移，这就不会发生数据不一致和丢失的情况。</p><h4 id="日志存储设计"><a href="#日志存储设计" class="headerlink" title="日志存储设计"></a>日志存储设计</h4><h5 id="Kafka-日志"><a href="#Kafka-日志" class="headerlink" title="Kafka 日志"></a>Kafka 日志</h5><p>Kafka日志属于专门为程序访问的日志。而不是常见的松散结构化的请求日志、错误日志或其他数据。<br>从某种意义上说，Kafka 日志的设计更像是关系型数据库中的记录，抑或是某些系统中所谓的提交日志（commit log）或日志（journal）。这些日志有一个共同的特点就是：只能按照时间顺序在日志尾部追加写入记录（record）。</p><p>日志记录按照被写入的顺序保存，读取日志以从左到右的方式进行。每条记录都会被分配一个唯一的且顺序增加的记录号作为定位该消息的唯一标识（位移信息）。<br>记录中消息内容和格式的实现可能有多种方式，比如使用 XML 格式或 JSON 格式。如前所述，Kafka 则是自己定义了消息格式并且在写入日志前序列化成紧凑的二进制字节数组来保存日志。</p><p>日志中记录的排序通常按照时间顺序，即位于日志左边部分的记录的发生时间通常要小于位于右边部分的记录。<br>Kafka 自0.10.0.0版本开始在消息体中增加了时间戳信息。默认情况下，消息创建时间会被封装进消息中，因此，Kafka 记录大部分遵循按时间排序这一规则。<br>当然，凡事皆有例外，Kafka的Java版本producer确实支持用户为消息指定时间戳，用户完全可以打乱这种时间排序。只不过这样的话，时间戳索引文件可能会失效，因此，在实际中似乎并没有太多的使用场景。</p><p>Kafka 的日志设计都是以分区为单位的，即每个分区都有它自己的日志，该日志被称为分区日志（partition log）。<br>producer 生产 Kafka 消息时需要确定该消息被发送到的分区，然后Kafka broker把该消息写入该分区对应的日志中。<br>具体对每个日志而言，Kafka又将其进一步细分成日志段文件（log segment file）以及日志段索引文件。<br>所以，每个分区日志都是由若干组日志段文件+索引文件构成的。</p><h5 id="底层文件系统"><a href="#底层文件系统" class="headerlink" title="底层文件系统"></a>底层文件系统</h5><p>创建 topic时，Kafka为该 topic的每个分区在文件系统中创建了一个对应的子目录，名字就是<topic>-&lt;分区号&gt;。<br>所以，倘若有一个 topic 名为 test，有两个分区，那么在文件系统中Kafka会创建两个子目录：test-0和 test-1。每个日志子目录的文件构成都是若干组日志段+索引文件。</p><p>日志段文件，即后缀名是.log 的文件保存着真实的 Kafka 记录。<br>每个.log文件都包含了一段位移范围的Kafka记录。Kafka使用该文件第一条记录对应的offset来命名此.log文件。<br>因此，每个新创建的 topic分区一定有 offset是0的.log文件，即00000000000000000000.log。<br>虽然在 Kafka内部 offset是用64位来保存的，但目前对于日志段文件而言，Kafka只使用20位数字来标识offset。不过对于实际的线上环境而言，这通常是足够的。</p><p>Kafka每个日志段文件是有上限大小的，由 broker端参数log.segment.bytes 控制，默认就是1GB 大小。<br>因此，当日志段文件填满记录后，Kafka 会自动创建一组新的日志段文件和索引文件——这个过程被称为日志切分（log rolling）。<br>日志切分后，新的日志文件被创建并开始承担保存记录的角色。</p><p>一旦日志段被填满，它就不能再追加写入新消息了，而 Kafka 正在写入的分区日志段文件被称为当前激活日志段（active log segment）或简称为当前日志段。<br>当前日志段非常特殊，它不受任何 Kafka后台任务的影响，比如定期日志清除任务和定期日志compaction任务。</p><h5 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h5><p>除了.log 文件，Kafka 分区日志还包含两个特殊的文件.index 和.timeindex，它们都是索引文件，分别被称为位移索引文件和时间戳索引文件。<br>前者可以帮助broker更快地定位记录所在的物理文件位置，而后者则是根据给定的时间戳查找对应的位移信息。</p><p>它们都属于稀疏索引文件（sparse index file），每个索引文件都由若干条索引项（index entry）组成。<br>Kafka 不会为每条消息记录都保存对应的索引项，而是待写入若干条记录后才增加一个索引项。<br>broker 端参数 log.index.interval.bytes 设置了这个间隔到底是多大，默认值是4KB，即 Kafka 分区至少写入了 4KB 数据后才会在索引文件中增加一个索引项，故本质上它们是稀疏的。</p><p>不论是位移索引文件还是时间戳索引文件，它们中的索引项都按照某种规律进行升序排列。<br>对于位移索引文件而言，它是按照位移顺序保存的；而时间戳索引文件则严格按照时间戳顺序保存。<br>由于有了这种升序规律，Kafka可以利用二分查找（binary search）算法来搜寻目标索引项，从而降低整体时间复杂度到 O（lgN）。<br>若没有索引文件，Kafka 搜寻记录的方式只能是从每个日志段文件的头部顺序扫描，因此，这种方案的时间复杂度是 O（N）。<br>显然，引入索引文件可以极大地减少查找时间，减少broker端的CPU开销。</p><p>当前，索引文件支持两种打开方式：只读模式和读&#x2F;写模式。<br>对于非当前日志段而言，其对应的索引文件通常以只读方式打开，即只能读取索引文件中的内容而不能修改它。反之，当前日志段的索引文件必须要能被修改，因此总是以读&#x2F;写模式打开的。<br>当日志进行切分时，索引文件也需要进行切分。此时，Kafka 会关闭当前正在写入的索引文件，同时以读&#x2F;写模式创建一个新的索引文件。<br>broker 端参数 log.index.size.max.bytes 设置了索引文件的最大文件大小，默认值是10MB。和日志段文件不同，索引文件的空间默认都是预先分配好的，而当对索引文件切分时，Kafka 会把该文件大小“裁剪”到真实的数据大小。</p><p>位移索引文件和时间戳索引文件的格式。</p><ol><li>位移索引文件<br>每个索引项固定地占用8字节的物理空间，同时Kafka强制要求索引文件必须是索引项大小的整数倍，即8的整数倍。<br>因此，假设设置参数log.index.size.max.bytes为300，那么Kafka在内部会“勒令”该文件大小为296——即不大于300的最大的8的倍数。<br>前4位是相对位移——它保存的是与索引文件起始位移的差值。索引文件文件名中的位移就是该索引文件的起始位移。通过保存差值，我们只需要4字节而非保存整个位移的8字节。<br>后4位是文件物理位置。<br>如果想要增加索引项的密度，可以减少broker端参数log.index.interval.bytes的值。</li><li>时间戳索引文件<br>每个索引项固定占用12字节的物理空间，同时 Kafka强制要求索引文件必须是索引项大小的整数倍，即12的整数倍。<br>因此，假设设置参数log.index.size.max.bytes为100，那么Kafka在内部会“勒令”该文件大小为96——即不大于100的最大的12的倍数。时间戳索引项保存的也是相对位移值。<br>前8位是时间戳。<br>后4位是相对位移。<br>时间戳索引项保存的是时间戳与位移的映射关系。<strong>给定时间戳之后根据此索引文件只能找到不大于该时间戳的最大位移，稍后 Kafka 还需要拿着返回的位移再去位移索引文件中定位真实的物理文件位置</strong>。<br>该索引文件中的时间戳一定是按照升序排列的。<br>若消息R2在日志段中位于R1之前，但R2的时间戳小于R1（这是可能的，因为Java版本producer允许用户手动指定时间戳），那么 R2这条消息是不会被记录在时间戳索引项中的，因为这会造成时间的乱序。<br>目前 Kafka 还无力调整这种时间“错乱”的情况，而缺乏对应的索引项也会使得 clients 根据时间戳查找消息的结果不能完全准确，因而在实际场景中并不推荐producer端直接手动指定时间戳的用法。</li></ol><h5 id="日志留存"><a href="#日志留存" class="headerlink" title="日志留存"></a>日志留存</h5><p>Kafka 是会定期清除日志的，而且清除的单位是日志段文件，即删除符合清除策略的日志段文件和对应的两个索引文件。当前留存策略有如下两种。</p><ul><li>基于时间的留存策略：Kafka 默认会清除 7 天前的日志段数据（包括索引文件）。<br>Kafka提供了3个broker端参数，其中log.retention.{hours|minutes|ms}用于配置清除日志的时间间隔，其中的ms优先级最高，minutes次之，hours优先级最低。</li><li>基于大小的留存策略：Kafka默认只会为每个log保存log.retention.bytes参数值大小的字节数。<br>默认值是-1，表示Kafka不会对log进行大小方面的限制。</li></ul><p>日志清除是一个异步过程，Kafka broker 启动后会创建单独的线程处理日志清除事宜。<br>另外，一定要注意的是，日志清除对于当前日志段是不生效的。也就是说，Kafka 永远不会清除当前日志段。<br>因此，若把日志段文件最大文件的大小设置得过大而导致没有出现日志切分，那么日志清除也就永远无法执行。</p><p>在基于时间的清除策略中，0.10.0.0版本之前 Kafka 使用日志段文件的最近修改时间（当前时间与最近修改时间的差值）来衡量日志段文件是否依然在留存时间窗口中，但文件的最近修改时间属性经常有可能被“无意”修改（比如执行了 touch 操作）。<br>因此，在0.10.0.0版本引入时间戳字段后，该策略会计算当前时间戳与日志段首条消息的时间戳之差作为衡量日志段是否留存的依据。如果第一条消息没有时间戳信息，Kafka才会使用最近修改时间的属性。</p><h5 id="日志compaction"><a href="#日志compaction" class="headerlink" title="日志compaction"></a>日志compaction</h5><p>前面讨论的所有 topic都有这样一个特点：<br>clients端通常需要访问和处理这种 topic下的所有消息，但考虑这样一种应用场景，某个 Kafka topic 保存的是用户的邮箱地址，每次用户更新邮箱地址时都会发送一条Kafka消息。<br>该消息的key就是用户ID，而value保存了邮件地址信息。假设用户 ID 为 user123 的用户连续修改了 3 次邮件地址，那么就会产生 3 条对应的Kafka消息，如下：</p><ol><li>user123 &#x3D;&gt; <a class="link"   href="mailto:&#117;&#115;&#x65;&#114;&#49;&#x32;&#x33;&#64;&#x6b;&#97;&#102;&#107;&#97;&#49;&#x2e;&#99;&#x6f;&#x6d;" >user123@kafka1.com<i class="fas fa-external-link-alt"></i></a></li><li>user123 &#x3D;&gt; <a class="link"   href="mailto:&#x75;&#115;&#x65;&#114;&#x31;&#x32;&#51;&#64;&#107;&#97;&#102;&#107;&#x61;&#x32;&#x2e;&#99;&#111;&#109;" >user123@kafka2.com<i class="fas fa-external-link-alt"></i></a></li><li>user123 &#x3D;&gt; <a class="link"   href="mailto:&#117;&#115;&#101;&#114;&#49;&#50;&#51;&#64;&#107;&#97;&#x66;&#107;&#97;&#51;&#46;&#x63;&#x6f;&#x6d;" >user123@kafka3.com<i class="fas fa-external-link-alt"></i></a></li></ol><p>显然，在这种情况下用户只关心最近修改的邮件地址，即value是<a class="link"   href="mailto:&#117;&#x73;&#101;&#114;&#x31;&#x32;&#51;&#64;&#x6b;&#97;&#102;&#x6b;&#x61;&#x33;&#x2e;&#99;&#x6f;&#x6d;" >user123@kafka3.com<i class="fas fa-external-link-alt"></i></a>的那条消息，而之前的其他消息都是“过期”的，可以放心删除。<br>但前面提到的清除策略都无法实现这样的处理逻辑，因此，Kafka社区引入了log compaction。</p><p><strong>log compaction 确保Kafka topic每个分区下的每条具有相同 key的消息都至少保存最新 value的消息。</strong><br>它提供了更细粒度化的留存策略。这也说明了如果要使用log compaction,Kafka消息必须要设置key。无key消息是无法为其进行压实操作的。典型的log compaction使用场景如下。</p><ul><li>数据库变更订阅：用户通常在多个数据系统存有数据，比如数据库、缓存、查询集群和 Hadoop 集群等。对数据库的所有变更都需要同步到其他数据系统中。在同步的过程中用户没必要同步所有数据，只需要同步最近的变更或增量变更。</li><li>事件溯源（event sourcing）：编织查询处理逻辑到应用设计中并使用变更日志保存应用状态。</li><li>高可用日志化（journaling）：将本地计算进程的变更实时记录到本地状态中，以便在出现崩溃时其他进程可以加载该状态，从而实现整体上的高可用。</li></ul><p>log compaction相关的Kafka log结构：<br>为了实现log compaction,Kafka在逻辑上将每个log划分成log tail和log head。<br>log head和普通的Kafka log没有区别。事实上，它就是Kafka log的一部分，在log head中所有offset都是连续递增的。<br>log tail中消息的位移则是不连续的，它已经是压实之后（compacted）的消息集合了。<br><strong>log compaction 只会根据某种策略有选择性地移除 log 中的消息，而不会变更消息的offset值。</strong></p><p>Kafka有一个组件叫 Cleaner，它就是负责执行 compaction操作的。Cleaner负责从 log中移除已废弃的消息。<br>log compaction是topic级别的设置。一旦为某个topic启用了log compaction,Kafka会将该 topic 的日志在逻辑上划分成两部分：“已清理”部分和“未清理”部分，后者又可进一步划分成“可清理”部分和“不可清理”部分。<br>“不可清理”部分无法被 Kafka Cleaner 清理，而当前日志段永远属于“不可清理”部分。当前 Kafka 使用一些后台线程定期执行真正的清理任务。每个线程会挑选出“最脏”的日志段执行清理。衡量一个日志段“脏”的程度使用“脏”日志部分与总日志大小的比率。<br>在内部，Kafka 会构造一个哈希表来保存 key与最新位移的映射关系。当执行 compaction时，Cleaner 不断拷贝日志段中的数据，只不过它会无视那些 key 存在于哈希表中但具有较大位移值的消息。</p><p>当前与compaction相关的Kafka参数如下。</p><ul><li>log.cleanup.policy：是否启用 log compaction。0.10.1.0 版本之前只有两种取值，即delete 和 compact。<br>其中 delete 是默认值，表示采用之前所说的留存策略；设置compact 则表示启用 log compaction。<br>自 0.10.1.0 版本开始，该参数支持同时指定两种策略，如 log.cleanup.policy&#x3D;delete,compact，表示既为该 topic 执行普通的留存策略，也对其进行log compaction。</li><li>log.cleaner.enable：是否启用 log Cleaner。<br>在 0.9.0.0 及之前的版本中该参数默认值是false，即不启用 compaction。对于这些版本的用户来说，如果要启用 Cleaner，则必须显式地设置该参数&#x3D;true。<br>自 0.9.0.1版本之后该参数便默认为 true。另外需要注意的是，如果要使用 log compaction，则必须将此参数设置为 true，否则即使用户设置log.cleanup.policy&#x3D;compact,Kafka也不会执行清理任务。</li><li>log.cleaner.min.compaction.lag.ms：默认值是 0，表示除了当前日志段，理论上所有的日志段都属于“可清理”部分，但有时候用户可能不想这么激进，用户可以设置此参数值来保护那些比某个时间新的日志段不被清理。<br>假设设置此参数为 10分钟，当前时间是下午 1点钟，那么所有最大时间戳（通常都是最后一条消息的时间戳）在 12:50之后的日志段都不可清理。</li></ul><p>前面有提到过Kafka新版本consumer使用__consumer_offsets内部topic来保存位移信息。<br>这个 topic 就是采用 log compaction 留存策略的，因为对于每一个 key（通常是groupId + topic + 分区号）而言，我们只关心最新的位移值——这是非常典型的log compaction使用场景。</p><h4 id="通信协议（wire-protocol）"><a href="#通信协议（wire-protocol）" class="headerlink" title="通信协议（wire protocol）"></a>通信协议（wire protocol）</h4><h5 id="协议设计"><a href="#协议设计" class="headerlink" title="协议设计"></a>协议设计</h5><p>所谓通信协议，就是实现client-server间或server-server间数据传输的一套规范。<br>Kafka的通信协议是基于 TCP 之上的二进制协议，这套协议提供的 API 表现为服务于不同功能的多种请求（request）类型以及对应的响应（response）。<br>所有类型的请求和响应都是结构化的，由不同的初始类型构成。Kafka使用这组协议完成各个功能的实现。</p><p>Kafka客户端与broker传输数据时，首先需要创建一个连向特定broker的Socket连接，然后按照待发送请求类型要求的结构构造响应的请求二进制字节数数组，之后发送给broker并等待从 broker处接收响应。<br>假如是像发送消息和消费消息这样的请求，clients通常会一直维持与某些broker的长连接，从而创建TCP连接的开销被不断地摊薄给每条具体的请求。</p><p>实际使用过程中，单个Kafka clients通常需要同时连接多个broker服务器进行数据交互，但在每个 broker 之上只需要维护一个 Socket 连接用于数据传输。<br>clients 可能会创建额外的Socket连接用于其他任务，如元数据获取以及组rebalance等。<br>Kafka自带的Java clients（包括Java版本producer和Java版本consumer）使用了类似于epoll的方式在单个连接上不停地轮询以传输数据。</p><p>broker端需要确保在单个Socket连接上按照发送顺序对请求进行一一处理，然后依次返回对应的响应结果。<br>单个 TCP 连接上某一时刻只能处理一条请求的做法正是为了保证不会出现请求乱序。当然这是 broker 端的做法，clients 端在实现时需要自行保证请求发送顺序。<br>比如Java版本 producer默认情况下会对 PRODUCE请求（专门用于发送消息的请求）进行流水化处理，在内存中它允许多条未处理完成的请求同时排队等候被发送。<br>这样做的好处是提升了producer 端的吞吐量，但潜在的风险是 PRODUCE 请求发送乱序所导致的消息生产乱序。在实际应用中，用户可以通过设置参数 max.in.flight.requests.per.connection&#x3D;1来关闭这种流水化作业。</p><p>Kafka 通信协议中规定的请求发送流向有3种。除了上面所说的 clients给 broker发送请求之外，Kafka集群中的controller也能够给其他broker发送请求。<br>clients可能给多个 broker发送请求，而 controller会向所有 broker发送请求。<br>当然 clients也可以给 controller直接发送请求，只是在这种情况下 clients只当其是一个普通的 broker而已。<br>第三种方式就是follower副本所在broker向leader副本所在broker发送请求，不过这只能是固定的FETCH请求。<br>Kafka的broker端提供了一个可配置的参数用于限制broker端能够处理请求的最大字节数。一旦超过了该阈值，发生此请求的Socket连接就会被强制关闭。clients观察到连接关闭后只能执行连接重建和请求重试等的逻辑。</p><h5 id="请求-响应结构"><a href="#请求-响应结构" class="headerlink" title="请求&#x2F;响应结构"></a>请求&#x2F;响应结构</h5><p>Kafka 协议提供的所有请求及其响应的结构体都是由固定格式组成的，它们统一构建于多种初始类型（primitive types）之上。这些初始类型如下。</p><ul><li>固定长度初始类型：包括int8、int16、int32和int64，分别表示有符号的单字节整数、双字节整数、4字节整数和8字节整数。</li><li>可变长度初始类型：包括bytes和string，由一个有符号整数N加上后续的N字节组成。N表示它们的内容，若是-1，则表示内容为空。其中 string类型使用 int16来保存 N；bytes使用int32来保存N。</li><li>数组：用于处理结构体之类重复性数据结构。它们总是被编码成一个int32类型的整数N 以及后续的 N 字节。同样，N表示该数组的长度信息，而具体到里面的元素可以是其他的初始类型。</li></ul><p>所有的请求和响应都具有统一的格式，即Size + Request&#x2F;Response，其中的Size是int32表示的整数，表征了该请求或响应的长度信息。<br>请求又可划分成请求头部和请求体，请求体的格式因请求类型的不同而变化，但请求头部的结构是固定的——它由以下4个字段构成。</p><ul><li>api_key：请求类型，以int16整数表示。</li><li>api_version：请求版本号，以int16整数表示。</li><li>correlation_id：与对应响应的关联号，实际中用于关联 response 与 request，方便用户调试和排错。该字段以int32整数表示。</li><li>client_id：表示发出此请求的client ID。实际场景中用于区分集群上不同clients发送的请求。该字段是一个非空字符串。<br>同理，响应也可划分成响应头部和响应体，响应体的格式因其对应的请求类型的不同而变化，但响应头部的结构是固定的——它只有下面的这个字段。</li><li>correlation_id：该字段值就是上面请求头部中的 correlation_id。有了该字段，用户就能够知道该响应对应于哪个请求了。<br>Kafka 推荐用户总是指定 client_id 和 correlation_id，这样可以方便用户后续定位问题和DEBUG。</li></ul><h5 id="常见请求类型"><a href="#常见请求类型" class="headerlink" title="常见请求类型"></a>常见请求类型</h5><p>其中具体格式省略，各版本可能不一致。</p><ol><li>PRODUCE请求<br>这是编号为0的请求，即api_key &#x3D; 0，也就是Kafka通信协议中的第一个请求类型。顾名思义，它实现消息的生产。clients向broker发送PRODUCE请求并期待broker端返回响应表明消息生产是否成功。</li><li>FETCH请求<br>FETCH 请求是编号为1的请求，即 api_key &#x3D; 1。它服务于消费消息，既包括 clients 向broker发送的FETCH请求，也包括分区follower副本发送给leader副本的FETCH请求。</li><li>METADATA请求<br>clients向broker发送METADATA请求以获取指定topic的元数据信息。</li></ol><h5 id="请求处理流程"><a href="#请求处理流程" class="headerlink" title="请求处理流程"></a>请求处理流程</h5><ol><li>clients端<br>Kafka并没有规定这些请求必须被如何处理，它要求的只是 clients端代码必须要构造符合格式的请求，然后发送给broker。每种语言的clients端代码必须自行实现对请求和响应的完整的生命周期管理。<br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8Aapache%20Kafka%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-producer%E3%80%81consumer%E5%92%8C%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/Java%E7%89%88%E6%9C%ACclients%E7%AB%AF%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png"                        alt="Java版本clients端请求处理流程.png"                 ></li><li>broker端<br>每个 broker 启动时都会创建一个请求阻塞队列，专门用于接收从 clients 端发送过来的请求。同时，broker还会创建若干个请求处理线程专门获取并处理该阻塞队列中的请求<br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8Aapache%20Kafka%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-producer%E3%80%81consumer%E5%92%8C%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/Java%E7%89%88%E6%9C%ACbroker%E7%AB%AF%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png"                        alt="Java版本broker端请求处理流程.png"                 ></li></ol><h4 id="controller设计"><a href="#controller设计" class="headerlink" title="controller设计"></a>controller设计</h4><p>在一个 Kafka 集群中，某个 broker 会被选举出来承担特殊的角色，即控制器（下称controller）。<br>顾名思义，引入 controller 就是用来管理和协调 Kafka 集群的。具体来说，就是管理集群中所有分区的状态并执行相应的管理操作。</p><p>每个 Kafka 集群任意时刻都只能有一个 controller。当集群启动时，所有 broker 都会参与controller的竞选，但最终只能由一个 broker胜出。<br>一旦 controller在某个时刻崩溃，集群中剩余的broker会立刻得到通知，然后开启新一轮的controller选举。新选举出来的controller将承担起之前controller的所有工作。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8Aapache%20Kafka%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-producer%E3%80%81consumer%E5%92%8C%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/controller%E6%9E%B6%E6%9E%84.png"                        alt="controller架构.png"                 ></p><h5 id="controller管理状态"><a href="#controller管理状态" class="headerlink" title="controller管理状态"></a>controller管理状态</h5><p>controller维护的状态分为两类：每台broker上的分区副本和每个分区的 leader副本信息。<br>从维度上看，这些状态又可分为副本状态和分区状态。controller为了维护这两个状态专门引入了两个状态机，分别管理副本状态和分区状态。</p><ol><li>副本状态机（Replica State Machine）<br>当前，Kafka为副本定义了7种状态以及每个状态之间的流转规则。这些状态分别如下。<ul><li>NewReplica:controller 创建副本时的最初状态。当处在这个状态时，副本只能成为follower副本。</li><li>OnlineReplica：启动副本后变更为该状态。在该状态下，副本既可以成为 follower 副本也可以成为leader副本。</li><li>OfflineReplica：一旦副本所在broker崩溃，该副本将变更为该状态。</li><li>ReplicaDeletionStarted：若开启了 topic 删除操作，topic 下所有分区的所有副本都会被删除。此时副本进入该状态。</li><li>ReplicaDeletionSuccessful：若副本成功响应了删除副本请求，则进入该状态。</li><li>ReplicaDeletionIneligible：若副本删除失败，则进入该状态。</li><li>NonExistentReplica：若副本被成功删除，则进入该状态。<br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8Aapache%20Kafka%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-producer%E3%80%81consumer%E5%92%8C%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/%E5%89%AF%E6%9C%AC%E7%8A%B6%E6%80%81%E6%9C%BA.png"                        alt="副本状态机.png"                 ></li></ul></li><li>分区状态机（Partition State Machine）<br>除了副本状态机，controller 还引入了分区状态机来负责集群下所有分区的状态管理。<ul><li>NonExistent：表明不存在的分区或已删除的分区。</li><li>NewPartition：一旦被创建，分区便处于该状态。此时，Kafka 已经为分区确定了副本列表，但尚未选举出leader和ISR。</li><li>OnlinePartition：一旦该分区的 leader 被选出，则进入此状态。这也是分区正常工作时的状态。</li><li>OfflinePartition：在成功选举出leader后，若leader所在的broker宕机，则分区将进入该状态，表明无法正常工作了。<br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8Aapache%20Kafka%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-producer%E3%80%81consumer%E5%92%8C%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/%E5%88%86%E5%8C%BA%E7%8A%B6%E6%80%81%E6%9C%BA.png"                        alt="分区状态机.png"                 ></li></ul></li></ol><h5 id="controller职责"><a href="#controller职责" class="headerlink" title="controller职责"></a>controller职责</h5><p>对集群状态的维护只是 controller 保持运行状态一致性的一个基本要素，但却不是controller 的职责所在。<br>应该这样说，如果保持 controller 持续稳定地对外提供服务，就必须要求controller妥善地保存这些状态。实际上，controller的职责相当多，包括如下职责。</p><ol><li>更新集群元数据信息。<br>一个clients能够向集群中任意一台broker发送METADATA请求来查询topic的分区信息（比如 topic有多少个分区、每个分区的 leader在哪台 broker上以及分区的副本列表）。<br>随着集群的运行，这部分信息可能会发生变化，因此就需要 controller 提供一种机制，用于随时随地地把变更后的分区信息广播出去，同步给集群上所有的 broker。<br>具体做法就是，当有分区信息发生变更时，controller将变更后的信息封装进 UpdateMetadataRequests请求（通信协议中的一种）中，然后发送给集群中的每个broker，这样clients在请求数据时总是能够获取最新、最及时的分区信息。</li><li>创建topic。<br>controller 启动时会创建一个 ZooKeeper 的监听器，该监听器的唯一任务就是监控ZooKeeper节点&#x2F;brokers&#x2F;topics下子节点的变更情况。当前一个 clients或 admin创建 topic的方式主要有如下3种。<ul><li>通过kafka-topics脚本的–create创建。</li><li>构造CreateTopicsRequest请求创建</li><li>配置broker端参数auto.create.topics.enable为true，然后发送MetadataRequest请求。</li></ul></li><li>删除topic。<br>标准的Kafka删除topic方法有如下两种。<ul><li>通过kafka-topics脚本的–delete来删除topic。</li><li>构造DeleteTopicsRequest。</li></ul></li><li>分区重分配。<br>分区重分配操作通常都是由 Kafka 集群的管理员发起的，旨在对 topic 的所有分区重新分配副本所在broker的位置，以期望实现更均匀的分配效果。<br>分区副本重分配的过程实际上是先扩展再收缩的过程。controller首先将分区副本集合进行扩展（旧副本集合与新副本集合的合集），等待它们全部与 leader保持同步之后将 leader设置为新分配方案中的副本，最后执行收缩阶段，将分区副本集合缩减成分配方案中的副本集合。</li><li>preferred leader副本选举。<br>为了避免分区副本分配不均匀，Kafka引入了 preferred副本的概念。比如一个分区的副本列表是[1,2,3]，那么broker 1就被称为该分区的preferred leader，因为它位于副本列表的第一位。<br>在集群运行的过程中，分区的 leader因为各种各样的原因会发生变更，从而使得 leader不再是preferred leader，此时用户可以发起命令将这些分区的leader重新调整为preferred leader。具体的方法有如下两种。<ul><li>设置 broker端参数 auto.leader.rebalance.enable为 true，这样 controller会定时地自动调整preferred leader。</li><li>通过kafka-preferred-replica-election脚本手动触发。</li></ul></li><li>topic分区扩展。<br>当前增加分区主要使用kafka-topics脚本的–alter选项来完成。和创建 topic一样它会向 ZooKeeper的&#x2F;brokers&#x2F;topics&#x2F;<topic>节点下写入新的分区目录。</li><li>broker加入集群。<br>每个broker成功启动之后都会在ZooKeeper的&#x2F;broker&#x2F;ids下创建一个znode，并写入broker的信息。如果要让Kafka动态地维护broker列表，就必须注册一个ZooKeeper监听器时刻监控该目录下的数据变化。<br>每当有新 broker 加入集群时，该监听器会感知到变化，执行对应的 broker 启动任务，之后更新集群元数据信息并广而告之。</li><li>broker崩溃。<br>由于当前broker在 ZooKeeper中注册的znode是临时节点，因此一旦broker崩溃，broker与ZooKeeper的会话会失效并导致临时节点被删除，故上面监控broker加入的那个监听器同样被用来监控那些因为崩溃而退出集群的 broker 列表。</li><li>受控关闭。<br>受控关闭是由即将关闭的 broker向 controller发送请求的。请求的名字是 ControlledShutdownRequest。<br>一旦发送完 ControlledShutdownRequest，待关闭 broker将一直处于阻塞状态，直到接收到 broker端发送的 ControlledShutdownResponse，表示关闭成功，或用完所有重试机会后强行退出。</li><li>controller leader选举。<br>作为 Kafka 集群的重要组件，controller 必然要支持故障转移（fail-over）。若当前controller 发生故障或显式关闭，Kafka 必须要能够保证及时选出新的 controller。<br>当前，一个Kafka集群中发生controller leader选举的场景共有如下4种。<ul><li>关闭controller所在broker。</li><li>当前controller所在broker宕机或崩溃。</li><li>手动删除ZooKeeper的&#x2F;controller节点。</li><li>手动向ZooKeeper的&#x2F;controller节点写入新的broker id。<br>这4种操作变更实际上都是&#x2F;controller节点的内容，因此 controller只需要做一件事情：创建一个监听该目录的监听器。<br>&#x2F;controller 本质上是一个临时节点，节点保存了当前 controller 所在的 broker id。集群首次启动时所有 broker 都会抢着创建该节点，但ZooKeeper保证了最终只能有一个broker胜出——胜出的那个broker即成为controller。<br>一旦成为 controller，它会增加 controller的版本号，即更新&#x2F;controller_epoch节点的值，然后履行上面所有的这些职责。<br>对于那些没有成为 controller 的 broker 们而言，它们不会甘心失败，而是继续监听&#x2F;controller节点的存活情况并随时准备竞选新的controller。</li></ul></li></ol><h4 id="broker请求处理"><a href="#broker请求处理" class="headerlink" title="broker请求处理"></a>broker请求处理</h4><h5 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h5><p>Kafka broker处理请求的模式就是 Reactor设计模式。根据维基百科的定义，Reactor设计模式是一种事件处理模式，旨在处理多个输入源同时发送过来的请求。<br>Reactor 模式中的服务处理器（service handler）或分发器（dispatcher）将入站请求（inbound request）按照多路复用的方式分发到对应的请求处理器（request handler）中。</p><p>本质上这和生产者-消费者的模式很像。外部的输入源就类似于producer角色，它们的工作就是生产“事件”发送给Reactor中的dispatcher，具体而言是将事件放入dispatcher中的队列上；而Reactor通常会创建多个request handler线程专门消费dispatcher分发过来的事件。<br>对于Kafka而言，该模型中的事件实际上对应于Socket连接通道（SocketChannel），即broker上每当有新的Socket连接通道被创建，dispatcher都会将该连接分发给下面某个request handler来消费。</p><p>Reactor 模式中有很两个很重要的组件 acceptor 线程和 processor 线程。acceptor 线程实时地监听外部数据源发送过来的事件，并执行分发任务；processor 线程执行事件处理逻辑并将处理结果发送给 client。</p><h5 id="Kafka-broker请求处理"><a href="#Kafka-broker请求处理" class="headerlink" title="Kafka broker请求处理"></a>Kafka broker请求处理</h5><p>Kafka broker 请求处理实现了上面的 Reactor 模式。在 Kafka 中，每个 broker 都有一个acceptor 线程和若干个 processor 线程。processor 线程的数量是可以配置的。<br>num.network.threads就用于控制该数量的 broker端参数，默认值是 3，即每个 broker都创建 3个processor线程。值得注意的是，broker会为用户配置的每组listener创建一组processor线程。<br>每个 broker 可以同时设置多种通信安全协议，比如PLAINTEXT和 SSL，因此一旦某个 broker同时配置了多套通信安全协议，那么 Kafka会为每个协议都创建一组processor线程。</p><p>clients 端通常会保存与broker 的长连接，因此不需要频繁地重建 Socket 连接，故broker端固定使用一个 acceptor线程来唯一地监听入站连接。<br>由于只做新连接监听这一件事情，acceptor 线程的处理逻辑是很轻量级的，在实际使用过程中通常也都不是系统瓶颈。这就是多路复用在broker端的第一个应用。</p><p>processor线程接收 acceptor线程分配的新 Socket连接通道，然后开始监听该通道上的数据传输。<br>目前 broker 以线程数组而非线程池的方式来实现这组processor，之后使用很简单的数组索引轮询方式依次给每个 processor 线程分配任务，实现了最均匀化的负载均衡。<br>processor 线程实际上也不是处理请求的真正执行者，Kafka 创建了一个KafkaRequestHandler 线程池专门地处理真正的请求。<br>processor 线程一个重要的任务就是将Socket连接上接收到的请求放入请求队列中。<br>每个broker启动时会创建一个全局唯一的请求队列，大小由broker端参数queued.max.requests控制，默认值是500，表示每个broker最多只能保存500个未处理的请求。一旦超过该数字，clients端发送给broker的请求将会被“阻塞”，直到该队列腾出空间。</p><p>KafkaRequestHandler线程池分配具体的线程从该队列中获取请求并执行真正的请求处理逻辑。该线程池的大小也是可以配置的，由broker端参数num.io.threads控制，默认是8个线程。<br>除了请求队列，每个broker还会创建与processor线程数等量的响应队列，即为每个processor线程都创建一个对应的响应队列。processor线程的另一个很重要的任务就是实时处理各自响应队列中的响应结果。</p><p>Kafka在设计上使用了 Java NIO的Selector+Channel+Buffer的思想，在每个processor线程中维护一个Selector实例，并通过这个Selector来管理多个通道上的数据交互，这便是多路复用在processor线程上的应用。</p><h3 id="实现精确一次处理语义"><a href="#实现精确一次处理语义" class="headerlink" title="实现精确一次处理语义"></a>实现精确一次处理语义</h3><p>Apache Kafka的消息交付语义（message delivery semantic）。Kafka是如何达到精确一次处理语义（exactly-once semantics，简称EOS）的？</p><h4 id="消息交付语义"><a href="#消息交付语义" class="headerlink" title="消息交付语义"></a>消息交付语义</h4><p>clients端常见的 3种消息交付语义。它们分别如下。</p><ul><li>最多一次（at most once）：消息可能丢失也可能被处理，但最多只会被处理一次。</li><li>至少一次（at least once）：消息不会丢失，但可能被处理多次。</li><li>精确一次（exactly once）：消息被处理且只会被处理一次。</li></ul><p>对 producer而言，Kafka 引入已提交消息（committed message）的概念。一旦消息被成功地提交到日志文件，只要至少存在一个可用的包含该消息的副本，那么这条消息就永远不会丢失。<br>在0.11.0.0版本之前，Kafka producer默认提供的是at least once语义。可能会因为网络出现故障导致消息写入磁盘的响应没有发送成功从而开启重试操作，导致消息被写入日志两次。<br>Kafka 0.11.0.0版本推出了幂等性 producer和对事务的支持，从而完美地解决了这种消息重复发送的问题。</p><p>对 consumer 端而言，相同日志下所有的副本都应该有相同的内容以及相同的当前位移值。consumer通过consumer位移自行控制和标记日志读取的进度。<br>如果 consumer程序崩溃，那么替代它的新程序实例就必须要接管这个 consumer 位移，即从崩溃时读取位置继续开始消费。若要判断consumer到底支持什么交付语义，位移提交的时机就显得至关重要。</p><p>一种方式是 consumer 首先获取若干消息，然后提交位移，之后再开始处理消息。<br>这种方法下若consumer在提交位移后处理消息前崩溃，那么它实现的就是at most once语义，因为消息有可能不被处理，就算处理了最多也只会是一次。</p><p>另一种方式是 consumer 获取了若干消息，处理到最后提交位移。<br>显然，consumer 保证只有在消息被处理完成后才提交位移，因此它实现的就是 at least once 语义，因为消息处理过程中如果出现错误从而引发重试，那么某些消息就可能被处理多次。</p><p>那么如何实现 consumer端的 EOS呢？主要是依赖0.11.0.0版本引入的事务。</p><h4 id="幂等性producer（idempotent-producer）"><a href="#幂等性producer（idempotent-producer）" class="headerlink" title="幂等性producer（idempotent producer）"></a>幂等性producer（idempotent producer）</h4><p>幂等性producer是Apache Kafka 0.11.0.0版本用于实现EOS的第一个利器。<br><strong>若一个操作执行多次的结果与只运行一次的结果是相同的，那么我们称该操作为幂等操作。</strong></p><p>启用幂等性 producer 以及获取其提供的 EOS 语义，需要显式地设置producer端的新参数 enable.idempotence 为true。</p><p>幂等性 producer的设计思路类似于 TCP的工作方式。发送到 broker端的每批消息都会被赋予一个序列号（sequence number）用于消息去重。<br>但是和 TCP 不同的是，这个序列号不会被丢弃，相反 Kafka会把它们保存在底层日志中，这样即使分区的 leader副本挂掉，新选出来的 leader broker也能执行消息去重工作。<br>保存序列号只需要额外几字节，因此整体上对 Kafka消息保存开销的影响并不大。</p><p>除了序列号，Kafka还会为每个producer实例分配一个producer id（下称PID）。producer在初始化时必须分配一个 PID。PID 分配的过程对用户来说是完全透明的，因此不会为用户所见。<br>消息要被发送到的每个分区都有对应的序列号值，它们总是从0开始并且严格单调增加。对于 PID、分区和序列号的关系，用户可以设想一个 Map,key 就是（PID，分区号）,value就是序列号。即每对（PID，分区号）都有对应的序列号值。<br>若发送消息的序列号小于或等于broker端保存的序列号，那么broker会拒绝这条消息的写入操作。</p><p>这种设计确保了即使出现重试操作，每条消息也只会被保存在日志中一次。<br>不过，由于每个新的 producer实例都会被分配不同的 PID，当前设计只能保证单个 producer实例的 EOS语义，而无法实现多个producer实例一起提供EOS语义。</p><h4 id="事务（transaction）"><a href="#事务（transaction）" class="headerlink" title="事务（transaction）"></a>事务（transaction）</h4><p>对事务的支持是 Kafka 实现 EOS 的第二个利器。引入事务使得 clients 端程序（无论是producer还是consumer）能够将一组消息放入一个原子性单元中统一处理。</p><p>处于事务中的这组消息能够从多个分区中消费，也可以发送到多个分区中去。<br>重要的是不论是发送还是消费，Kafka 都能保证它们是原子性的，即所有的写入操作要么全部成功，要么全部失败。<br>当然对于consumer而言，EOS语义的支持要弱一些，这是由consumer本身的特性决定的。也就是说，consumer 有可能以原子性的方式消费这批消息，也有可能是非原子性的。<br>设想consumer总是需要 replay某些消息，如果是这样的使用场景，那么对于 EOS的支持就要弱很多。</p><p>Kafka为实现事务要求应用程序必须提供一个唯一的 id来表征事务。这个 id被称为事务 id，或 TransactionalId，它必须在应用程序所有的会话上是唯一的。<br>值得注意的是，TransactionalId与上面所说的PID是不同的，前者是由用户显式提供的，而后者是 producer 自行分配的。</p><p>当提供了TransactionalId后，Kafka就能确保：</p><ul><li>跨应用程序会话间的幂等发送语义。具体的做法与新版本 consumer的 generation概念类似，使用具有版本含义的generation来隔离旧事务的操作。</li><li>支持跨会话间的事务恢复。如果某个 producer 实例挂掉了，Kafka 能够保证下一个实例首先完成之前未完成的事务，从而总是保证状态的一致性。</li></ul><p>如果以consumer的角度而言，如前所述，事务的支持要弱一些，原因如下。</p><ul><li>对于compacted的topic而言，事务中的消息可能已经被删除了。</li><li>事务可能跨多个日志段（log segment），因此若老的日志段被删除，用户将丢失事务中的部分消息。</li><li>consumer程序可能使用 seek方法定位事务中的任意位置，也可能造成部分消息的丢失。</li><li>consumer可能选择不消费事务中的所有消息，即无法保证读取事务的全部消息。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;springboot 开发参考 &lt;a class=&quot;link&quot;   href=&quot;https://docs.spring.io/spring-kafka/reference/quick-tour.html&quot; &gt;Spring for Apache Kafka&#92;Introduct</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://cooooing.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="《apache Kafka实战》" scheme="https://cooooing.github.io/tags/%E3%80%8Aapache-Kafka%E5%AE%9E%E6%88%98%E3%80%8B/"/>
    
    <category term="kafka" scheme="https://cooooing.github.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>《apache Kafka实战》读书笔记-基本概念</title>
    <link href="https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8Aapache%20Kafka%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8Aapache%20Kafka%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2025-03-08T09:37:55.000Z</published>
    <updated>2025-03-08T09:37:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章-认识-Apache-Kafka"><a href="#第一章-认识-Apache-Kafka" class="headerlink" title="第一章 - 认识 Apache Kafka"></a>第一章 - 认识 Apache Kafka</h2><p>Kafka 的核心功能是什么？一言以蔽之，<strong>高性能的消息发送与高性能的消息消费</strong>。</p><h3 id="消息引擎系统（Messaging-system）"><a href="#消息引擎系统（Messaging-system）" class="headerlink" title="消息引擎系统（Messaging system）"></a>消息引擎系统（Messaging system）</h3><p>用于在不同应用间传输消息的系统，消息引擎系统中的消息自然是最关键的因素之一。<br>其实，这里的消息可以是任何形式的数据，比如电子邮件、传真、即时消息，甚至是其他服务等，总之都是对企业有价值的数据。<br>在设计一个消息引擎系统时需要考虑的两个重要因素：</p><ul><li>消息设计。</li><li>传输协议设计。</li></ul><h4 id="消息设计"><a href="#消息设计" class="headerlink" title="消息设计"></a>消息设计</h4><p><strong>消息引擎系统在设计消息时一定要考虑语义的清晰和格式上的通用性。</strong><br>一条消息要有能够完整清晰表达业务的能力，它不能是含糊不清、语义不明甚至无法处理的。同时，为了更好地表达语义以及最大限度地提高重用性，消息通常都采用结构化的方式进行设计。<br>比如SOAP协议中的消息就采用了XML格式，而Web Service也支持JSON格式的消息。Kafka的消息是用二进制方式来保存的，但依然是结构化的消息。</p><h4 id="传输协议设计"><a href="#传输协议设计" class="headerlink" title="传输协议设计"></a>传输协议设计</h4><p><strong>消息传输协议指定了消息在不同系统之间传输的方式。</strong><br>这类协议可能包括任何能够在不同系统间传输消息或是执行语义操作的协议或框架。<br>比如现在主流的 RPC 及序列化框架，包括Google的Protocol Buffers、阿里系的Dubbo等。<br>Kafka自己设计了一套二进制的消息传输协议。</p><h4 id="消息引擎范型"><a href="#消息引擎范型" class="headerlink" title="消息引擎范型"></a>消息引擎范型</h4><p>一个消息引擎范型是一个基于网络的架构范型，描述了消息引擎系统的两个不同的子部分是如何互连且交互的。<br>如果把消息引擎系统的这两个子系统比喻成两座城市，那么之前谈到的传输协议就是需要铺设的沥青公路，而引擎范型决定了来往穿梭于这两座城市的路线。</p><p>最常见的两种消息引擎范型是消息队列模型和发布&#x2F;订阅模型。</p><p>消息队列(message queue)模型是基于队列提供消息传输服务的，多用于进程间通信（inter-process communication,IPC)以及线程间通信。<br>该模型定义了消息队列(queue)、发送者(sender)和接收者(receiver)，提供了一种点对点(point-to-point,p2p)的消息传递方式，即发送者发送每条消息到队列的指定位置，接收者从指定位置获取消息。一旦消息被消费(consumed)，就会从队列中移除该消息。<br><strong>每条消息由一个发送者生产出来，且只被一个消费者(consumer)处理——发送者和消费者之间是一对一的关系。</strong><br>生活中接线生的工作就是一个典型的基于队列的消息引擎模型。每个打进来的电话都进入一个排队队列，然后只由一个接线生进行处理。同一个客户不会被第二个接线生处理。</p><p>另一种模型就是发布&#x2F;订阅模型（publish&#x2F;subscribe，或简称为 pub&#x2F;sub），与前一种模型不同，它有主题（topic）的概念：一个 topic 可以理解为逻辑语义相近的消息的容器。<br>这种模型也定义了类似于生产者&#x2F;消费者这样的角色，即发布者（publisher）和订阅者（subscriber）。<strong>发布者将消息生产出来发送到指定的 topic 中，所有订阅了该 topic 的订阅者都可以接收到该topic下的所有消息。</strong><br>通常具有相同订阅 topic的所有订阅者将接收到同样的消息。生活中报纸的订阅就是一种典型的发布&#x2F;订阅模型：很多读者都会订阅同一个报社（类比于同一个 topic）出版的报纸，这样每当报纸更新（生产新的消息）时，这些读者都可以收到最新的报纸（接收最新的消息）。</p><p>Kafka引入了消息组（consumer group）的概念来同时支持这两种模型。</p><h3 id="Kafka-概要设计"><a href="#Kafka-概要设计" class="headerlink" title="Kafka 概要设计"></a>Kafka 概要设计</h3><p>Kafka的设计初衷就是为了解决互联网公司超大量级数据的实时传输。为了实现这个目标，Kafka在设计之初就需要考虑以下4个方面的问题。</p><ul><li>吞吐量&#x2F;延时。</li><li>消息持久化。</li><li>负载均衡和故障转移。</li><li>伸缩性。</li></ul><h4 id="吞吐量-延时"><a href="#吞吐量-延时" class="headerlink" title="吞吐量&#x2F;延时"></a>吞吐量&#x2F;延时</h4><p>通常来说，吞吐量是某种处理能力的最大值。而对于 Kafka而言，<strong>它的吞吐量就是每秒能够处理的消息数或者每秒能够处理的字节数</strong>。很显然，我们自然希望消息引擎的吞吐量越大越好。<br>消息引擎系统还有一个名为延时的性能指标。它衡量的是一段时间间隔，可能是发出某个操作与接收到操作响应（response）之间的时间，或者是在系统中导致某些物理变更的起始时刻与变更正式生效时刻之间的间隔。<br>对于 Kafka而言， <strong>延时可以表示客户端发起请求与服务器处理请求并发送响应给客户端之间的这一段时间</strong>。显而易见，延时间隔越短越好。</p><p>在实际使用场景中，这两个指标通常是一对矛盾体，即调优其中一个指标通常会使另一个指标变差。<br>Kafka而言它是如何做到高吞吐量、低延时的呢？首先，Kafka 的写入操作是很快的，这主要得益于它对磁盘的使用方法的不同。<br>虽然Kafka 会持久化所有数据到磁盘，但本质上每次写入操作其实都只是把数据写入到操作系统的页缓存（page cache）中，然后由操作系统自行决定什么时候把页缓存中的数据写回磁盘上。这样的设计有3个主要优势。</p><ul><li>操作系统页缓存是在内存中分配的，所以消息写入的速度非常快。</li><li>Kafka不必直接与底层的文件系统打交道。所有烦琐的I&#x2F;O操作都交由操作系统来处理。</li><li>Kafka写入操作采用追加写入（append）的方式，避免了磁盘随机写操作。（虽然通常认为物理磁盘读写操作是很慢的，但是磁盘的顺序读写速度还是非常快的）</li></ul><p>Kafka 在设计时采用了追加写入消息的方式，即只能在日志文件末尾追加写入新的消息，且不允许修改已写入的消息，因此它属于典型的磁盘顺序访问型操作，所以Kafka 消息发送的吞吐量是很高的。<br>在实际使用过程中可以很轻松地做到每秒写入几万甚至几十万条消息。</p><p>Kafka是把消息写入操作系统的页缓存中的。那么同样地，Kafka 在读取消息时会首先尝试从 OS的页缓存中读取，如果命中便把消息经页缓存直接发送到网络的 Socket上。<br>这个过程就是利用 Linux 平台的 sendfile 系统调用做到的，而这种技术就是大名鼎鼎的<strong>零拷贝（Zero Copy）技术</strong>。</p><p>关于 sendfile 与零拷贝<br>传统的Linux操作系统中的I&#x2F;O接口是依托于数据拷贝来实现的，但在零拷贝技术出现之前，一个I&#x2F;O操作会将同一份数据进行多次拷贝。<br>数据传输过程中还涉及内核态与用户态的上下文切换，CPU 的开销非常大，因此极大地限制了 OS 高效进行数据传输的能力。<br>零拷贝技术很好地改善了这个问题：首先在内核驱动程序处理 I&#x2F;O 数据的时候，它不再需要进行上下文的切换，节省了内核缓冲区与用户态应用程序缓冲区之间的数据拷贝，同时它利用直接存储器访问技术（Direct Memory Access,DMA）执行I&#x2F;O操作，因此也避免了OS内核缓冲区之间的数据拷贝，故而得名零拷贝。</p><ul><li><p>传统方式（没有零拷贝）：</p><ul><li><strong>步骤 1</strong>：内核调用 <code>read()</code> 从磁盘读取数据到 <strong>内核缓冲区</strong>（Page Cache）。</li><li><strong>步骤 2</strong>：再调用 <code>write()</code> 将数据从 <strong>内核缓冲区</strong> 拷贝到 <strong>用户缓冲区</strong>（User Buffer）。</li><li><strong>步骤 3</strong>：用户态再调用 <code>send()</code>，将数据拷贝回 <strong>内核缓冲区</strong>（Socket Buffer）。</li><li><strong>步骤 4</strong>：内核将数据写入 <strong>网卡缓冲区</strong>，最终发送给消费者。</li></ul></li><li><p>Kafka 采用 <code>sendfile()</code>（零拷贝）：</p><ul><li><strong>步骤 1</strong>：内核直接将数据从 <strong>磁盘 Page Cache</strong> 复制到 <strong>Socket Buffer</strong>，绕过用户态，不经过用户缓冲区。</li><li><strong>步骤 2</strong>：数据从 <strong>Socket Buffer</strong> 直接发送到网卡，传输给 Consumer。</li></ul></li></ul><p>除了零拷贝技术，Kafka 由于大量使用页缓存，故读取消息时大部分消息很有可能依然保存在页缓存中，因此可以直接命中缓存，不用“穿透”到底层的物理磁盘上获取消息，从而极大地提升了消息读取的吞吐量。<br>事实上，如果我们监控一个经过良好调优的 Kafka生产集群便可以发现，即使是那些有负载的 Kafka服务器，其磁盘的读操作也很少，这是因为大部分的消息读取操作会直接命中页缓存。</p><h4 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h4><p>Kafka是要持久化消息的，而且要把消息持久化到磁盘上。这样做的好处如下。</p><ul><li>解耦消息发送与消息消费 ：本质上来说，Kafka 最核心的功能就是提供了生产者-消费者模式的完整解决方案。通过将消息持久化使得生产者方不再需要直接和消费者方耦合，它只是简单地把消息生产出来并交由 Kafka 服务器保存即可，因此提升了整体的吞吐量。</li><li>实现灵活的消息处理 ：很多 Kafka 的下游子系统（接收 Kafka 消息的系统）都有这样的需求——对于已经处理过的消息可能在未来的某个时间点重新处理一次，即所谓的消息重演（message replay）。消息持久化便可以很方便地实现这样的需求。</li></ul><p>另外，Kafka 实现持久化的设计也有新颖之处。<br>普通的系统在实现持久化时可能会先尽量使用内存，当内存资源耗尽时，再一次性地把数据“刷盘”；<br>而 Kafka 则反其道而行之，所有数据都会立即被写入文件系统的持久化日志中，之后Kafka服务器才会返回结果给客户端通知它们消息已被成功写入。<br>这样做既实时保存了数据，又减少了 Kafka程序对于内存的消耗，从而将节省出的内存留给页缓存使用，更进一步地提升了整体性能。</p><h4 id="负载均衡和故障转移"><a href="#负载均衡和故障转移" class="headerlink" title="负载均衡和故障转移"></a>负载均衡和故障转移</h4><p>作为一个功能完备的分布式系统，Kafka 如果只提供了最基本的消息引擎功能肯定不足以帮助它脱颖而出。一套完整的消息引擎解决方案中必然要提供负载均衡（load balancing）和故障转移（fail-over）功能。</p><p><strong>负载均衡就是让系统的负载根据一定的规则均衡地分配在所有参与工作的服务器上，从而最大限度地提升系统整体的运行效率。</strong><br>具体到Kafka来说，默认情况下 Kafka的每台服务器都有均等的机会为 Kafka 的客户提供服务，可以把负载分散到所有集群中的机器上，避免出现“耗尽某台服务器”的情况发生。<br>Kafka 实现负载均衡实际上是通过智能化的分区领导者选举（partition leader election）来实现的。</p><p><strong>故障转移是指当服务器意外中止时，整个集群可以快速地检测到该失效（failure），并立即将该服务器上的应用或服务自动转移到其他服务器上。</strong><br>故障转移通常是以“心跳”或“会话”的机制来实现的，即只要主服务器与备份服务器之间的心跳无法维持或主服务器注册到服务中心的会话超时过期了，那么就认为主服务器已无法正常运行，集群会自动启动某个备份服务器来替代主服务器的工作。<br>Kafka 服务器支持故障转移的方式就是使用会话机制。每台 Kafka 服务器启动后会以会话的形式把自己注册到ZooKeeper 服务器上。一旦该服务器运转出现问题，与ZooKeeper 的会话便不能维持从而超时失效，此时 Kafka 集群会选举出另一台服务器来完全代替这台服务器继续提供服务。</p><h4 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h4><p>伸缩性，英文名是 scalability。根据 Java 大神 Brian Goetz 在其经典著作 Java Concurrency in Practice 中的定义，<strong>伸缩性表示向分布式系统中增加额外的计算资源（比如CPU、内存、存储或带宽）时吞吐量提升的能力</strong>。<br>举一个例子来说，对于计算密集型（computation-intensive）的业务而言，CPU的消耗一定是最大的，这类系统上的操作我们称之为 CPU-bound。<br>那么如果一个 CPU 的运算能力是 U，我们自然希望两个 CPU 的运算能力是2U，即可以线性地扩容计算能力，这种线性伸缩性是最理想的状态，但在实际中几乎不可能达到，毕竟分布式系统中有很多隐藏的“单点”瓶颈制约了这种线性的计算能力扩容。</p><p>阻碍线性扩容的一个很常见的因素就是状态的保存。<br>我们知道，不论是哪类分布式系统，集群中的每台服务器一定会维护很多内部状态。如果由服务器自己来保存这些状态信息，则必须要处理一致性的问题。<br>相反，如果服务器是无状态的，状态的保存和管理交于专门的协调服务来做（比如 ZooKeeper），那么整个集群的服务器之间就无须繁重的状态共享，这极大地降低了维护复杂度。<br>倘若要扩容集群节点，只需简单地启动新的节点机器进行自动负载均衡就可以了。</p><p>Kafka服务器上的状态统一交由 ZooKeeper保管。但也并不是所有状态都不保存，它只保存了很轻量级的内部状态，因此在整个集群间维护状态一致性的代价是很低的。</p><h3 id="Kafka-基本概念和术语"><a href="#Kafka-基本概念和术语" class="headerlink" title="Kafka 基本概念和术语"></a>Kafka 基本概念和术语</h3><p>Kafka 自推出伊始的确是以消息引擎的身份出现的，其强大的消息传输效率和完备的分布式解决方案，使它很快成为业界翘楚。<br>随着 Kafka 的不断演进，Kafka 开发团队日益发现经Kafka交由下游数据处理平台做的事情Kafka自己也可以做，因此在Kafka 0.10.0.0版本正式推出了Kafka Streams，即流式处理组件。<br>自此Kafka正式成为了一个流式处理框架，而不仅仅是消息引擎了。</p><p>不管是消息引擎还是流式处理平台，它的处理流程并没有发生变化，核心架构也总是类似的，无非是生产一些消息然后再消费一些消息。如果总结起来那就是三句话：</p><ul><li>生产者发送消息给Kafka服务器。</li><li>消费者从Kafka服务器读取消息。</li><li>Kafka服务器依托ZooKeeper集群进行服务的协调管理。</li></ul><p>另外，Kafka 服务器有一个官方名字：broker。</p><h4 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h4><p>Kafka 中的消息格式由很多字段组成，其中的很多字段都是用于管理消息的元数据字段，对用户来说是完全透明的。<br>Kafka 消息格式共经历过3次变迁，它们被分别称为 V0、V1和 V2版本。目前大部分用户使用的应该还是 V1版本的消息格式。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AApache%20Kafka%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/V1%E7%89%88%E6%9C%AC%E7%9A%84%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F.png"                        alt="V1版本的消息格式.png"                 ></p><p>消息由消息头部、key和value组成。消息头部包括消息的CRC码、消息版本号、属性、时间戳、键长度和消息体长度等信息。</p><ul><li>Key：消息键，对消息做partition时使用，即决定消息被保存在某topic下的哪个partition。</li><li>Value：消息体，保存实际的消息数据。</li><li>Timestamp：消息发送时间戳，用于流式处理及其他依赖时间的处理语义。如果不指定则取当前时间。</li></ul><p>另外，消息的属性字段，Kafka 为该字段分配了1字节。目前只使用了最低的3位用于保存消息的压缩类型，1位保存时间戳类型，高4位尚未使用。</p><ul><li><strong>Bit 0-2（3 bits）</strong>：压缩类型（Compression Type）</li><li><strong>Bit 3（1 bit）</strong>：时间戳类型（Timestamp Type）</li><li><strong>Bit 4-7（4 bits）</strong>：未使用（保留为 <code>0</code>）</li></ul><table><thead><tr><th><code>Attributes</code> 值</th><th>二进制表示</th><th>时间戳类型</th><th>压缩类型</th></tr></thead><tbody><tr><td><code>0x00</code> (0)</td><td><code>0000 0000</code></td><td>CreateTime</td><td>无压缩</td></tr><tr><td><code>0x01</code> (1)</td><td><code>0000 0001</code></td><td>CreateTime</td><td>Gzip</td></tr><tr><td><code>0x02</code> (2)</td><td><code>0000 0010</code></td><td>CreateTime</td><td>Snappy</td></tr><tr><td><code>0x04</code> (4)</td><td><code>0000 0100</code></td><td>CreateTime</td><td>Zstd</td></tr><tr><td><code>0x08</code> (8)</td><td><code>0000 1000</code></td><td>LogAppendTime</td><td>无压缩</td></tr><tr><td><code>0x0A</code> (10)</td><td><code>0000 1010</code></td><td>LogAppendTime</td><td>Snappy</td></tr></tbody></table><ul><li><strong>CreateTime</strong>（默认）：时间戳由 Producer 设置，适用于**事件时间（Event Time）**语义。</li><li><strong>LogAppendTime</strong>：时间戳由 Broker 记录，适用于**写入时间（Processing Time）**语义。</li></ul><p>Kafka 使用紧凑的二进制字节数组来保存上面这些字段，也就是说没有任何多余的比特位浪费。让我想起了之前看的 Redis 内部用的数据结构，也是十分的紧凑，没有多余比特位的浪费。</p><h4 id="topic-和-partition"><a href="#topic-和-partition" class="headerlink" title="topic 和 partition"></a>topic 和 partition</h4><p>topic 是一个逻辑概念，代表了一类消息，也可以认为是消息被发送到的地方。通常我们可以使用topic来区分实际业务，比如业务A使用一个topic，业务B使用另外一个topic。<br>Kafka中的 topic通常都会被多个消费者订阅，因此出于性能的考量，Kafka并不是 topic-message 的两级结构，而是采用了 topic-partition-message的三级结构来分散负载。从本质上说，每个Kafka topic都由若干个partition组成。</p><p>topic是由多个partition组成的，而Kafka的partition是不可修改的有序消息序列，也可以说是有序的消息日志。<br>每个 partition 有自己专属的 partition 号，通常是从0开始的。用户对partition 唯一能做的操作就是在消息序列的尾部追加写入消息。<br>partition 上的每条消息都会被分配一个唯一的序列号——按照Kafka的术语来讲，该序列号被称为位移（offset）。该位移值是从0开始顺序递增的整数。<br>位移信息可以唯一定位到某partition下的一条消息。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AApache%20Kafka%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/topic%E5%92%8Cpartition.png"                        alt="topic和partition.png"                 ></p><p>Kafka 的 partition 实际上并没有太多的业务含义，它的引入就是单纯地为了提升系统的吞吐量，因此在创建 Kafka topic 的时候可以根据集群实际配置设置具体的partition数，实现整体性能的最大化。</p><h4 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h4><p>topic partition 下的每条消息都被分配一个位移值。<br>实际上，Kafka 消费者端也有位移（offset）的概念，但这两个offset属于不同的概念</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AApache%20Kafka%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B6%88%E6%81%AF%E4%BD%8D%E7%A7%BB%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E4%BD%8D%E7%A7%BB.png"                        alt="消息位移与消费者位移.png"                 ></p><p>每条消息在某个 partition的位移是固定的，但消费该 partition的消费者的位移会随着消费进度不断前移，但终究不可能超过该分区最新一条消息的位移。<br><strong>Kafka 中的一条消息其实就是一个&lt;topic,partition,offset&gt;三元组（tuple），通过该元组值我们可以在 Kafka 集群中找到唯一对应的那条消息。</strong></p><h4 id="replica"><a href="#replica" class="headerlink" title="replica"></a>replica</h4><p>分布式系统要实现高可靠性，就要通过冗余机制来保证。partition 的消息不能只保存一份，而是要保存多份，因此每个 partition 都会分配多个副本（replica），每个副本都保存着该 partition 的消息。</p><p>副本分为两类：领导者副本（leader replica）和追随者副本（follower replica）。<br>follower replica 是不能提供服务给客户端的，也就是说不负责响应客户端发来的消息写入和消息消费请求。<br>它只是被动地向领导者副本（leader replica）获取数据，而一旦 leader replica 所在的broker宕机，Kafka会从剩余的 replica中选举出新的 leader继续提供服务。</p><h4 id="leader-和-follower"><a href="#leader-和-follower" class="headerlink" title="leader 和 follower"></a>leader 和 follower</h4><p>Kafka的 replica分为两个角色：领导者（leader）和追随者（follower）。<br>如今这种角色设定几乎完全取代了过去的主备的提法（Master-Slave）。和传统主备系统（比如MySQL）不同的是，<strong>在这类 leader-follower系统中通常只有 leader对外提供服务，follower只是被动地追随 leader 的状态，保持与 leader 的同步。</strong><br><strong>follower 存在的唯一价值就是充当 leader的候补：一旦 leader 挂掉立即就会有一个追随者被选举成为新的 leader 接替它的工作。</strong><br><strong>Kafka保证同一个partition的多个replica一定不会分配在同一台broker上。</strong> 毕竟如果同一个broker上有同一个partition的多个replica，那么将无法实现备份冗余的效果。</p><h4 id="ISR"><a href="#ISR" class="headerlink" title="ISR"></a>ISR</h4><p>ISR的全称是in-sync replica，翻译过来就是与leader replica保持同步的replica集合。</p><p>Kafka为partition动态维护一个replica集合。该集合中的所有replica保存的消息日志都与leader replica保持同步状态。<br><strong>只有这个集合中的 replica才能被选举为 leader，也只有该集合中所有replica都接收到了同一条消息，Kafka才会将该消息置于“已提交”状态，即认为这条消息发送成功。</strong></p><p>正常情况下，partition的所有replica（含leader replica）都应该与leader replica保持同步，即所有 replica都在 ISR中。<br>因为各种各样的原因，一小部分 replica开始落后于 leader replica的进度。当滞后到一定程度时，Kafka会将这些 replica“踢”出 ISR。<br>相反地，当这些 replica重新“追上”了 leader的进度时，那么 Kafka会将它们加回到 ISR中。<br>这一切都是自动维护的，不需要用户进行人工干预。</p><h3 id="Kafka-使用场景"><a href="#Kafka-使用场景" class="headerlink" title="Kafka 使用场景"></a>Kafka 使用场景</h3><ol><li>消息传输<br>Kafka非常适合替代传统的消息总线（message bus）或消息代理（message broker）。Kafka特别适合用于实现一个超大量级消息处理应用。</li><li>网站行为日志追踪<br>Kafka 最早就是用于重建用户行为数据追踪系统的。很多网站上的用户操作都会以消息的形式发送到 Kafka 的某个对应的 topic 上。</li><li>审计数据收集<br>对关键的操作和运维进行监控和审计。需要从各个运维应用程序处实时汇总操作步骤信息进行集中式管理。</li><li>日志收集<br>对于大量分散在不同机器上的服务日志。我们可以使用 Kafka对它们进行全量收集，并集中送往下游的分布式存储中（比如 HDFS 等）。</li><li>Event Sourcing<br>Event Sourcing实际上是领域驱动设计（Domain-Driven Design,DDD）的名词，它使用事件序列来表示状态变更，这种思想和 Kafka 的设计特性不谋而合。Kafka 也是用不可变更的消息序列来抽象化表示业务消息的，因此Kafka特别适合作为这种应用的后端存储。</li><li>流式处理<br>自0.10.0.0版本开始，Kafka社区推出了一个全新的流式处理组件Kafka Streams。</li></ol><h2 id="第二章-Kafka-发展历史"><a href="#第二章-Kafka-发展历史" class="headerlink" title="第二章 - Kafka 发展历史"></a>第二章 - Kafka 发展历史</h2><p>挑选我感兴趣的内容，部分略过。</p><p>Kafka这个名字的由来。应该是Kafka三位原作者之一Jay Kreps的这句话：</p><blockquote><p>I thought that since Kafka was a system optimized for writing using a writer’s name would make sense.<br>I had taken a lot of lit classes in college and liked Franz Kafka.Plus the name sounded cool for an open source project.<br>因为 Kafka 系统的写操作性能特别强，所以找个作家的名字来命名似乎是一个好主意。<br>我在大学时上了很多文学课，非常喜欢Franz Kafka。另外为开源项目起Kafka这个名字听上去很酷。</p></blockquote><p>Kafka三位原作者之一（另外两位分别是Jun Rao和Neha Narkhede）。</p><p>以下是基于搜索结果的Kafka重要版本功能变化汇总表，结合多个来源信息整理而成：</p><table><thead><tr><th>版本</th><th>功能变化</th><th>说明</th></tr></thead><tbody><tr><td>0.8.x</td><td>副本机制</td><td>引入多副本机制（Replication），提升数据可靠性</td></tr><tr><td></td><td>新Producer API</td><td>异步发送消息，提升客户端效率，但初期存在稳定性问题</td></tr><tr><td></td><td>Offset存储优化</td><td>将消费者位移从ZooKeeper迁移至<code>__consumer_offsets</code>主题，减少ZooKeeper压力</td></tr><tr><td>0.9.x</td><td>安全认证</td><td>支持SSL&#x2F;SASL认证、授权管理及数据加密，增强外网传输安全性</td></tr><tr><td></td><td>Kafka Connect</td><td>引入高性能数据集成框架，支持与外部系统（如数据库、HDFS）对接</td></tr><tr><td></td><td>新Consumer API</td><td>消费者自主管理Offset，支持多线程消费和细粒度控制，取代旧版High-level Consumer</td></tr><tr><td>0.10.x</td><td>Kafka Streams</td><td>正式成为流处理平台，支持基于时间戳的流计算，但初期功能尚不完善</td></tr><tr><td></td><td>消息时间戳</td><td>消息体中增加时间戳字段，支持基于时间的窗口操作和回溯查询</td></tr><tr><td>0.11.x</td><td>Exactly-Once语义</td><td>支持生产者幂等性和事务功能，确保消息不重复处理（需配合Kafka Streams）</td></tr><tr><td></td><td>消息格式重构</td><td>优化消息头结构，支持Header字段存储元数据，提升批量消息压缩效率</td></tr><tr><td>1.0.x</td><td>磁盘故障转移</td><td>Broker单块磁盘损坏时，数据自动迁移至其他磁盘，提升可用性</td></tr><tr><td></td><td>跨磁盘副本迁移</td><td>分区副本可在同一Broker的不同磁盘目录间迁移，优化磁盘负载均衡</td></tr><tr><td>2.0.x</td><td>安全增强</td><td>支持前缀通配符ACL和OAuth2令牌认证，默认启用SSL主机名验证</td></tr><tr><td></td><td>消费者组管理优化</td><td>默认Offset保留时间从1天延长至7天，减少消费者组重建时的数据丢失风险</td></tr><tr><td>2.8.x</td><td>KRaft模式</td><td>引入Raft共识协议替代ZooKeeper管理元数据，简化架构（早期版本不建议生产使用）</td></tr><tr><td>3.0.x</td><td>移除ZooKeeper依赖</td><td>KRaft模式正式支持，元数据完全由Kafka自身管理，提升云原生兼容性</td></tr><tr><td></td><td>默认交付保证增强</td><td>生产者默认启用<code>acks=all</code>和幂等性（<code>enable.idempotence=true</code>），确保消息持久化与顺序性</td></tr></tbody></table><ol><li><strong>版本演进趋势</strong>：从消息队列逐步发展为流处理平台，核心改进集中在<strong>可靠性</strong>（副本、事务）、<strong>性能</strong>（异步发送、压缩优化）、<strong>云原生</strong>（KRaft、存储分离）和<strong>安全性</strong>（SSL、ACL）。</li><li><strong>兼容性注意</strong>：<ul><li>0.11.x后消息格式变更需客户端同步升级；</li><li>3.0.x起弃用Java 8和Scala 2.12，计划在4.0移除。</li></ul></li></ol><h2 id="第三章-Kafka-线上环境部署"><a href="#第三章-Kafka-线上环境部署" class="headerlink" title="第三章 - Kafka 线上环境部署"></a>第三章 - Kafka 线上环境部署</h2><h3 id="集群环境规划"><a href="#集群环境规划" class="headerlink" title="集群环境规划"></a>集群环境规划</h3><p>操作系统优先选择Linux，这里考虑的主要是系统的IO模型、Kafka底层网络库的设计和网络传输效率。</p><p>IO模型主流的有五种：阻塞 I&#x2F;O、非阻塞 I&#x2F;O、I&#x2F;O多路复用、信号驱动 I&#x2F;O和异步 I&#x2F;O。<br>linux epoll取消了轮询机制，取而代之的是回调机制（callback）。这样当底层连接 Socket 数较多时，可以避免很多无意义的 CPU 时间浪费。<br>windows IOCP是异步 I&#x2F;O的实现。</p><p>Kafka新版本clients在设计底层网络库时采用了Java的Selector机制。<br>Java的Selector 在 Linux上的实现机制就是 epoll；<br>但是在 Windows平台上，Java NIO的 Selector底层是使用 select模型，在 Java NIO2才是使用 IOCP 实现的。</p><p>网络与磁盘的数据传输 Kafka 通过 Java 的FileChannel.transferTo方法实现。<br>在Linux平台上该方法底层会调用sendfile系统调用，即采用了Linux提供的零拷贝（Zero Copy）技术。<br>对于Windows平台，虽然它也提供了TransmitFile函数来支持零拷贝技术，但是直到Java 8u60版本Windows平台才正式让FileChannel的transferTo方法调用该函数。</p><h4 id="磁盘规划"><a href="#磁盘规划" class="headerlink" title="磁盘规划"></a>磁盘规划</h4><p>机械硬盘（HDD）和固态硬盘（SSD）对于Kafka没有太大的区别。（当然，SSD会有更好性能，HDD会有更好的性价比）<br>因为Kafka主要是顺序写磁盘，SSD顺序IO不需要频繁移动磁头。</p><p>JBOD（Just Bunch Of Disks 普通磁盘集合） 与磁盘阵列（RAID）。普通磁盘性价比更高。<br>RAID会以容量为代价换来数据的冗余和负载均衡。但是Kafka集群本身可以设置副本数，是自带数据冗余的。<br>使用RAID会增加额外不需要的数据冗余，会是一笔很大的成本开销。</p><p>但JBOD方案也会有缺陷：</p><ol><li>任意磁盘损坏都会导致 broker 宕机——普通磁盘损坏的概率是很大的，因此这个缺陷从某种程度上来说是致命的。</li><li>JBOD 的管理需要更加细粒度化。</li><li>JBOD 需要提供类似于负载均衡的功能。</li></ol><h4 id="磁盘容量规划"><a href="#磁盘容量规划" class="headerlink" title="磁盘容量规划"></a>磁盘容量规划</h4><p>Kafka的每条消息都保存在实际的物理磁盘中，这些消息默认会被broker保存一段时间之后清除。<br>这段时间是可以配置的，因此用户可以根据自身实际业务场景和存储需求来大致计算线上环境所需的磁盘容量。</p><p>对于磁盘容量的规划和以下多个因素有关：</p><ul><li>新增消息数。</li><li>消息留存时间。</li><li>平均消息大小。</li><li>副本数。</li><li>是否启用压缩。</li></ul><h4 id="内存规划"><a href="#内存规划" class="headerlink" title="内存规划"></a>内存规划</h4><p>Kafka 虽然会持久化每条消息，但其实这个工作都是底层的文件系统来完成的，Kafka 仅仅将消息写入page cache而已，之后将消息“冲刷”到磁盘的任务完全交由操作系统来完成。<br>consumer 在读取消息时也会首先尝试从该区域中查找，如果直接命中则完全不用执行耗时的物理 I&#x2F;O 操作，从而提升了 consumer 的整体性能。</p><p>Kafka对于Java堆内存的使用并不多，因为Kafka的消息很快就会被垃圾回收（GC）。<br>一般情况下，broker 所需的堆内存都不会超过6GB。但消息会占用大量系统的 page cache。</p><p>对于内存规划的建议如下。</p><ul><li>尽量分配更多的内存给操作系统的page cache。</li><li>不要为broker设置过大的堆内存，最好不超过6GB。</li><li>page cache大小至少要大于一个日志段的大小。</li></ul><h4 id="CPU-规划"><a href="#CPU-规划" class="headerlink" title="CPU 规划"></a>CPU 规划</h4><p>Kafka不属于计算密集型（CPU-bound）的系统，属于IO密集型（I&#x2F;O-bound）的系统。<br>所以多核系统是最佳的选择。</p><p>当然，如果启用了消息压缩，那么 broker 也可能需要大量的 CPU 资源。</p><h4 id="带宽规划"><a href="#带宽规划" class="headerlink" title="带宽规划"></a>带宽规划</h4><p>对带宽资源规划的建议如下：</p><ul><li>尽量使用高速网络。</li><li>根据自身网络条件和带宽来评估Kafka集群机器数量。</li><li>避免使用跨机房网络。</li></ul><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>这里使用 Docker 部署，关于集群与相关参数设置这里省略，使用的时候根据<a class="link"   href="https://kafka.apache.org/documentation/" >官方文档<i class="fas fa-external-link-alt"></i></a>设置即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull apache/kafka:3.9.0</span><br><span class="line">docker run -p 9092:9092 apache/kafka:3.9.0</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一章-认识-Apache-Kafka&quot;&gt;&lt;a href=&quot;#第一章-认识-Apache-Kafka&quot; class=&quot;headerlink&quot; title=&quot;第一章 - 认识 Apache Kafka&quot;&gt;&lt;/a&gt;第一章 - 认识 Apache Kafka&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://cooooing.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="《apache Kafka实战》" scheme="https://cooooing.github.io/tags/%E3%80%8Aapache-Kafka%E5%AE%9E%E6%88%98%E3%80%8B/"/>
    
    <category term="kafka" scheme="https://cooooing.github.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>《go语言并发之道》读书笔记-大规模并发</title>
    <link href="https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%B9%B6%E5%8F%91/"/>
    <id>https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%B9%B6%E5%8F%91/</id>
    <published>2025-01-28T14:27:50.000Z</published>
    <updated>2025-01-28T14:27:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天是2025年1月28日，除夕夜晚上十点半。今年家里是十分的冷清，没有什么过年的氛围。<br>不过，可能向来如此吧。</p><p>除夕夜还在看这些，莫名有些伤感。<br>想起一句话：<strong>我们是除夕夜街头，即将放飞理想的有志青年。</strong><br>也许吧，还是看书吧</p><h2 id="第五章-大规模并发"><a href="#第五章-大规模并发" class="headerlink" title="第五章 - 大规模并发"></a>第五章 - 大规模并发</h2><h3 id="异常传递"><a href="#异常传递" class="headerlink" title="异常传递"></a>异常传递</h3><p>编写并发代码，特别是在分布式系统中，你的系统中非常容易出现一些奇怪问题，并且难以理解为什么会发生这种情况。<br>为了将你自己、你的团队、你的用户从众多的痛苦中拯救出来，你需要仔细考虑异常(error)是如何通过分布式系统传递的，以及问题最终将如何呈现给使用者。</p><p>异常处理十分的重要，首先来明确异常是什么，什么时候发生，提供了哪些好处。<br>出现异常表示你的系统进入了一个无法满足用户操作的状态，这个操作可能是显式的，也可能是隐式的。<br>这时系统需要传达几个信息：</p><ol><li>发生了什么<br>这部分异常信息包含了对异常事件的描述。例如：“磁盘已满”，“连接被重置”，“证书过期”。这些信息可能是被一些代码隐式的表达出来的，你可以用一些上下文来修饰这些信息来帮助用户理解发生了什么问题。</li><li>发生在什么时间、什么位置<br>异常应当总是包含完整的栈轨迹信息，从调用的启动方式开始，以异常的实例结尾。栈轨迹信息不应该包含在异常消息中（这一点尤为重要），但当需要处理栈中的异常时应该很容易被找到。<br>更进一步讲，异常应当包含有关其内部运行的上下文信息。例如，在分布式系统中，异常应该有一些字段用来识别发生异常的机器。发生异常后，这些信息会对你诊断系统故障原因非常有价值。<br>此外，异常还应包含对应机器上的时间，并且最好是UTC时间。</li><li>对用户友好的信息<br>应当对展现给用户的异常信息进行自定义，以适应你的系统和用户。这些信息应该只包含前两点的概述以及相关信息。对用户友好的信息是从用户的角度考虑，给出一些信息，说明这些问题是否是暂时的，并且最好是行以内的文本。</li><li>告诉用户如何获得更多的信息<br>在某些情况下，用户希望知道当异常发生时，具体发生了哪些故障。展现给用户的异常信息应当提供一个ID,利用这个ID可以查询到对应的详细日志。<br>这个详细日志应显示异常的完整信息：发生异常的时间（而不是异常记录的时间)，异常创建时完整的堆栈调用。包含一个堆栈轨迹的hash也有助于聚合这些异常，就像bug追踪器那样跟踪问题。</li></ol><p>默认状态下，如果你不介人，异常信息不会包含上述所有的信息。因此，你应当保持这样一种观念，任何展现给用户的异常信息如果没包含这些信息，不是出错了就是有bug。<br>这引出了一个可以用来处理异常的通用模型。所有的异常都几乎都能归为以下两种分类之一：</p><ul><li>Bug</li><li>已知信息（例如：网络连接断开，磁盘写入失败等）。</li></ul><p>Bug是一些你未在你的系统中定义的异常，或者一些“原生”的异常，就是那些极少遇到的情况。<br>有时这是有意为之的，在你系统最初的几次迭代中，一些罕见问题展现给用户是可以接受的。还有些时候这是意外发生的。<br>总之，如果你同意我所提出的方法，即“原生”异常总是bug。在确定如何传播异常时，在系统随着时间的推移如何增长以及最终向用户展示什么时，这种区别被证明是非常有用的。</p><p>当我们面向用户部分的代码收到一个格式良好的异常信息时，我们知道在代码的各个层面上，我们都小心的处理了异常，我们可以将其记录下来并打印出来供用户查看。确保异常类型的准确有效是非常重要的。<br>当不规范的异常或bug传递给用户时，我们也应该记录异常，但是应该向用户显示一条友好的消息，指出发生了意外的事情。如果我们在系统中支持自动的异常报告，则应该将这些问题报告为bug。如果我们不这样做，我们应该建议用户提交一个bug反馈。<br>请注意，不规范的异常实际上也可能包含用的信息，但我们不能保证这一点，我们唯一能确认的是异常没有经过我们格式化。因此我们应该直截了当地展示一段人类可解读的信息，来展示刚刚发生的事情。</p><p>请记住，在这两种情况下，如果出现格式不规范的异常，我们将在消息中包含一个日志ID,以便用户在需要更多信息时可以查询到相关的内容。<br>因此，如果bug确实包含了有用的信息，有需要的用户仍然有可追踪的线索。</p><p>作者给了个简单的包装异常的例子，这里就省略了。<br>我通常处理异常的方式和上面是一样的，分为自定义异常（不符合业务逻辑的异常、可以预料到的系统异常）和意料之外的异常。<br>具体处理方式在不同的场景下区别是比较大的，这块后续会去学习errors包的处理方式。另外还有分布式的异常处理方式。</p><h3 id="超时与取消"><a href="#超时与取消" class="headerlink" title="超时与取消"></a>超时与取消</h3><p>在并发代码运行时，超时（Timeouts）和取消（Cancellation）会频繁出现。<br>超时的处理对于创建一个易于理解的系统是至关重要的，进程被取消是其发生超时时的自然反应。</p><p>那么，为什么希望并发程序支持超时呢？</p><ul><li>系统饱和<br>即系统的处理能力达到上线，希望超出的请求返回超时，而不是花很长时间等待响应。<ul><li>请求在超时时不太可能重复</li><li>没有资源存储请求（内存队列内存，持久队列磁盘）</li><li>如果系统对响应或请求发送数据有时效性要求。</li><li>如果一个请求可能会重复，超时会额外增加一个请求和超时的消耗。</li><li>如果开销超过系统容量，可能会导致系统宕机。</li></ul></li><li>陈旧的数据<br>数据通常有一个窗口期，一般是在这个窗口中必须先处理更多的相关数据，或者处理数据的需求已经过期。<br>如果一个并发进程处理数据需要的时间比这个窗口期更长，我们会想返回超时并取消并发进程。<br>例如，如果我们的并发进程在长时间的等待之后响应请求，则在排队中的请求或其数据可能已经过时。<br>如果事先知道这个窗口时间，那么将context.WithDeadline或context.WithTimeout创建的context.Context传递给我们的并发进程是有意义的。<br>如果事先不知道窗口，我们希望并发进程的父节点能够在请求不再需要时取消并发进程。context.WithCancel是达到这个目的的最佳选择。</li><li>试图防止死锁<br>在大型系统中，尤其是分布式系统中，有时难以理解数据流动的方式，或者可能出现的罕见情况。<br>为了保证系统不会发生死锁，建议在所有并发操作中增加超时处理。超时时间不一定要接近执行并发操作所需的实际时间。<br>不过超时的目的只是为了防止死锁，所以需要它足够短，使死锁的系统在合理的时间内解除阻塞即可。<br>尝试通过设置超时可以将一个死锁系统转变为一个活锁系统。不过，在大型系统中，由于存在更多灵活的组件，在系统死锁后，你的系统更可能会遇到时序配置不同步的情况。<br>因此，最好是在允许的时间内尽可能修复活锁，好过发生死锁后只有通过重新启动才能恢复系统。</li></ul><p>如何建立一个并发处理来优雅地处理取消。并发进程可能被取消的原因有很多：</p><ul><li>超时<br>超时是隐式取消。</li><li>用户干预<br>为了获得良好的用户体验，通常建议维持一个长链接，然后以轮询间隔将状态报告给用户，或允许用户查看他们认为合适的状态。<br>当用户使用并发程序时，有时需要允许用户取消他们已经开始的操作。</li><li>父进程取消<br>对于这个问题，如果任何一种并发操作的父进程停止，那子进程也将被取消。</li><li>复制请求<br>我们可能希望将数据发送到多个并发进程，以尝试从其中一个进程获得更快的响应。当第一个回来的时候，我们就会取消其余的进程。后面讨论</li></ul><p>也可能有有其他原因。</p><p>那么当一个并发进程被取消时，对于正在执行的算法，及其下游消费这意味着什么？在编写可能随时终止的并发代码时，需要考虑哪些事项？</p><p>首先是并发进程的可抢占性。<br>如果一个原子操作执行时间非常地长，那么在确认取消与停止之间需要很长的时间。</p><p>所以需要定义我们的并发进程可抢占的周期，确保运行周期比抢占周期长的功能本身都是可抢占的。<br><strong>一个简单的方法是将你的goroutine代码段分解成小段。就是那些不可抢占的原子操作，确保它们的运行时间小于你认为可以接受的时间。</strong><br>这里还有另外一个潜在的问题：如果我们的goroutine恰好修改了共享状态(例如数据库，文件，内存数据结构)，那当goroutine被取消时会发生什么？你的goroutine会试图将这个中间状态回滚吗？回滚过程需要多长时间？<br>goroutine已经接收到了停止的信号，所以它不应该花太长的时间来回滚它之前的工作，对吧？<br>就如何处理这个问题很难给出通用的建议，因为你的算法的性质很大程度上决定了你应当如何解决这个问题。<br>然而，如果你将对共享状态的修改保特在一个很小的范围内，并且确保这些修改很容易回滚，那么你可以很好的处理取消。<br>如果可能的话，将中间结果存储在内存，然后尽可能快的修改状态。</p><p>另外，还需要关注重复消息的问题。<br>假设有一个管道，它有三个阶段：生成阶段，阶段A和阶段B。<br>生成阶段通过记录上一次channel被读取的时间，来监控阶段A持续的时间。<br>如果当前实例变得不正常，阶段B在处理中时，实例A被取消。新的请求则会产生新的实例A2。但是阶段B会受到重复的消息。<br>有很多种方法可以避免发送重复的消息。<strong>最简单的方法（也是我推荐的方法）是让一个父goroutine在子goroutine已经发送完结果之后发送一个取消信号。这需要各阶段之间的双向通信（心跳）。</strong><br>其他方法是：</p><ol><li>接收到的第一个或最后一个消息，如果你的算法允许，或者你的并发进程是幂等的，那么你可以简单地在下游进程中允许可能存在的重复消息，并从接收到的第一个消息或最后一个消息中挑选一个处理。</li><li>像父goroutine确认权限，使用双向通信明确请求允许在B的channel上执行写人操作，这比心跳更安全。然而，在实践中很少这样做，因为它比心跳更加复杂，而心跳更普遍且有效。</li></ol><h3 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h3><p>心跳是并发进程向外界发出信号的一种方式。这个说法来自人体解剖学，在解剖学中心跳反应了观察者的生命体征。</p><p>在设计并发程序时，一定要考虑到超时和取消。如果从一开始就忽略超时和取消，然后在后期尝试加入它们，这有点像在蛋糕烤好后再加鸡蛋。<br>在并发编程中，有几个的原因使心跳变得格外有趣。它允许我们对系统有深入的了解，当系统工作不正常时，它可以对系统进行测试。<br>下面讨论两种不同类型的心跳：</p><ul><li>在一段时间间隔内发出的心跳。</li><li>在工作单元开始时发出的心跳</li></ul><p>在一段时间间隔上发出的心跳对并发代码很有用，尤其是当它在处于等待状态。因为你不知道新的事件什么时候会被触发，你的goroutine可能会在等待某件事情发生的时候挂起。<br>心跳是告诉监听程序一切安好的一种方式，而静默状态也是预料之中的。<br>下面的代码演示了一个会发出心跳的goroutine:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">doWork := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> any, pulseInterval time.Duration)</span></span> (&lt;-<span class="keyword">chan</span> any, &lt;-<span class="keyword">chan</span> time.Time) &#123;</span><br><span class="line">heartbeat := <span class="built_in">make</span>(<span class="keyword">chan</span> any) <span class="comment">// 建立一个发送心跳的 channel</span></span><br><span class="line">results := <span class="built_in">make</span>(<span class="keyword">chan</span> time.Time)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(heartbeat)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(results)</span><br><span class="line">pulse := time.Tick(pulseInterval)       <span class="comment">// 设置心跳的间隔时间</span></span><br><span class="line">workGen := time.Tick(<span class="number">2</span> * pulseInterval) <span class="comment">// 另一个模拟工作结果的生成间隔</span></span><br><span class="line">sendPulse := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> heartbeat &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">// 添加默认语句，避免阻塞。因为可能没有人接受心跳，从 goroutine 发送信息是重要的，但心跳却不一定重要。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sendResult := <span class="function"><span class="keyword">func</span><span class="params">(r time.Time)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-pulse: <span class="comment">// 和 done channel 一样，当执行发送或接收时，也需要发送一个包含心跳的分支</span></span><br><span class="line">sendPulse()</span><br><span class="line"><span class="keyword">case</span> results &lt;- r:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-pulse: <span class="comment">// 和 done channel 一样，当执行发送或接收时，也需要发送一个包含心跳的分支</span></span><br><span class="line">sendPulse()</span><br><span class="line"><span class="keyword">case</span> r := &lt;-workGen:</span><br><span class="line">sendResult(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> heartbeat, results</span><br><span class="line">&#125;</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line">time.AfterFunc(<span class="number">10</span>*time.Second, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">close</span>(done) &#125;) <span class="comment">// 10秒后关闭 done channel</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeout = <span class="number">2</span> * time.Second               <span class="comment">// 设置超时时间</span></span><br><span class="line">heartbeat, results := doWork(done, timeout/<span class="number">2</span>) <span class="comment">// 心跳间隔为超时时间的一半，以便心跳有额外的响应时间</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> _, ok := &lt;-heartbeat: <span class="comment">// 处理心跳。知道心跳会有消息，如果什么都没收到，便知道是 goroutine 出了问题</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;pulse&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> r, ok := &lt;-results:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;results %v\n&quot;</span>, r.Second())</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(timeout): <span class="comment">// 如果没有收到心跳或其他消息，就会超时</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pulse</span><br><span class="line">pulse</span><br><span class="line">results 18</span><br><span class="line">pulse</span><br><span class="line">pulse</span><br><span class="line">results 20</span><br><span class="line">pulse</span><br><span class="line">pulse</span><br><span class="line">results 22</span><br><span class="line">pulse</span><br><span class="line">pulse</span><br><span class="line">results 24</span><br><span class="line">pulse</span><br><span class="line">results 26</span><br></pre></td></tr></table></figure><p>下面来模拟一个异常的 goroutine 。它将在两次迭代后停止，但不关闭任何一个 channel：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">doWork := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> any, pulseInterval time.Duration)</span></span> (&lt;-<span class="keyword">chan</span> any, &lt;-<span class="keyword">chan</span> time.Time) &#123;</span><br><span class="line">heartbeat := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line">results := <span class="built_in">make</span>(<span class="keyword">chan</span> time.Time)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">pulse := time.Tick(pulseInterval)</span><br><span class="line">workGen := time.Tick(<span class="number">2</span> * pulseInterval)</span><br><span class="line">sendPulse := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> heartbeat &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sendResult := <span class="function"><span class="keyword">func</span><span class="params">(r time.Time)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-pulse:</span><br><span class="line">sendPulse()</span><br><span class="line"><span class="keyword">case</span> results &lt;- r:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-pulse:</span><br><span class="line">sendPulse()</span><br><span class="line"><span class="keyword">case</span> r := &lt;-workGen:</span><br><span class="line">sendResult(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> heartbeat, results</span><br><span class="line">&#125;</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line">time.AfterFunc(<span class="number">10</span>*time.Second, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">close</span>(done) &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeout = <span class="number">2</span> * time.Second</span><br><span class="line">heartbeat, results := doWork(done, timeout/<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> _, ok := &lt;-heartbeat:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;pulse&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> r, ok := &lt;-results:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;results %v\n&quot;</span>, r.Second())</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(timeout):</span><br><span class="line">fmt.Println(<span class="string">&quot;worker goroutine is not healthy!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pulse</span><br><span class="line">pulse</span><br><span class="line">worker goroutine is not healthy!</span><br></pre></td></tr></table></figure><p>心跳和超时在正常工作，通过心跳可以确定 goroutine 是否在正常运行，从而避免死锁。</p><h3 id="复制请求"><a href="#复制请求" class="headerlink" title="复制请求"></a>复制请求</h3><p>对于某些应用来说，尽可能快地接收响应是重中之重。例如，程序正在处理用户的HTTP请求，或者检索一个数据块。<br>在这些情况下，你可以进行权衡：你可以将请求分发到多个处理程序（无论是goroutine,进程，还是服务器），其中一个将比其他处理程序返回更快，你可以立即返回结果。<br>缺点是为了维特多个实例的运行，你将不得不消耗更多的资源。</p><p>如果这种复制是在内存中进行的，消耗则没有那么大，但是如果多个处理程序要多个进程，服务器甚至是数据中心，那可能会变得相当昂贵。<br>所以你需要决定这么做是否值得。</p><p>来看看如何在单个进程中制造复制请求。使用多个goroutine作为处理程序，并且goroutine将随机休眠一段时间以模似不同的负载，休眠时间在1到6秒之间。<br>这将使我们处理程序在不同的时间返回结果，并且我们可以看到复制请求如何更快的返回结果。<br>下面是一个在10个处理程序上复制模拟请求的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">dowork := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> any, id <span class="type">int</span>, wg *sync.WaitGroup, result <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">started := time.Now()</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="comment">// 模拟随机负找</span></span><br><span class="line">simulatedLoadTime := time.Duration(<span class="number">1</span>+rand.Intn(<span class="number">5</span>)) * time.Second</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(simulatedLoadTime):</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">case</span> result &lt;- id:</span><br><span class="line">&#125;</span><br><span class="line">took := time.Since(started)</span><br><span class="line"><span class="comment">// 显示处理程序需要多长时间</span></span><br><span class="line"><span class="keyword">if</span> took &lt; simulatedLoadTime &#123;</span><br><span class="line">took = simulatedLoadTime</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v took %v\n&quot;</span>, id, took)</span><br><span class="line">&#125;</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line">result := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123; <span class="comment">// 启动 10 个处理程序</span></span><br><span class="line"><span class="keyword">go</span> dowork(done, i, &amp;wg, result)</span><br><span class="line">&#125;</span><br><span class="line">firstReturned := &lt;-result <span class="comment">// 获取处理程序组的第一个结果</span></span><br><span class="line"><span class="built_in">close</span>(done)               <span class="comment">// 取消其余处理程序</span></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Printf(<span class="string">&quot;Received an answer from %v\n&quot;</span>, firstReturned)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">6 took 1.0010419s</span><br><span class="line">9 took 2s</span><br><span class="line">0 took 3s</span><br><span class="line">8 took 2s</span><br><span class="line">7 took 2s</span><br><span class="line">4 took 4s</span><br><span class="line">3 took 4s</span><br><span class="line">5 took 1.0010419s</span><br><span class="line">1 took 2s</span><br><span class="line">2 took 2s</span><br><span class="line">Received an answer from 6</span><br></pre></td></tr></table></figure><p>这里第六个处理程序返回的最快。<br>注意，所有的处理程序都应该是尽可能的等价的，有相同的机会处理请求。<br>但需要复制请求的场景很少，因为建立和维护这样的系统有非常大的代价。除非对响应速度的要求可以接受这样的代价。<br>另外，这种方式天然地提供了容错和可扩展性。（分布式处理，不过只取第一个响应的，而取消其他。比较浪费</p><h3 id="速率限制"><a href="#速率限制" class="headerlink" title="速率限制"></a>速率限制</h3><p>限制某种资源在某段时间内被访问的次数。资源可以是任何东西：API连接、磁盘读写、网络包、异常…<br>速率限制允许将系统的性能和隐定性平衡在可控范围内。如果需要扩大这些限制，可以在大量测试和等待后，以可控的方式进行拓展。</p><p>大多数的限速是基于令牌桶算法的。这很容易理解，而且相对容易实现。<br>如果要访问资源，你必须拥有资源的访问令牌，没有令牌的请求会被拒绝。<br>现在假设这些令牌存储在一个等待被检索使用的桶中。桶的深度为d,表示一个桶可以容纳d个访问令牌。<br>例如，存储桶深度为五，则可以存放五个令牌。每当你需要访问资源时，都会在桶中删除一个令牌。<br>如果你的存储桶包含五个令牌，前五次访问没有问题，操作正常进行；但是在第六次尝试时，就没有访问令牌可用。你的请求必须排队等待，直到令牌可用，或者被拒绝操作。</p><p>那如何补充令牌，我们总是能获得一个新的吗？在令牌桶算法中，将r定义为向桶中添加令牌的速率。它可以是一纳秒或一分钟。<br>这就是我们通常认为的速率限制：因为我们必须等到新的令牌可用，我们将操作速度限制在这个频率下。</p><p>现在我们有两个设置项可以修改：有多少个令牌可以立即使用d,桶的深度，以及它们补充的速度r。在这两者之间，我们可以平衡突发性和限制整体速率。<br>突发性指的是当存储桶已满时可以进行多少次请求。</p><p>下面是使用<code>golang.org/x/time/rate</code>包实现的例子，同时对磁盘访问和网络访问添加限制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;golang.org/x/time/rate&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> log.Printf(<span class="string">&quot;Done.&quot;</span>)</span><br><span class="line">log.SetOutput(os.Stdout)</span><br><span class="line">log.SetFlags(log.Ltime | log.LUTC)</span><br><span class="line"></span><br><span class="line">apiConnection := Open()</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">err := apiConnection.ReadFile(context.Background())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;cannot ReadFile: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;ReadFile&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">err := apiConnection.ResolveAddress(context.Background())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;cannot ResolveAddress: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;ResolveAddress&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Per</span><span class="params">(eventCount <span class="type">int</span>, duration time.Duration)</span></span> rate.Limit &#123;</span><br><span class="line"><span class="keyword">return</span> rate.Every(duration / time.Duration(eventCount))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span></span> *APIConnection &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;APIConnection&#123;</span><br><span class="line">apiLimiter: MultiLimiter( <span class="comment">// 为API调用设置限速器，每秒请求数与每分钟请求数都有限制</span></span><br><span class="line">rate.NewLimiter(Per(<span class="number">2</span>, time.Second), <span class="number">2</span>), <span class="comment">// 第一个参数为频率，第二个为桶大小</span></span><br><span class="line">rate.NewLimiter(Per(<span class="number">10</span>, time.Minute), <span class="number">10</span>),</span><br><span class="line">),</span><br><span class="line">diskLimiter: MultiLimiter( <span class="comment">// 为磁盘操作设置限速器，每秒一次</span></span><br><span class="line">rate.NewLimiter(rate.Limit(<span class="number">1</span>), <span class="number">1</span>),</span><br><span class="line">),</span><br><span class="line">networkLimiter: MultiLimiter( <span class="comment">// 为网络操作设置限速器，每秒3次</span></span><br><span class="line">rate.NewLimiter(Per(<span class="number">3</span>, time.Second), <span class="number">3</span>),</span><br><span class="line">),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> APIConnection <span class="keyword">struct</span> &#123;</span><br><span class="line">networkLimiter RateLimiter</span><br><span class="line">diskLimiter    RateLimiter</span><br><span class="line">apiLimiter     RateLimiter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *APIConnection)</span></span> ReadFile(ctx context.Context) <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">// 读取文件时，同时使用API限速器和磁盘限速器的限制</span></span><br><span class="line"><span class="keyword">if</span> err := MultiLimiter(a.apiLimiter, a.diskLimiter).Wait(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 假设执行一些逻辑</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *APIConnection)</span></span> ResolveAddress(ctx context.Context) <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">// 网络访问时，同时使用API限速器和网络限速器的限制</span></span><br><span class="line"><span class="keyword">if</span> err := MultiLimiter(a.apiLimiter, a.networkLimiter).Wait(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 假设执行一些逻辑</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RateLimiter <span class="keyword">interface</span> &#123; <span class="comment">// 定义 RateLimiter 接口，使 MultiLimiter 可以递归地定义其他 MultiLimiter 实例。</span></span><br><span class="line">Wait(context.Context) <span class="type">error</span></span><br><span class="line">Limit() rate.Limit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MultiLimiter</span><span class="params">(limiters ...RateLimiter)</span></span> *multiLimiter &#123;</span><br><span class="line">byLimit := <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> limiters[i].Limit() &lt; limiters[j].Limit()</span><br><span class="line">&#125;</span><br><span class="line">sort.Slice(limiters, byLimit) <span class="comment">// 根据每个 RateLimiter 的 Limit() 进行排序</span></span><br><span class="line"><span class="keyword">return</span> &amp;multiLimiter&#123;limiters: limiters&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> multiLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">limiters []RateLimiter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *multiLimiter)</span></span> Wait(ctx context.Context) <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, l := <span class="keyword">range</span> l.limiters &#123;</span><br><span class="line"><span class="keyword">if</span> err := l.Wait(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *multiLimiter)</span></span> Limit() rate.Limit &#123;</span><br><span class="line"><span class="keyword">return</span> l.limiters[<span class="number">0</span>].Limit() <span class="comment">// 返回限制最多的限速器（已排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">09:09:32 ReadFile</span><br><span class="line">09:09:33 ReadFile</span><br><span class="line">09:09:33 ResolveAddress</span><br><span class="line">09:09:34 ReadFile</span><br><span class="line">09:09:35 ReadFile</span><br><span class="line">09:09:36 ReadFile</span><br><span class="line">09:09:36 ResolveAddress</span><br><span class="line">09:09:37 ReadFile</span><br><span class="line">09:09:38 ResolveAddress</span><br><span class="line">09:09:38 ReadFile</span><br><span class="line">09:09:39 ReadFile</span><br><span class="line">09:09:44 ResolveAddress</span><br><span class="line">09:09:50 ReadFile</span><br><span class="line">09:09:56 ResolveAddress</span><br><span class="line">09:10:02 ResolveAddress</span><br><span class="line">09:10:08 ResolveAddress</span><br><span class="line">09:10:14 ResolveAddress</span><br><span class="line">09:10:20 ResolveAddress</span><br><span class="line">09:10:26 ResolveAddress</span><br><span class="line">09:10:32 ReadFile</span><br><span class="line">09:10:32 Done.</span><br></pre></td></tr></table></figure><h3 id="治愈异常的goroutine"><a href="#治愈异常的goroutine" class="headerlink" title="治愈异常的goroutine"></a>治愈异常的goroutine</h3><p>在长期运行的后台程序中，经常会有一些长时间运行的goroutine。这些goroutine经常处于阻塞状态，等待数据以某种方式到达，然后唤醒它们，进行一些处理，再返回一些数据。<br>有时候，这些goroutine依赖于一些控制不太好的资源。也许一个goroutine需要从接收到的请求中提取数据，或者它正在监听一个临时文件。<br>问题在于，如果没有外部干预，一个goroutine很容易进入一个不正常的状态，并且无法恢复。<br>抛开这些担忧，你甚至可以说，goroutine本身不应该关心其如何从一个异常状态回复过来。<br>在一个长期运行的程序中，建立一个机制来监控你的goroutine是否处于健康的状态是很用的，当他们变得异常时，就可以尽快重启。<br>我们将这个重启goroutine的过程称为“治愈”(Healing）。</p><p>为了治愈goroutine,我们需要使用心跳模式来检查我们正在监控的goroutine是否活跃。<br>心跳的类型取决于你想要监控的内容，但是如果你的goroutine有可能会产生活锁，确保心跳包含某些信息，表明该goroutine在正常的工作而不仅仅是活着。<br>把监控goroutine的健康这段逻辑称为管理员，它监视一个管理区的goroutine。如果有goroutine变得不健康，管理员将负责重新启动这个管理区的goroutine。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> or <span class="function"><span class="keyword">func</span><span class="params">(channels ...&lt;-<span class="keyword">chan</span> any)</span></span> &lt;-<span class="keyword">chan</span> any</span><br><span class="line">or = <span class="function"><span class="keyword">func</span><span class="params">(channels ...&lt;-<span class="keyword">chan</span> any)</span></span> &lt;-<span class="keyword">chan</span> any &#123;</span><br><span class="line"><span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> channels[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">orDone := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(orDone)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-channels[<span class="number">0</span>]:</span><br><span class="line"><span class="keyword">case</span> &lt;-channels[<span class="number">1</span>]:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-channels[<span class="number">0</span>]:</span><br><span class="line"><span class="keyword">case</span> &lt;-channels[<span class="number">1</span>]:</span><br><span class="line"><span class="keyword">case</span> &lt;-channels[<span class="number">2</span>]:</span><br><span class="line"><span class="keyword">case</span> &lt;-or(<span class="built_in">append</span>(channels[<span class="number">3</span>:], orDone)...):</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> orDone</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> startGoroutineFn <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> any, pulseInterval time.Duration)</span></span> (heartbeat &lt;-<span class="keyword">chan</span> any) <span class="comment">// 定义一个可以监控和重启的goroutine的信号</span></span><br><span class="line"></span><br><span class="line">newSteward := <span class="function"><span class="keyword">func</span><span class="params">(timeout time.Duration, startGoroutine startGoroutineFn)</span></span> startGoroutineFn &#123; <span class="comment">// 管理员监控goroutine需要timeout变量和启动goroutine的startGoroutine函数，同时，返回一个startGoroutineFn，说明管理员本身也是可以监控的</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> any, pulseInterval time.Duration)</span></span> &lt;-<span class="keyword">chan</span> any &#123;</span><br><span class="line">heartbeat := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(heartbeat)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wardDone <span class="keyword">chan</span> any</span><br><span class="line"><span class="keyword">var</span> wardHeartbeat &lt;-<span class="keyword">chan</span> any</span><br><span class="line">startWard := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// 定义一个闭包，实现一个统一的方法来启动正在监控的goroutine</span></span><br><span class="line">wardDone = <span class="built_in">make</span>(<span class="keyword">chan</span> any)                                     <span class="comment">// 停止信号，用来停止正在监控的goroutine</span></span><br><span class="line">wardHeartbeat = startGoroutine(or(wardDone, done), timeout/<span class="number">2</span>) <span class="comment">// 启动将要监控的goroutine</span></span><br><span class="line">&#125;</span><br><span class="line">startWard()</span><br><span class="line">pulse := time.Tick(pulseInterval)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">timeoutSignal := time.After(timeout)</span><br><span class="line"><span class="comment">// 管理员自身心跳</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-pulse:</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> heartbeat &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监控goroutine</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-wardHeartbeat: <span class="comment">// 如果收到心跳，将继续监控</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">case</span> &lt;-timeoutSignal: <span class="comment">// 在暂停期间没有收到goroutine心跳，会进行重启</span></span><br><span class="line">log.Println(<span class="string">&quot;steward: ward unhealthy; restarting&quot;</span>)</span><br><span class="line"><span class="built_in">close</span>(wardDone)</span><br><span class="line">startWard()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> heartbeat</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">log.SetOutput(os.Stdout)</span><br><span class="line">log.SetFlags(log.Ltime | log.LUTC)</span><br><span class="line"></span><br><span class="line">doWork := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> any, _ time.Duration)</span></span> &lt;-<span class="keyword">chan</span> any &#123;</span><br><span class="line">log.Println(<span class="string">&quot;ward: Hello, I&#x27;m irresponsible!&quot;</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">&lt;-done <span class="comment">// 这个goroutine没有做任何事，只是等待被取消</span></span><br><span class="line">log.Println(<span class="string">&quot;ward: I am halting.&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">doWorkWithSteward := newSteward(<span class="number">4</span>*time.Second, doWork) <span class="comment">// 为上面的goroutine创建一个管理员，设置超时时间为4秒</span></span><br><span class="line"></span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line">time.AfterFunc(<span class="number">9</span>*time.Second, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// 设置9秒后停止管理员和goroutine</span></span><br><span class="line">log.Println(<span class="string">&quot;main: halting steward and ward.&quot;</span>)</span><br><span class="line"><span class="built_in">close</span>(done)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> doWorkWithSteward(done, <span class="number">4</span>*time.Second) &#123;</span><br><span class="line">&#125; <span class="comment">// 启动管理员，并在其心跳范围内防止测试停止</span></span><br><span class="line">log.Println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可以一直监控一个goroutine，当goroutine不活跃时，管理员会重新启动它。输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">03:28:14 ward: Hello, I&#x27;m irresponsible!</span><br><span class="line">03:28:18 steward: ward unhealthy; restarting</span><br><span class="line">03:28:18 ward: Hello, I&#x27;m irresponsible!</span><br><span class="line">03:28:18 ward: I am halting.</span><br><span class="line">03:28:22 steward: ward unhealthy; restarting</span><br><span class="line">03:28:22 ward: Hello, I&#x27;m irresponsible!</span><br><span class="line">03:28:22 ward: I am halting.</span><br><span class="line">03:28:23 main: halting steward and ward.</span><br><span class="line">03:28:23 ward: I am halting.</span><br><span class="line">03:28:26 Done</span><br></pre></td></tr></table></figure><p>上面的输出看起来符合预期，在其超时时重启它。<br>但是它所管理goroutine有些简单，除了取消和心跳所需要的东西之外，不接受任何参数，也不返回任何参数。<br>下面的例子根据离散值生成一个整数流，并在遇到负数时结束，使用闭包来对其进行包装，可以添加一些参数和返回值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> or <span class="function"><span class="keyword">func</span><span class="params">(channels ...&lt;-<span class="keyword">chan</span> any)</span></span> &lt;-<span class="keyword">chan</span> any</span><br><span class="line">or = <span class="function"><span class="keyword">func</span><span class="params">(channels ...&lt;-<span class="keyword">chan</span> any)</span></span> &lt;-<span class="keyword">chan</span> any &#123;</span><br><span class="line"><span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> channels[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">orDone := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(orDone)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-channels[<span class="number">0</span>]:</span><br><span class="line"><span class="keyword">case</span> &lt;-channels[<span class="number">1</span>]:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-channels[<span class="number">0</span>]:</span><br><span class="line"><span class="keyword">case</span> &lt;-channels[<span class="number">1</span>]:</span><br><span class="line"><span class="keyword">case</span> &lt;-channels[<span class="number">2</span>]:</span><br><span class="line"><span class="keyword">case</span> &lt;-or(<span class="built_in">append</span>(channels[<span class="number">3</span>:], orDone)...):</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> orDone</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> startGoroutineFn <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> any, pulseInterval time.Duration)</span></span> (heartbeat &lt;-<span class="keyword">chan</span> any)</span><br><span class="line"></span><br><span class="line">newSteward := <span class="function"><span class="keyword">func</span><span class="params">(timeout time.Duration, startGoroutine startGoroutineFn)</span></span> startGoroutineFn &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> any, pulseInterval time.Duration)</span></span> &lt;-<span class="keyword">chan</span> any &#123;</span><br><span class="line">heartbeat := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(heartbeat)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wardDone <span class="keyword">chan</span> any</span><br><span class="line"><span class="keyword">var</span> wardHeartbeat &lt;-<span class="keyword">chan</span> any</span><br><span class="line">startWard := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">wardDone = <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line">wardHeartbeat = startGoroutine(or(wardDone, done), timeout/<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">startWard()</span><br><span class="line">pulse := time.Tick(pulseInterval)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">timeoutSignal := time.After(timeout)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-pulse:</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> heartbeat &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-wardHeartbeat:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">case</span> &lt;-timeoutSignal:</span><br><span class="line">log.Println(<span class="string">&quot;steward: ward unhealthy; restarting&quot;</span>)</span><br><span class="line"><span class="built_in">close</span>(wardDone)</span><br><span class="line">startWard()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> heartbeat</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">take := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> any, valueStream &lt;-<span class="keyword">chan</span> any, num <span class="type">int</span>)</span></span> &lt;-<span class="keyword">chan</span> any &#123;</span><br><span class="line">takeStream := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(takeStream)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> takeStream &lt;- &lt;-valueStream:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> takeStream</span><br><span class="line">&#125;</span><br><span class="line">orDone := <span class="function"><span class="keyword">func</span><span class="params">(done, c &lt;-<span class="keyword">chan</span> any)</span></span> &lt;-<span class="keyword">chan</span> any &#123;</span><br><span class="line">valStream := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(valStream)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> v, ok := &lt;-c:</span><br><span class="line"><span class="keyword">if</span> ok == <span class="literal">false</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> valStream &lt;- v:</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> valStream</span><br><span class="line">&#125;</span><br><span class="line">bridge := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> any, chanStream &lt;-<span class="keyword">chan</span> &lt;-<span class="keyword">chan</span> any)</span></span> &lt;-<span class="keyword">chan</span> any &#123;</span><br><span class="line">valStream := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(valStream)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> stream &lt;-<span class="keyword">chan</span> any</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> maybeStream, ok := &lt;-chanStream:</span><br><span class="line"><span class="keyword">if</span> ok == <span class="literal">false</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">stream = maybeStream</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> val := <span class="keyword">range</span> orDone(done, stream) &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> valStream &lt;- val:</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> valStream</span><br><span class="line">&#125;</span><br><span class="line">doWorkFn := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> any, intList ...<span class="type">int</span>)</span></span> (startGoroutineFn, &lt;-<span class="keyword">chan</span> any) &#123; <span class="comment">// 添加所需的参数和返回值</span></span><br><span class="line">intChanStream := <span class="built_in">make</span>(<span class="keyword">chan</span> (&lt;-<span class="keyword">chan</span> any)) <span class="comment">// 创建作为桥接模式一部分的 channel</span></span><br><span class="line">intStream := bridge(done, intChanStream)</span><br><span class="line">doWork := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> any, pulseInterval time.Duration)</span></span> &lt;-<span class="keyword">chan</span> any &#123; <span class="comment">// 创建一个被监控的闭包</span></span><br><span class="line">intStream := <span class="built_in">make</span>(<span class="keyword">chan</span> any) <span class="comment">// 实例化 channel，与 goroutine 通信</span></span><br><span class="line">heartbeat := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(intStream)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> intChanStream &lt;- intStream: <span class="comment">// 将用来通信的 channel 传递给 bridge</span></span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, intVal := <span class="keyword">range</span> intList &#123;</span><br><span class="line"><span class="keyword">if</span> intVal &lt; <span class="number">0</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;negative value: %v\n&quot;</span>, intVal) <span class="comment">// 遇到负数时给出错误信息并从 goroutine 返回</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">pulse := time.Tick(pulseInterval)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-pulse:</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> heartbeat &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> intStream &lt;- intVal:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> heartbeat</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> doWork, intStream</span><br><span class="line">&#125;</span><br><span class="line">log.SetFlags(log.Ltime | log.LUTC)</span><br><span class="line">log.SetOutput(os.Stdout)</span><br><span class="line"></span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line"></span><br><span class="line">doWork, intStream := doWorkFn(done, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">doWorkWithSteward := newSteward(<span class="number">1</span>*time.Millisecond, doWork)</span><br><span class="line">doWorkWithSteward(done, <span class="number">1</span>*time.Hour)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> intVal := <span class="keyword">range</span> take(done, intStream, <span class="number">6</span>) &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Received: %v\n&quot;</span>, intVal)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Received: 1</span><br><span class="line">07:22:25 negative value: -1</span><br><span class="line">Received: 2</span><br><span class="line">07:22:25 steward: ward unhealthy; restarting</span><br><span class="line">Received: 1</span><br><span class="line">07:22:25 negative value: -1</span><br><span class="line">Received: 2</span><br><span class="line">07:22:25 steward: ward unhealthy; restarting</span><br><span class="line">Received: 1</span><br><span class="line">07:22:25 negative value: -1</span><br><span class="line">Received: 2</span><br></pre></td></tr></table></figure><h2 id="第六章-goroutine-和-Go语言运行时"><a href="#第六章-goroutine-和-Go语言运行时" class="headerlink" title="第六章 - goroutine 和 Go语言运行时"></a>第六章 - goroutine 和 Go语言运行时</h2><h3 id="工作窃取"><a href="#工作窃取" class="headerlink" title="工作窃取"></a>工作窃取</h3><p>Go语言将调度多个goroutine,使其在系统线程上运行。它使用的算法被称为工作窃取策略。</p><ol><li>朴素策略（公平调度策略）<br>在所有可用处理器之间平均分配任务。但是在fork-join模型中，任务可能会相互依赖，导致处理器空闲等待。另外还可能导致缓存的位置偏差，因为调用这些数据的任务跑在其他处理器上。</li><li>工作窃取算法：集中队列算法<br>使用一个集中化的FIFO队列来存储待处理的任务。处理器从队列中获取任务进行执行。但是反复进出临界区会导致较高的竞争开销。也有缓存偏移的问题，集中式队列需要频繁地加载到每个处理器的缓存中，影响缓存效率。</li><li>工作窃取算法：分布式队列算法<br>每个处理器拥有独立的双端队列。解决了集中式队列的竞争问题，提高了并行度和缓存命中率。每个处理器有自己的队列，减少了竞争开销。任务在同一处理器上执行，提高了缓存命中率。</li></ol><p>在goroutine开始的时候fork,join点是两个或更多的goroutine通过channel或sync包中的类型进行同步时。<br>工作窃取算法遵循一些基本原则。对于给定的线程：</p><ol><li>在fork点，将任务添加到与线程关联的双端队列的尾部。</li><li>如果线程空闲，则选取一个随机的线程，从它关联的双端队列头部窃取工作。</li><li>如果在未准备好的join点（即与其同步的goroutine还没有完成），则将工作从线程的双端队列尾部出栈。</li><li>如果线程的双端队列是空的，则：<ol><li>暂停加入。</li><li>从随机线程关联的双端队列中窃取工作。</li></ol></li></ol><p>正在执行的线程会在队列的尾部人栈或者（必要时）出栈一个任务。位于队列尾部的任务有这样几个有趣的特性：</p><ul><li>这是最有可能完成父进程join的任务。<br>更快地完成join意味着我们的程序性能会更好，在内存中停留的时间更少。</li><li>这是最有可能存在于处理器缓存中的任务。<br>因为这是这个线程在开始当前工作前的最后一个任务。所以当前线程执行需要的信总可能仍然存在于CPU的缓存之中。这意味着缓存的命中率更高</li></ul><h4 id="窃取任务还是续体"><a href="#窃取任务还是续体" class="headerlink" title="窃取任务还是续体"></a>窃取任务还是续体</h4><p>什么样的任务进行排队和窃取。fork-join模式下两种选择：新任务和续体。</p><p>窃取任务是指一个空闲的处理器从另一个忙碌的处理器的任务队列中获取任务进行执行。<br>窃取续体是指一个处理器从另一个处理器的任务队列中获取未完成的goroutine（或称为续体）并继续执行。</p><p>G0语言的周度器有三个主要的概念：</p><ul><li>G goroutine.</li><li>M OS线程（在源代码中也被称为机器）。 </li><li>P 上下文（在源代码中也被称为处理器）。</li></ul><p>Go语言的工作窃取算法对续体进行入队和窃取。<br>当一个执行线程到达一个join point时，该线程必须暂停执行，等待回调以窃取任务。</p><h3 id="向开发人员展示所有这些信息"><a href="#向开发人员展示所有这些信息" class="headerlink" title="向开发人员展示所有这些信息"></a>向开发人员展示所有这些信息</h3><p>关键字 go 连接所有的这些</p><p>在函数或闭包之前敲上go,就会有一个会自动调度的任务，它将以最有效率的方式利用它所在的机器。<br>作为开发者，我们依旧使用我们最熟悉的原语：function。我们不必理解新的处理方式，复杂的数据结构或调度算法。</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>很好的书，有些从未见过的go代码。对于熟悉go并发的使用非常好。<br>最后一章关于go原理部分有些抽象，后续可能会单独写一篇关于go线程模型的文章以深入了解下。</p><p>现在，该去重构我的聊天室应用了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天是2025年1月28日，除夕夜晚上十点半。今年家里是十分的冷清，没有什么过年的氛围。&lt;br&gt;不过，可能向来如此吧。&lt;/p&gt;
&lt;p&gt;除夕夜</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://cooooing.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="go" scheme="https://cooooing.github.io/tags/go/"/>
    
    <category term="并发" scheme="https://cooooing.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="《go语言并发之道》" scheme="https://cooooing.github.io/tags/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%81%93%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《go语言并发之道》读书笔记-并发模式</title>
    <link href="https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/"/>
    <id>https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/</id>
    <published>2025-01-21T04:41:17.000Z</published>
    <updated>2025-01-21T04:41:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第四章-Go语言的并发模式"><a href="#第四章-Go语言的并发模式" class="headerlink" title="第四章 - Go语言的并发模式"></a>第四章 - Go语言的并发模式</h2><p>前面讲了Go语言的并发原语的基本原理，这章要讨论如何将它们组合成模式，以帮助保持系统的可拓展性和可维护性。</p><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>在编写并发代码的时候，有以下几种不同的保证操作安全的方法。我们已经介绍了其中两个：</p><ul><li>用于共享内存的同步原语（如sync.Mutex)。</li><li>通过通信共享内存来进行同步（如channel)。</li></ul><p>但是，在并发处理中还有其他几种情况也是隐式并发安全的：</p><ul><li>不会发生改变的数据。</li><li>受到保护的数据。</li></ul><p>从某种意义上讲，不可变数据是理想的，因为它是隐式地并行安全的。每个并发进程可能对相同的数据进行操作，但不能对其进行修改。<br>如果要创建新数据，则必须创建具有所需修改的数据的新副本。这不仅可以减轻开发人员的认知负担，并且可以使程序运行得更快，这将使程序的临界区减少（或者完全消除临界区)<br>在G0语言中，可以通过编写利用值的副本而不是指向内存值的指针的代码来实现此目的。有些语言支持使用明确不变的值的指针，然而，G0语言不在其中。<br>“约束”还可以使开发人员减少临界区的长度以及承担更小的认知负担。约束并发值的技术比简单传递值的副本要复杂一点，所以本章我们将深入介绍这些约束技术。</p><p>“约束”是一种确保了信息只能从一个并发过程中获取到的简单且强大的方法。达到此目的时，并发程序隐式安全，不需要同步。<br>有两种可能的约束：特定约束和词法约束。</p><p>特定约束是指通过公约实现约束时，无论是由语言社区、你所在的团队，还是你的代码库设置。<br>坚持约束很难在任何规模的项目上进行协调，除非你有工具在每次有人提交代码时对你的代码进行静态分析。（因为每个人开发习惯和理解不一致，导致基本是不可能的事）</p><p>词法约束涉及使用词法作用域仅公开用于多个并发进程的正确数据和并发原语。这使得做错事是不可能的。实际上我们已经在第3章中谈到了这个主题。<br>回想一下 channel 部分，它讨论的只是将 channel 的读或写处理暴露给需要它们的并发进程。因为 channel 是并发安全的。<br>下面看一个不是并发安全的数据结构约束的例子，他是一个 bytes Buffer 的实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">printData := <span class="function"><span class="keyword">func</span><span class="params">(wg *sync.WaitGroup, data []<span class="type">byte</span>)</span></span> {</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">var</span> buff bytes.Buffer</span><br><span class="line"><span class="keyword">for</span> _, b := <span class="keyword">range</span> data {</span><br><span class="line">fmt.Fprintf(&amp;buff, <span class="string">"%c"</span>, b)</span><br><span class="line">}</span><br><span class="line">fmt.Println(buff.String())</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line">data := []<span class="type">byte</span>(<span class="string">"golang"</span>)</span><br><span class="line"><span class="keyword">go</span> printData(&amp;wg, data[:<span class="number">3</span>])</span><br><span class="line"><span class="keyword">go</span> printData(&amp;wg, data[<span class="number">3</span>:])</span><br><span class="line">wg.Wait()</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在这个例子中，你可以看到，因为 printData 没有对切片数据进行封装或保护。<br><strong>但因为传递的是切片的不同子集，且不重合。</strong> 所以可以通过不用通过通信完成内存访问同步或共享数据。</p><p>那么有什么意义呢？如果我们有同步功能，为什么要约束？答案是提高了性能并降低了开发人员的认知负担。<br>同步带来了成本，如果你可以避免它，你将不会有任何临界区，因此你不必为同步它们付出任何成本。<br>你也可以通过同步回避所有可能的问题，开发人员根本不必担心这些问题。<br>利用词法约束的并发代码通常比不具有词法约束变量的并发代码更易于理解。这是因为在你的词法范围内，你可以编写同步代码。<br>但建立约束可能很困难。</p><h3 id="for-select-循环"><a href="#for-select-循环" class="headerlink" title="for-select 循环"></a>for-select 循环</h3><p>向 channel 发送迭代变量<br>通常情况下，你需要将可迭代的内容转换为channel上的值。这不是什么幻想，通常看起来像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for _, s := range []string{"a", "b", "c"} {</span><br><span class="line">select {</span><br><span class="line">case &lt;-done:</span><br><span class="line">return</span><br><span class="line">case stringStream &lt;- s:</span><br><span class="line">// ...</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>循环等待停止<br>创建循环，无限循环直到停止的goroutine很常见。这个有一些变化。你选择哪一个纯粹是一种个人爱好。<br>第一种变体保持select语句尽可能短：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for {</span><br><span class="line">select {</span><br><span class="line">case &lt;-done:</span><br><span class="line">return</span><br><span class="line">default:</span><br><span class="line">}</span><br><span class="line">// 进行非抢占式任务</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>如果已经完成的 channel 未关闭，我们将退出 select 语句并继续执行 for 循环的其余部分。</p><p>第二种变体将工作嵌入到选择语句的默认子句中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for {</span><br><span class="line">select {</span><br><span class="line">case &lt;-done:</span><br><span class="line">return</span><br><span class="line">default:</span><br><span class="line">// 进行非抢占式任务</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>当我们输入 select 语句时，如果完成的 channel 尚未关闭，我们将执行 default 子句。<br>这种模式没有什么别的了，但它在任何地方都会被用到，所以值得一提。</p><h3 id="防止goroutine泄漏"><a href="#防止goroutine泄漏" class="headerlink" title="防止goroutine泄漏"></a>防止goroutine泄漏</h3><p>goroutine 是廉价且易于创建，这是让Go语言这么富有成效的原因之一。运行时将多个 goroutine 复用到任意数量的操作系统线程，以便我们不必担心该抽象级别。<br>但是 goroutine 还是需要消耗资源，而且 <strong>goroutine 不会被运行时垃圾回收</strong>，所以无论goroutine所占用的内存有多么的少，我们都不希望我们的进程对此没有感知。<br>那么我们如何去确保他们被清理干净？</p><p>goroutine有以下几种方式被终止：</p><ul><li>当它完成了它的工作。</li><li>因为不可恢复的错误，它不能继续工作。</li><li>当它被告知需要终止工作。</li></ul><p>我们可以很简单地使用前两种方法，因为这两种方法就隐含在你的算法中，<br>但是“取消工作”又是怎样工作的呢？由于网络的影响，事实证明这是最重要的一点：<br>如果你开始了一个goroutine,最有可能以某种有组织的方式与其他几个goroutine合作。<br>我们甚至可以将这种相互连接表现为一个图表：<strong>子 goroutine 是否应该继续执行可能是以许多其他goroutine状态的认知为基础的。</strong></p><p>goroutine(通常是main goroutine)具有这种完整的语境知识应该能够告诉其子goroutine终止。<br>让我们从一个简单的goroutine泄漏开始：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">doWork := <span class="function"><span class="keyword">func</span><span class="params">(strings &lt;-<span class="keyword">chan</span> <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> any {</span><br><span class="line">completed := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"dowork exited."</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(completed)</span><br><span class="line"><span class="keyword">for</span> s := <span class="keyword">range</span> strings {</span><br><span class="line"><span class="comment">// 做些有趣的操作</span></span><br><span class="line">fmt.Println(s)</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">return</span> completed</span><br><span class="line">}</span><br><span class="line">doWork(<span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// 也许这里有其他的操作需要进行</span></span><br><span class="line">fmt.Println(<span class="string">"Done."</span>)</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在这里，我们看到 main goroutine 将一个空的 channel 传递给了 doWork。<br>因此，字符串channel永远不会写入任何字符串，并且包含doWork的goroutine将在此过程的整个生命周期中保留在内存中（如果我们在doWork和main goroutine中加入了goroutine,甚至会死锁)。<br>在这个例子中，这个过程的生命周期很短，但是在一个真正的程序中，goroutine可以很容易地在一个长期生命的程序开始时启动。<br>在最糟糕的情况下，main goroutine 可能会在其生命周期内持续的将其他的 goroutine 设置为自旋，这会导致内存利用率的下降。</p><p>成功减轻这种情况的方法是在父goroutine和其子goroutine之间建立一个信号，让父goroutine向其子goroutine发出信号通知。<br>按照惯例，这个信号通常是一个名为done的只读channel。父goroutine将该channel传递给子goroutine,然后在想要取消子goroutine时关闭该channel。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">doWork := <span class="function"><span class="keyword">func</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">// 在这里，我们将完成的channel传递给doWork函数。作为惯例，这个 channel 是第一个参数。</span></span></span><br><span class="line"><span class="params"><span class="function">done &lt;-<span class="keyword">chan</span> any,</span></span></span><br><span class="line"><span class="params"><span class="function">strings &lt;-<span class="keyword">chan</span> <span class="type">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &lt;-<span class="keyword">chan</span> any {</span><br><span class="line">terminated := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"dowork exited."</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(terminated)</span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> s := &lt;-strings:</span><br><span class="line"><span class="comment">//做一些有意思的操作</span></span><br><span class="line">fmt.Println(s)</span><br><span class="line"><span class="keyword">case</span> &lt;-done: <span class="comment">// 在这一行上，我们看到了在实际编程中无处不在的select模式。我们的一个案例陈述是检查我们的done channel是否已经发出信号。如果有的话，我们从goroutine返回。</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">return</span> terminated</span><br><span class="line">}</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line">terminated := doWork(done, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// 在这里我们创建另一个goroutine,如果超过1s就会取消doWork中产生的goroutine.</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// 在1秒之后取消本操作</span></span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"Canceling dowork goroutine..."</span>)</span><br><span class="line"><span class="built_in">close</span>(done)</span><br><span class="line">}()</span><br><span class="line">&lt;-terminated</span><br><span class="line">fmt.Println(<span class="string">"Done."</span>)</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>输出如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Canceling dowork goroutine...</span><br><span class="line">dowork exited.</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure><p>这可以成功地消除 goroutine 的泄漏。</p><p>前面的例子很好地处理了在channel上接收goroutine的情况，但是如果我们正在处理相反的情况：<br>一个goroutine阻塞了向channel进行写入的请求？以下是演示此问题的简单示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">newRandStream := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> {</span><br><span class="line">randStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"newRandStream closure exited."</span>) <span class="comment">// 这里我们在goroutine成功终止时打印出一条消息。</span></span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(randStream)</span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line">randStream &lt;- rand.Int()</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">return</span> randStream</span><br><span class="line">}</span><br><span class="line">randStream := newRandStream()</span><br><span class="line">fmt.Println(<span class="string">"3 random ints:"</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ {</span><br><span class="line">fmt.Printf(<span class="string">"%d: %d\n"</span>, i, &lt;-randStream)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>输出如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 random ints:</span><br><span class="line">1: 3655305211868055039</span><br><span class="line">2: 1249578273512689196</span><br><span class="line">3: 5508016884678521403</span><br></pre></td></tr></table></figure><p>可以从输出中看到defer语句中的fmt.Println语句永远不会运行。<br>在循环的第三次迭代之后，我们的goroutine试图将下一个随机整数发送到不再被读取的channel。我们无法告诉生产者它可以停止。<br>解决方案就像接收案例一样，为生产者goroutine提供一个通知它退出的channel:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">newRandStream := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> any)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> {</span><br><span class="line">randStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"newRandStream closure exited."</span>) <span class="comment">// 这里我们在goroutine成功终止时打印出一条消息。</span></span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(randStream)</span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> randStream &lt;- rand.Int():</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">return</span> randStream</span><br><span class="line">}</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line">randStream := newRandStream(done)</span><br><span class="line">fmt.Println(<span class="string">"3 random ints:"</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ {</span><br><span class="line">fmt.Printf(<span class="string">"%d: %d\n"</span>, i, &lt;-randStream)</span><br><span class="line">}</span><br><span class="line"><span class="built_in">close</span>(done)</span><br><span class="line"><span class="comment">// 模拟耗时操作</span></span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>输出如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 random ints:</span><br><span class="line">1: 6235326924859206075</span><br><span class="line">2: 5955475684025182616</span><br><span class="line">3: 8355754141677034465</span><br><span class="line">newRandStream closure exited.</span><br></pre></td></tr></table></figure><p>现在goroutine已经被正确地清理了。</p><p>现在我们知道如何确保goroutine不泄漏，我们可以规定一个约定：<strong>如果 goroutine 负责创建 goroutine,它也负责确保它可以停止 goroutine。</strong><br>这个约定有助于确保你的程序在组合和扩展时可以扩展。</p><h3 id="or-channel"><a href="#or-channel" class="headerlink" title="or-channel"></a>or-channel</h3><p>有时你可能会发现自己希望将一个或多个完成的 channel 合并到一个完成的 channel 中，该 channel 在任何组件 channel 关闭时关闭。<br>编写一个执行这种耦合的选择语句是完全可以接受的，尽管很冗长。但是，有时你无法知道你在运行时使用的已完成的channel的数量。<br>在这种情况下，或者如果你只喜欢单线程，你可以使用or-channel模式将这些channel组合在一起。</p><p>这种模式通过递归和goroutine创建一个复合done channel。我们来看一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">var</span> or <span class="function"><span class="keyword">func</span><span class="params">(channels ...&lt;-<span class="keyword">chan</span> any)</span></span> &lt;-<span class="keyword">chan</span> any</span><br><span class="line">or = <span class="function"><span class="keyword">func</span><span class="params">(channels ...&lt;-<span class="keyword">chan</span> any)</span></span> &lt;-<span class="keyword">chan</span> any { <span class="comment">// 在这里，我们有我们的函数，或者，它采用可变的channel切片并返回单个channel</span></span><br><span class="line"><span class="keyword">switch</span> <span class="built_in">len</span>(channels) {</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// 由于这是一个递归函数，我们必须设置终止标准。首先，如果可变切片是空的，我们只返回一个空channel。这是由于不传递channel的观点所产生的，我们不希望复合的channel做任何事情.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 我们的第二个终止标准是如果我们的变量切片只包含一个元素，我们只返回该元素。</span></span><br><span class="line"><span class="keyword">return</span> channels[<span class="number">0</span>]</span><br><span class="line">}</span><br><span class="line">orDone := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> { <span class="comment">// 这是函数的主体，以及递归发生的地方。我们创建了一个goroutine,以便我们可以不受阻塞地等待我们channel上的消息。</span></span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(orDone)</span><br><span class="line"><span class="keyword">switch</span> <span class="built_in">len</span>(channels) {</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// // 基于我们进行迭代的方式，每一次迭代调用都将至少有两个channel。在这里我们为需要两个channel的情况采用了约束goroutine数目的优化方法。</span></span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-channels[<span class="number">0</span>]:</span><br><span class="line"><span class="keyword">case</span> &lt;-channels[<span class="number">1</span>]:</span><br><span class="line">}</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-channels[<span class="number">0</span>]:</span><br><span class="line"><span class="keyword">case</span> &lt;-channels[<span class="number">1</span>]:</span><br><span class="line"><span class="keyword">case</span> &lt;-channels[<span class="number">2</span>]:</span><br><span class="line"><span class="keyword">case</span> &lt;-or(<span class="built_in">append</span>(channels[<span class="number">3</span>:], orDone)...): <span class="comment">// 在这里，我们在循环到我们存放所有channel的slice的第三个索引的时候，我们创建了一个or-channel并从这个channel中选择了一个。这将形成一个由现有slice的剩余部分组成的树并且返回第一个信号量。为了使在建立这个树的goroutine退出的时候在树下的goroutine也可以跟着退出，我们将这个orDone channel也传递到了调用中。</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">return</span> orDone</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这是一个相当简洁的函数，使你可以将任意数量的channel组合到单个channel中，只要任何组件channel关闭或写入，该channel就会关闭。<br>下面是个简短的例子，它将经过一段时间后关闭的channel，并将这些channel合并到一个关闭的单个channel中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">sig := <span class="function"><span class="keyword">func</span><span class="params">(after time.Duration)</span></span> &lt;-<span class="keyword">chan</span> any {</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line">time.Sleep(after)</span><br><span class="line">c &lt;- <span class="keyword">struct</span>{}{}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">start := time.Now()</span><br><span class="line">&lt;-or(</span><br><span class="line">sig(<span class="number">2</span>*time.Hour),</span><br><span class="line">sig(<span class="number">5</span>*time.Minute),</span><br><span class="line">sig(<span class="number">1</span>*time.Second),</span><br><span class="line">sig(<span class="number">1</span>*time.Hour),</span><br><span class="line">sig(<span class="number">1</span>*time.Minute),</span><br><span class="line">)</span><br><span class="line">fmt.Printf(<span class="string">"done after %v\n"</span>, time.Since(start))</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>输出如下：<code>done after 1.0107002s</code></p><p>请注意，尽管在我们的调用中放置了多个channel或需要不同时间才能关闭，但我们在1s后关闭的channel会导致由该调用创建的整个channel关闭。<br>这是因为尽管它位于树或函数构建的树中，它将始终关闭，因此依赖于其关闭的channel也将关闭。</p><p>我们以附加的goroutine为代价来实现这个简洁性，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.791ex;" xmlns="http://www.w3.org/2000/svg" width="11.362ex" height="2.713ex" role="img" focusable="false" viewBox="0 -849.5 5022 1199"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mo" transform="translate(550,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(939,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(1511,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2177.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mrow" transform="translate(3233.6,0)"><g data-mml-node="mo" transform="translate(0 -0.5)"><path data-c="2308" d="M202 -349V850H449V810H242V-349H202Z"></path></g><g data-mml-node="mfrac" transform="translate(472,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mn" transform="translate(245.5,-345) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><rect width="604.5" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(1316.5,0) translate(0 -0.5)"><path data-c="2309" d="M22 810V850H269V-349H229V810H22Z"></path></g></g></g></g></svg></mjx-container>,其中x是goroutine的数量，但要记住Go语言的一个优点是能够快速创建，调度和运行goroutine,并且该语言积极鼓励使用goroutine来正确建模问题。<br>担心在这里创建的goroutine的数量可能是一个不成熟的优化。此外，如果在编译时你不知道你正在使用多少个“done channel”,则将会没有其他方式可以合并“done channel”</p><p>这种模式在你的系统中的模块交汇处非常有用。在这些交汇处，你的调用堆中应该有复数种的用来取消goroutine的决策树。<br>使用or函数，你可以简单地将它们组合在一起并将其传递给堆栈。<br>我们将在本章后面“context包”中看到另一种做法，这也很好，也许更具描述性。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>在并发程序中，错误处理可能难以正确进行。<br>有时候，我们花了很多时间思考我们的各种 stage 如何共享信息和进行协调，我们忘记考虑它们如何优雅地处理错误的状态。<br><strong>当G0语言避开了流行的错误异常模型时，它声明错误处理非常重要，并且在开发我们的程序时，我们应该给出我们的错误路径给予我们的算法同样的关注。</strong><br>本着这种精神，让我们来看看在处理多个并发进程时我们如何做到这一点。</p><p>思考错误处理时最根本的问题是，“谁应该负责处理错误？”在某些时候，程序需要停止将错误输出来，并且实际上对它做了些什么。这么做的目的是什么？</p><p>在并发进程中，这个问题变得更复杂一些。因为并发进程独立于其父进程或兄弟进程运行，所以它可能很难推断出错是正确的。<br>goroutine没有选择。它不能简单地吞下错误，因此它只能做出明智的事情：它会打印错误并希望某些内容被关注。<br>一般来说，你的并发进程应该把他们的错误发送到你的程序的另一部分，它有你的程序状态的完整信息，并可以做出更明智的决定做什么。<br>下面的例子，会在出现三个或更多错误时停止尝试检查状态：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> {</span><br><span class="line">Response *http.Response</span><br><span class="line">Error    <span class="type">error</span></span><br><span class="line">}</span><br><span class="line">checkStatus := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> any, urls ...<span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> Result {</span><br><span class="line">responses := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(responses)</span><br><span class="line"><span class="keyword">for</span> _, url := <span class="keyword">range</span> urls {</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> responses &lt;- Result{Response: resp, Error: err}:</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">return</span> responses</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">errCount := <span class="number">0</span></span><br><span class="line">urls := []<span class="type">string</span>{<span class="string">"a"</span>, <span class="string">"https://www.google.com"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>}</span><br><span class="line"><span class="keyword">for</span> result := <span class="keyword">range</span> checkStatus(done, urls...) {</span><br><span class="line"><span class="keyword">if</span> result.Error != <span class="literal">nil</span> {</span><br><span class="line">fmt.Printf(<span class="string">"error: %v\n"</span>, result.Error)</span><br><span class="line">errCount++</span><br><span class="line"><span class="keyword">if</span> errCount &gt;= <span class="number">3</span> {</span><br><span class="line">fmt.Println(<span class="string">"Too many errors,breaking!"</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">}</span><br><span class="line">fmt.Printf(<span class="string">"Response:%v\n"</span>, result.Response.Status)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error: Get "a": unsupported protocol scheme ""</span><br><span class="line">Response:200 OK</span><br><span class="line">error: Get "b": unsupported protocol scheme ""</span><br><span class="line">error: Get "c": unsupported protocol scheme ""</span><br><span class="line">Too many errors,breaking!</span><br></pre></td></tr></table></figure><p>因为错误是从checkStatus返回的而不是在goroutine内部处理的，错误处理遵循熟悉的G0语言模式。<br>这是一个简单的例子，但不难想象，main goroutine正在协调多个goroutine的结果，并制定更复杂的规则来继续或取消子goroutine.。<br>此外，这里的主要内容是，在构建从goroutine返回值时，应将错误视为一等公民。<br>如果你的goroutine可能产生错误，那么这些错误应该与你的结果类型紧密结合，并且通过相同的通信线传递，就像常规的同步函数一样。</p><h3 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h3><p>pipeline 是可以用来在系统中形成抽象的一种工具。<br>特别是，当你的程序需要流式处理或批处理数据时，它是一个非常强大的工具。<br>pipeline这个词据称是在1856年首次使用的，可能是指将液体从一个地方输送到另一个地方的一系列管道。<br>我们在计算机科学中借用了这个术语，因为我们也在从一个地方向另一个地方传输某些东西：数据。<br>pipeline只不过是一系列将数据输入，执行操作并将结果数据传回的系统。我们称这些操作都是pipeline的一个stage。</p><p>通过使用pipeline,你可以分离每个stage的关注点，这提供了许多好处。<br>你可以相互独立地修改各个stage,你可以混合搭配stage的组合方式，而无需修改stage,你可以将每个stage同时处理到上游或下游stage,并且可以扇出或限制部分你的pipeline。</p><p>让我们从简单的开始，尝试构建一个pipeline的stage。<br>如前所述，一个stage只是将数据输入，对其进行转换并将数据发回。下面是一个可以被视为pipeline stage的函数的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">multiply := <span class="function"><span class="keyword">func</span><span class="params">(values []<span class="type">int</span>, multiplier <span class="type">int</span>)</span></span> []<span class="type">int</span> {</span><br><span class="line">multipliedValues := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(values))</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> values {</span><br><span class="line">multipliedValues[i] = v * multiplier</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> multipliedValues</span><br><span class="line">}</span><br><span class="line">add := <span class="function"><span class="keyword">func</span><span class="params">(values []<span class="type">int</span>, adder <span class="type">int</span>)</span></span> []<span class="type">int</span> {</span><br><span class="line">addedValues := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(values))</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> values {</span><br><span class="line">addedValues[i] = v + adder</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> addedValues</span><br><span class="line">}</span><br><span class="line">ints := []<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>}</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> add(multiply(ints, <span class="number">2</span>), <span class="number">1</span>) {</span><br><span class="line">fmt.Println(v)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">9</span><br><span class="line">11</span><br></pre></td></tr></table></figure><p>看看我们如何在range子句中结合添加和乘法。这些函数就像你每天工作的函数一样，但是因为我们将它们构建为具有pipeline stage的属性，所以我们可以将它们组合起来形成一个pipeline。<br>那很有意思，pipeline stage的属性是什么？</p><ul><li>一个stage消耗并返回相同的类型.</li><li>一个stage必须用语言来表达，以便它可以被传递。Go语言中的功能已被证实，并很好地适用于此目的。</li></ul><p>事实上，pipeline stage与函数式编程密切相关，可以被认为是 monad 的一个子集。我不会在这里明确地讨论monad或函数式编程，但它们本身就是一个有趣的主题，并且在尝试理解pipeline时，对这两个主题的工作知识虽然不必要，但是有用。<br>在这里，我们的add和multiply stage满足pipeline stage的所有属性：它们都消耗一个int切片并返回一个int切片，并且因为Go语言具有函数化功能，所以我们可以传递add和multiply。<br>这些属性引起了我们前面提到的 pipeline stage 的有趣特性，即在不改变stage本身的情况下，将我们的 stage 结合到更高层次变得非常容易。</p><p>例如，如果我们现在想要为pipeline添加一个额外的stage来乘以2，我们只需将我们以前的pipeline包装在一个新的乘法stage,如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ints := []int{1, 2, 3, 4, 5}</span><br><span class="line">for _, v := range multiply(add(multiply(ints, 2), 1), 2) {</span><br><span class="line">fmt.Println(v)</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>最初，这看起来简单得多，但正如我们看到的那样，程序代码在处理数据流时不会提供与pipeline相同的好处。<br>请注意每个stage是如何获取切片数据并返回切片数据的？这些stage正在执行我们称作批处理的操作。这意味若它们仅对大块数据进行一次操作，而不是一次一个离散值。<br>还有另一种类型的pipeline stage执行流处理。这意味着这个stage一次只接收和处理一个元素。</p><p>批处理和流处理有优点和缺点，我们将稍微讨论一下。<br>现在，请注意，为使原始数据保持不变，每个stage都必须创建一个等长的新片段来存储其计算结果。<br>这意味着我们程序在任何时候的内存占用量都是我们发送到我们 pipeline 开始处的片大小的两倍。<br>让我们将我们的stage转换为以流为导向，看起来如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">multiply := <span class="function"><span class="keyword">func</span><span class="params">(value <span class="type">int</span>, multiplier <span class="type">int</span>)</span></span> <span class="type">int</span> {</span><br><span class="line"><span class="keyword">return</span> value * multiplier</span><br><span class="line">}</span><br><span class="line">add := <span class="function"><span class="keyword">func</span><span class="params">(value <span class="type">int</span>, adder <span class="type">int</span>)</span></span> <span class="type">int</span> {</span><br><span class="line"><span class="keyword">return</span> value + adder</span><br><span class="line">}</span><br><span class="line">ints := []<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>}</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> ints {</span><br><span class="line">fmt.Println(add(multiply(v, <span class="number">2</span>), <span class="number">1</span>))</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>每个stage都接收并发出一个离散值，我们的程序的内存占用空间将回落到只有pipeline输入的大小。<br>但是我们不得不将pipeline写入到for循环的体内，并让range语句为我们的pipeline进行繁重的提升。<br>这不仅限制了我们供应pipeline的重复使用，这也限制了我们的扩展能力。</p><p>还有其他问题。实际上，我们正在为循环的每次迭代实例化我们的pipeline。尽管进行函数调用代价很低，但我们为循环的每次迭代进行三次函数调用。<br>并发性又如何？我前面说过，使用pipeline的好处之一是能够同时处理各个stage,并且我提到了一些关于扇出(fan-out)的内容。所有进来的地方在哪里？</p><h4 id="构建-pipeline-的最佳实践"><a href="#构建-pipeline-的最佳实践" class="headerlink" title="构建 pipeline 的最佳实践"></a>构建 pipeline 的最佳实践</h4><p>channel非常适合在Go语言中构建pipeline,因为它们满足了我们所有的基本要求。<br>它们可以接受和产生值，可以安全地同时使用，还可以被放弃，它们被语言所证实。<br>让我们花点时间转换一下前面的例子来改用channel:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">generator := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> any, integers ...<span class="type">int</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> {</span><br><span class="line">intStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(intStream)</span><br><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> integers {</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> intStream &lt;- i:</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">return</span> intStream</span><br><span class="line">}</span><br><span class="line">multiply := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> any, intStream &lt;-<span class="keyword">chan</span> <span class="type">int</span>, multiplier <span class="type">int</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> {</span><br><span class="line">multipliedStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(multipliedStream)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> intStream {</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> multipliedStream &lt;- i * multiplier:</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">return</span> multipliedStream</span><br><span class="line">}</span><br><span class="line">add := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> any, intStream &lt;-<span class="keyword">chan</span> <span class="type">int</span>, additive <span class="type">int</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> {</span><br><span class="line">summedStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(summedStream)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> intStream {</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> summedStream &lt;- i + additive:</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">return</span> summedStream</span><br><span class="line">}</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">intStream := generator(done, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">pipeline := multiply(done, add(done, intStream, <span class="number">1</span>), <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> pipeline {</span><br><span class="line"><span class="built_in">println</span>(v)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>我们得到了期望的输出。它们都看起来像是在他们的函数体内开始了一个goroutine，通过一个channel表示该goroutine应该退出。这里使用了我们前面“防止goroutine泄漏”中建立的模式。<br>它们看起来都像是返回channel,其中一些看起来像是在另外一个channel中。</p><p>generator 函数接受一个可变的整数切片，构造一个缓存长度等于输入整数片段的整数channel,启动一个goroutine并返回构造的channel。<br>然后，在创建的goroutine上，generator函数使用range语句遍历传入的可变切片，并在其创建的channel上发送切片的值。<br>请注意，channel上的发送与完成channel上的选择共享一条select语句。再一次，使用了前面“防止goroutine泄漏”中建立的模式，以防止泄漏goroutines。</p><p>简而言之，<strong>generator函数将一组离散值转换为一个channel上的数据流</strong>。适当地说，这种类型的功能称为生成器。<br>在使用流水线时，你会经常看到这一点，因为在流水线开始时，你总是会有一些需要转换为channel的数据。</p><p>这里的channel与前面例子中使用函数的channel有些不同之处。<br>首先，我们正在使用pipeline。这是显而易见的，因为它允许两件事情：在我们的pipeline的末尾，我们可以使用范围语句来提取值，并且在每个stage我们可以安全地同时执行，因为我们的输入和输出在并发上下文中是安全的。<br>这给我们带来了第二个不同之处：pipeline的每个stage都在执行控制。这意味着任何stage只需要等待其输入，并且能够发送其输出。事实证明，这会产生巨大的影响。可以注意到它允许我们的stage相互独立地执行某个片段时间。</p><blockquote><p>pipeline中，每个stage都会接收done channel。即<code>case &lt;-done: return</code>控制语句。任何时候关闭 done channel，所有 stage 都会立即终止。<br>同时每个 stage 都会在退出前关闭自己管理的 channel <code>defer close(stream)</code>，避免 goroutine 泄漏。<br>最后每个 stage 的抢占性依赖于上游 stage 的抢占性 <code>for i := range stream</code>，最终形成一个递归关系。</p><p>很妙。书中的描述我没看懂，但就是环环相扣保证我们可以随时终止整个pipeline，而不会导致资源泄漏或阻塞。</p></blockquote><h4 id="一些便利的生成器"><a href="#一些便利的生成器" class="headerlink" title="一些便利的生成器"></a>一些便利的生成器</h4><p>pipeline的生成器是将一组离散值转换为channel上的值流的任何函数。</p><p>我们来看看一个名为 repeat 的生成器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">repeat := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> any, values ...any)</span></span> &lt;-<span class="keyword">chan</span> any {</span><br><span class="line">valueStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(valueStream)</span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> values {</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> valueStream &lt;- v:</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">return</span> valueStream</span><br><span class="line">}</span><br><span class="line">take := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> any, valueStream &lt;-<span class="keyword">chan</span> any, num <span class="type">int</span>)</span></span> &lt;-<span class="keyword">chan</span> any {</span><br><span class="line">takeStream := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(takeStream)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ {</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> takeStream &lt;- &lt;-valueStream:</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">return</span> takeStream</span><br><span class="line">}</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> take(done, repeat(done, <span class="number">1</span>), <span class="number">10</span>) {</span><br><span class="line">fmt.Printf(<span class="string">"%v "</span>, v)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>输出如下：<code>1 1 1 1 1 1 1 1 1 1 </code></p><p>这段代码展示了 Go 语言中 <strong>pipeline</strong> 模式的另一种实现方式，结合了 <code>repeat</code> 和 <code>take</code> 两个 stage，用于生成重复的值并从中取出指定数量的值。下面我们逐步分析代码的功能和运行机制。</p><ol><li><strong><code>repeat</code> 函数</strong>：生成一个无限重复的流，将传入的值循环发送到 channel 中。</li><li><strong><code>take</code> 函数</strong>：从传入的 channel 中取出指定数量的值，然后关闭 channel。</li><li><strong><code>main</code> 函数</strong>：组合 <code>repeat</code> 和 <code>take</code>，生成一个重复的值流，并从中取出前 10 个值。</li></ol><p>我们可以扩展这一点。让我们创建另一个重复的生成器，但是这次我们创建一个重复调用函数的生成器。我们称之为repeatFn:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand/v2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">repeatFn := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> any, fn <span class="keyword">func</span>()</span></span> any) &lt;-<span class="keyword">chan</span> any {</span><br><span class="line">valueStream := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(valueStream)</span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> valueStream &lt;- fn():</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">return</span> valueStream</span><br><span class="line">}</span><br><span class="line">take := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> any, valueStream &lt;-<span class="keyword">chan</span> any, num <span class="type">int</span>)</span></span> &lt;-<span class="keyword">chan</span> any {</span><br><span class="line">takeStream := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(takeStream)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ {</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> takeStream &lt;- &lt;-valueStream:</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">return</span> takeStream</span><br><span class="line">}</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">rand := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> any {</span><br><span class="line"><span class="keyword">return</span> rand.Int()</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> take(done, repeatFn(done, rand), <span class="number">10</span>) {</span><br><span class="line">fmt.Println(v)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这非常酷，一个根据需要生成随机整数的无限channel（确实，从未有过的想法</p><p>一般来说，pipeline上的限制因素将是你的生成器，或者是计算密集型的一个stage。如果生成器不像repeat和repeatFn生成器那样从内存中创建流，则可能会受/O限制。<br>如果一个stage计算成本很高，我们该如何帮助缓解这个问题呢？它不会限制整个pipeline的速度吗？<br>为了缓解这种情况，让我们来讨论扇出扇入(fan-out,fan-in)技术。</p><h3 id="扇入、扇出"><a href="#扇入、扇出" class="headerlink" title="扇入、扇出"></a>扇入、扇出</h3><p><strong>扇入（Fan-In）</strong> 和 <strong>扇出（Fan-Out）</strong> 是并发编程中的两种常见模式，用于描述数据流的合并和分发。它们在处理多任务、多数据源或多消费者场景时非常有用。</p><p>扇出是指将 <strong>一个输入流分发给多个处理单元（goroutine）</strong>，以实现并行处理。扇出模式通常用于提高任务的处理效率。<br>在某个stage在计算上特别昂贵时，可以使用扇出，增加处理单元来提高效率。防止上游阻塞。</p><p>扇入是指将 <strong>多个输入流合并为一个输出流</strong>。扇入模式通常用于将多个 goroutine 的结果汇总。</p><p>扇入和扇出通常结合使用，以实现高效的并发处理。<br>例如下面的代码，首先创建一个无限的随机数生成器，并使用多个stage计算其是否为素数（耗时操作），然后使用fanIn将计算结果进行合并，最后take取出前10个结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">repeatFn := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> any, fn <span class="keyword">func</span>()</span></span> any) &lt;-<span class="keyword">chan</span> any {</span><br><span class="line">valueStream := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(valueStream)</span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> valueStream &lt;- fn():</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">return</span> valueStream</span><br><span class="line">}</span><br><span class="line">take := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> any, valueStream &lt;-<span class="keyword">chan</span> any, num <span class="type">int</span>)</span></span> &lt;-<span class="keyword">chan</span> any {</span><br><span class="line">takeStream := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(takeStream)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ {</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> takeStream &lt;- &lt;-valueStream:</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">return</span> takeStream</span><br><span class="line">}</span><br><span class="line">toInt := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> any, valueStream &lt;-<span class="keyword">chan</span> any)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> {</span><br><span class="line">intStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(intStream)</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> valueStream {</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> intStream &lt;- v.(<span class="type">int</span>):</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">return</span> intStream</span><br><span class="line">}</span><br><span class="line">primeFinder := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> any, intStream &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &lt;-<span class="keyword">chan</span> any {</span><br><span class="line">primeStream := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(primeStream)</span><br><span class="line"><span class="keyword">for</span> integer := <span class="keyword">range</span> intStream {</span><br><span class="line">integer -= <span class="number">1</span></span><br><span class="line">prime := <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> divisor := integer - <span class="number">1</span>; divisor &gt; <span class="number">1</span>; divisor-- {</span><br><span class="line"><span class="keyword">if</span> integer%divisor == <span class="number">0</span> {</span><br><span class="line">prime = <span class="literal">false</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> prime {</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> primeStream &lt;- integer:</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">return</span> primeStream</span><br><span class="line">}</span><br><span class="line">fanIn := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> any, channels ...&lt;-<span class="keyword">chan</span> any)</span></span> &lt;-<span class="keyword">chan</span> any {</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">multiplexedStream := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"></span><br><span class="line">multiplex := <span class="function"><span class="keyword">func</span><span class="params">(c &lt;-<span class="keyword">chan</span> any)</span></span> {</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c {</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> multiplexedStream &lt;- i:</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Select from all the channels</span></span><br><span class="line">wg.Add(<span class="built_in">len</span>(channels))</span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> channels {</span><br><span class="line"><span class="keyword">go</span> multiplex(c)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for all the reads to complete</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="built_in">close</span>(multiplexedStream)</span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> multiplexedStream</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line"></span><br><span class="line">start := time.Now()</span><br><span class="line"></span><br><span class="line">rand := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> any { <span class="keyword">return</span> rand.Intn(<span class="number">50000000</span>) }</span><br><span class="line">randIntStream := toInt(done, repeatFn(done, rand))</span><br><span class="line">numFinders := runtime.NumCPU()</span><br><span class="line">fmt.Printf(<span class="string">"Spinning up %d prime finders.\n"</span>, numFinders)</span><br><span class="line">finders := <span class="built_in">make</span>([]&lt;-<span class="keyword">chan</span> any, numFinders)</span><br><span class="line">fmt.Println(<span class="string">"Primes:"</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numFinders; i++ {</span><br><span class="line">finders[i] = primeFinder(done, randIntStream)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> prime := <span class="keyword">range</span> take(done, fanIn(done, finders...), <span class="number">10</span>) {</span><br><span class="line">fmt.Printf(<span class="string">"\t%d\n"</span>, prime)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Search took: %v"</span>, time.Since(start))</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Spinning up 20 prime finders.</span><br><span class="line">Primes:</span><br><span class="line">8768423</span><br><span class="line">31296637</span><br><span class="line">37026001</span><br><span class="line">11348221</span><br><span class="line">32732303</span><br><span class="line">1481477</span><br><span class="line">46401169</span><br><span class="line">49287157</span><br><span class="line">10097783</span><br><span class="line">27371681</span><br><span class="line">Search took: 488.1048ms</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>模式</strong></th><th><strong>描述</strong></th><th><strong>应用场景</strong></th></tr></thead><tbody><tr><td>扇出</td><td>将输入流分发给多个处理单元（goroutine）</td><td>并行处理任务</td></tr><tr><td>扇入</td><td>将多个输入流合并为一个输出流</td><td>汇总多个任务的结果</td></tr></tbody></table><p>扇入和扇出是并发编程中非常强大的工具，能够有效提高程序的性能和可扩展性。<br>感觉有些类似大数据处理中的 map 和 reduce</p><h3 id="or-done-channel"><a href="#or-done-channel" class="headerlink" title="or-done-channel"></a>or-done-channel</h3><p>有时候，你需要处理来自系统各个分散部分的channel。与pipeline所不同的是，你不能对一个被done channel所取消的channel将会进行什么行为做任何的断言。<br>也就是说，你不知道你的goroutine是否被取消，这意味着你正在读取的channel将被取消。<br>出于这个原因，正如在本章前面“防止goroutine泄漏”中所阐述的那样，<strong>我们需要用channel中的select语句来包装我们的读操作，并从已完成的channel中进行选择。</strong><br>会写出这样的封 <code>orDone</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">orDone := <span class="function"><span class="keyword">func</span><span class="params">(done, c &lt;-<span class="keyword">chan</span> any)</span></span> &lt;-<span class="keyword">chan</span> any {</span><br><span class="line">valStream := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(valStream)</span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> v, ok := &lt;-c:</span><br><span class="line"><span class="keyword">if</span> ok == <span class="literal">false</span> {</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> valStream &lt;- v:</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">return</span> valStream</span><br><span class="line">}</span><br><span class="line">repeatFn := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> any, fn <span class="keyword">func</span>()</span></span> any) &lt;-<span class="keyword">chan</span> any {</span><br><span class="line">valueStream := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(valueStream)</span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> valueStream &lt;- fn():</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">return</span> valueStream</span><br><span class="line">}</span><br><span class="line">take := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> any, valueStream &lt;-<span class="keyword">chan</span> any, num <span class="type">int</span>)</span></span> &lt;-<span class="keyword">chan</span> any {</span><br><span class="line">takeStream := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(takeStream)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ {</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> takeStream &lt;- &lt;-valueStream:</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">return</span> takeStream</span><br><span class="line">}</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line">stream := take(done, repeatFn(done, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> any { <span class="keyword">return</span> rand.Int() }), <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> val := <span class="keyword">range</span> orDone(done, stream) {</span><br><span class="line">fmt.Println(val)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="tee-channel"><a href="#tee-channel" class="headerlink" title="tee-channel"></a>tee-channel</h3><p>有时候你可能想分制一个来自channel的值，以便将它们发送到你的代码的两个独立区域中。<br>设想一下，一个传递用户指令的channel:你可能想要在一个 channel 上接收一系列用户指令，将它们发送给相应的执行器，并将它们发送给记录命令以供日后审计的东西。</p><p>从类UNIX系统中的 tee 命令中获得它的名字，tee-channel 就是这样做的。<br>你可以将它传递给一个读channel,并且它会返回两个单独的channel,以获得相同的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">repeat := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, values ...<span class="keyword">interface</span>{})</span></span> &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</span><br><span class="line">valueStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(valueStream)</span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> values {</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> valueStream &lt;- v:</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">return</span> valueStream</span><br><span class="line">}</span><br><span class="line">take := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, valueStream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, num <span class="type">int</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</span><br><span class="line">takeStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(takeStream)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ {</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> takeStream &lt;- &lt;-valueStream:</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">return</span> takeStream</span><br><span class="line">}</span><br><span class="line">orDone := <span class="function"><span class="keyword">func</span><span class="params">(done, c &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{})</span></span> &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</span><br><span class="line">valStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(valStream)</span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> v, ok := &lt;-c:</span><br><span class="line"><span class="keyword">if</span> ok == <span class="literal">false</span> {</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> valStream &lt;- v:</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">return</span> valStream</span><br><span class="line">}</span><br><span class="line">tee := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, in &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{})</span></span> (_, _ &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) {</span><br><span class="line">out1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</span><br><span class="line">out2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(out1)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(out2)</span><br><span class="line"><span class="keyword">for</span> val := <span class="keyword">range</span> orDone(done, in) {</span><br><span class="line"><span class="keyword">var</span> out1, out2 = out1, out2 <span class="comment">// 使用out1和out2的本地版本。</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ {</span><br><span class="line"><span class="comment">// 使用se1ect语句，以便不阻塞的写入out1和out2。为确保两者都写入，将执行select语句的两次迭代：每个出站一个channel。</span></span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">case</span> out1 &lt;- val:</span><br><span class="line">out1 = <span class="literal">nil</span> <span class="comment">// 一旦写入了channel,将其影副本设置为nil,以便进一步阻塞写入，而另一个channel可以继续。</span></span><br><span class="line"><span class="keyword">case</span> out2 &lt;- val:</span><br><span class="line">out2 = <span class="literal">nil</span> <span class="comment">// 一旦写入了channel,将其影副本设置为nil,以便进一步阻塞写入，而另一个channel可以继续。</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">return</span> out1, out2</span><br><span class="line">}</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line"></span><br><span class="line">out1, out2 := tee(done, take(done, repeat(done, <span class="number">1</span>, <span class="number">2</span>), <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> val1 := <span class="keyword">range</span> out1 {</span><br><span class="line">fmt.Printf(<span class="string">"out1: %v, out2: %v\n"</span>, val1, &lt;-out2)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">out1: 1, out2: 1</span><br><span class="line">out1: 2, out2: 2</span><br><span class="line">out1: 1, out2: 1</span><br><span class="line">out1: 2, out2: 2</span><br></pre></td></tr></table></figure><p>注意写入out1和out2是紧密耦合的。直到out1和0ut2都被写入，迭代才能继续。<br>防止出现out1和out2的消费者消费速度不一致，导致数据顺序的问题（适合数据严格同步的场景）。同时，如果消费者没有及时消费，写入操作会阻塞。<br>最后，这个模式也可以作为多个goroutine的同步点。</p><h3 id="桥接-channel-模式"><a href="#桥接-channel-模式" class="headerlink" title="桥接 channel 模式"></a>桥接 channel 模式</h3><p>在某些情况下，你可能会发现自己希望从一系列的channel中消费产生的值：<code>&lt;-chan &lt;-chan any</code><br>这与将channel切片合并到单个channel中稍有不同，如我们在本章前面“The or-channel”或“扇出，扇入”中所看到的。<br>一系列的channel需要有序地写入，即使是不同的来源。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">orDone := <span class="function"><span class="keyword">func</span><span class="params">(done, c &lt;-<span class="keyword">chan</span> any)</span></span> &lt;-<span class="keyword">chan</span> any {</span><br><span class="line">valStream := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(valStream)</span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> v, ok := &lt;-c:</span><br><span class="line"><span class="keyword">if</span> ok == <span class="literal">false</span> {</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> valStream &lt;- v:</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">return</span> valStream</span><br><span class="line">}</span><br><span class="line">bridge := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> any, chanStream &lt;-<span class="keyword">chan</span> &lt;-<span class="keyword">chan</span> any)</span></span> &lt;-<span class="keyword">chan</span> any {</span><br><span class="line">valStream := <span class="built_in">make</span>(<span class="keyword">chan</span> any) <span class="comment">// 这将返回  bridge 中的所有值的 channel</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(valStream)</span><br><span class="line"><span class="comment">// 循环从 chanStream 中获取每个 channel，并提供给嵌套循环来使用</span></span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line"><span class="keyword">var</span> stream &lt;-<span class="keyword">chan</span> any</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> maybeStream, ok := &lt;-chanStream:</span><br><span class="line"><span class="keyword">if</span> ok == <span class="literal">false</span> {</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line">stream = maybeStream</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 循环读取已给出的 channel 中的值，将其写入 valStream。当正在循环的流关闭时，将从此流中跳出，继续下一次迭代</span></span><br><span class="line"><span class="keyword">for</span> val := <span class="keyword">range</span> orDone(done, stream) {</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> valStream &lt;- val:</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">return</span> valStream</span><br><span class="line">}</span><br><span class="line">genVals := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &lt;-<span class="keyword">chan</span> &lt;-<span class="keyword">chan</span> any {</span><br><span class="line">chanStream := <span class="built_in">make</span>(<span class="keyword">chan</span> (&lt;-<span class="keyword">chan</span> any))</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(chanStream)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">stream := <span class="built_in">make</span>(<span class="keyword">chan</span> any, <span class="number">1</span>)</span><br><span class="line">stream &lt;- i</span><br><span class="line"><span class="built_in">close</span>(stream)</span><br><span class="line">chanStream &lt;- stream</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">return</span> chanStream</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> bridge(<span class="literal">nil</span>, genVals()) {</span><br><span class="line">fmt.Printf(<span class="string">"%v "</span>, v)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>输出如下：<code>0 1 2 3 4 5 6 7 8 9 </code></p><p>通过桥接，可以在单个 range 中使用处理 channel 的 channel，并专注于循环逻辑。将结构处理的部分放在 bridge 函数中。</p><h3 id="队列排队"><a href="#队列排队" class="headerlink" title="队列排队"></a>队列排队</h3><p>有时，在你的队列尚未准备好的时候就开始接受请求是很有用的。这个过程被称作队列。</p><p>这也就意味若只要你的stage完成了某些工作，它就会把结果存储在一个稍后其他stage可以获取到结果的临时存储位置，而且你的stage不需要保存一份指向结果的引用。<br>在第3章“channel”中，我们讨论了带缓存的channel,那其实就是一种队列，而且我们当时有足够的理由不去过多讨论使用它。</p><p>虽然在系统中引入队列功能非常有用，但它通常是优化程序时希望采用的最后一种技术之一。<br>预先添加队列可以隐藏同步问题，例如死锁和活锁，并且，随着程序向正确性收敛，你可能会发现需要更多或更少的队列。</p><p>那么队列有什么好处呢？让我们开始回答这个问题，通过解决人们在调整系统性能时犯的一个常见错误：引入队列来尝试解决性能问题。<strong>队列几乎不会加速程序的总运行时间，它只会让程序的行为有所不同。</strong><br><strong>对于引入队列的效用问题的答案并不是一个stage的运行时间已经减少，而是它处于阻塞状态的时间减少了。这可以让这个stage继续工作。</strong></p><p>比如在web服务中的用户请求。加入队列之后用户可能会在他们的请求中经历滞后，但他们不会被拒绝服务。<br>通过这种方式，队列的真正用途是将stage分离，以便一个stage的运行时间不会影响另一个stage的运行时间。<br>以这种方式解耦stage,然后级联以改变整个系统的运行时行为，这取决于你的系统，可以是好的也可以是不好的。</p><p>然后我们来讨论调整排队问题。队列应该放在哪里？缓冲区大小应该是多少？这些问题的答案取决于你的管道的性质。<br>首先分析排队可以提高系统整体性能的情况。唯一适用的情况是：</p><ul><li>如果在一个stage批处理请求节省时间。</li><li>如果stage中的延迟产生反馈回路（如重试、超时等）进入系统。</li></ul><p>第一种情况的一个例子是将输入缓冲到比被设计为发送给（例如，盘）更快的事物（例如，存储器）的stage。</p><p>很显然，这就是Go语言的 bufio 包的目的。<br>缓冲写入比未缓冲写入更快。这是因为在 bufio.Writer 中，写入在内部排队到缓冲区中，直到已经积累了足够的块为止，然后块被写出。这个过程通常称为分块，原因很明显。<br>分块速度更快，因为 bytes.Buffer 必须增加其分配的内存以容纳它必须存储的字节。出于各种原因，增长的内存消耗是昂贵的。所以，我们需要增长的时间越少，整个系统的整体效率就越高。因此，排队提高了整个系统的性能。</p><p>这只是一个简单的内存分块示例，但是你可能会在该领域频繁地进行分块。<br>通常，任何时候执行操作都需要开销，分块可能会提高系统性能。这方面的一些例子是打开数据库事务，计算消息校验和以及分配连续空间。<br>除了分块之外，如果你的算法可以通过支持向后看或排序进行优化，排队也可以起到帮助作用。</p><p>第二种情况是，一个stage的延迟导致管道中接收到了更多的输入，这更难以发现，但也更重要，因为它可能导致上游系统的崩遗。</p><p>这个想法通常被称为负反馈循环，向下螺旋，甚至是死亡螺旋。<br>这是因为管道与上游系统之间存在经常性关系，上游stage或系统提交新请求的速度在某种程度上与管道的有效性有关。<br>如果管道的效率降低到某个临界阈值以下，管道上游的系统开始增加它们对管道的输入（比如重试操作），这导致管道损失更多效率，并且死亡螺旋开始。<br>如果没有某种安全防护，使用管道的系统将永远不能恢复。通过在管道入口处引入队列，你可以用创建请求滞后为代价来打破反馈循环。<br>从调用者进入管道的角度来看，请求似乎正在处理中，但需要很长时间。只要调用者不超时，你的管道将保持稳定。<br>如果主叫方超时，则需要确保你在出列时支持某种检查准备情况。如果你不这样做，你可能会无意中通过处理死亡请求来创建反馈循环，从而降低管道的效率。</p><p>在“队列”理论中，有这样的一条法则，通过足够的取样，可以预测管道的需求率。这被称作<a class="link" href="https://zh.wikipedia.org/wiki/%E5%88%A9%E7%89%B9%E7%88%BE%E6%B3%95%E5%89%87">利特尔法则<i class="fas fa-external-link-alt"></i></a>。<br><code>L = λ × W (系统中的平均负载数=负载的平均到达率*负载在系统中花费的平均时间)</code><br>这个等式只可以应用在所谓的稳定的系统。在管道中，一个稳定的系统是指工作负载进入管道，或者说入口的速率与负载退出系统的速率相等。<br>如果入口的速率超过了出口的速率，你的系统就是不稳定的，而且已经进入了一个死循环。<br>如果你的入口速率没有超过出口速率，你仍旧造成了一个不稳定的系统，但这所导致的也仅仅是你的系统资源并没有被完全使用而已。那并不是这个世界上最槽糕的情况，但是，你可能会在大规模系统（例如，集群或者数据中心）中关心这个问题。</p><p>具体的计算这里省略。<br>总之，队列在系统中可能会很有用，但由于它的复杂性（它会隐藏问题），建议作为实现的最后一个优化手段。</p><h3 id="context-包"><a href="#context-包" class="headerlink" title="context 包"></a>context 包</h3><p>在并发程序中，由于超时，取消或系统其他部分的故障往往需要抢占操作。<br>我们已经看过了创建done channel的习惯用法，该 channel 在你的程序中流动并取消所有阻塞的并发操作。这很好，但它也是有限的。</p><p>如果我们可以在简单的通知上附加传递额外的信息以取消：为什么取消发生，或者我们的函数是否有需要完成的最后期限（超时），这将非常有用。<br>事实证明，对于任何规模的系统来说，使用这些信息来包装已完成的频道是非常常见的，因此Go语言的作者们决定为此创建一个标准模式。<br>它起源于一个在标准库之外的实验功能，但是在Go1.7中，context包被引人标准库中，这使得它成为考虑并发问题时的一个标准的风格。<br>如果看一下上下文包，我们看到它非常简单：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Canceled = errors.New(<span class="string">"context canceled"</span>)</span><br><span class="line"><span class="keyword">var</span> DeadlineExceeded <span class="type">error</span> = deadlineExceededError{}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CancelFunc</span><br><span class="line"><span class="keyword">type</span> Context</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> Context</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span></span> Context</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span></span> (Context, CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Withvalue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>{})</span></span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">type Context interface {</span><br><span class="line">    // 当为该 context 工作的 work 被取消时，deadline 会返回时间。</span><br><span class="line">    // 在没有设定期限的情况下，会返回 ok==false</span><br><span class="line">    // 连续调用 deadline 会返回相同的值</span><br><span class="line">    Deadline() (deadline time.Time, ok bool)</span><br><span class="line">    </span><br><span class="line">    // Done 返回一个 channel，当代表此 context 的工作应被取消时，该 channel 会被关闭。</span><br><span class="line">    // 如果此 context 永远无法被取消，Done 可能返回 nil。</span><br><span class="line">    // 对 Done 的多次调用会返回相同的值。</span><br><span class="line">    // Done channel 的关闭可能是异步的，甚至在 cancel 函数返回之后才发生。</span><br><span class="line">    //</span><br><span class="line">    // WithCancel 会在 cancel 被调用时安排 Done channel 的关闭；</span><br><span class="line">    // WithDeadline 会在截止时间到达时安排 Done channel 的关闭；</span><br><span class="line">    // WithTimeout 会在超时时间到达时安排 Done channel 的关闭。</span><br><span class="line">    //</span><br><span class="line">    // Done 的设计目的是用于 select 语句中。</span><br><span class="line">    Done() &lt;-chan struct{}</span><br><span class="line">    </span><br><span class="line">    // 如果 Done 尚未关闭，Err 返回 nil。</span><br><span class="line">    // 如果 Done 已关闭，Err 返回一个非 nil 的错误，解释原因：</span><br><span class="line">    // - 如果 context 被取消，返回 Canceled 错误；</span><br><span class="line">    // - 如果 context 的截止时间已过，返回 DeadlineExceeded 错误。</span><br><span class="line">    // 一旦 Err 返回一个非 nil 的错误，后续对 Err 的调用将返回相同的错误。</span><br><span class="line">    Err() error</span><br><span class="line">    </span><br><span class="line">    // Value 返回与当前 context 中 key 关联的值，如果没有值与 key 关联，则返回 nil。</span><br><span class="line">    // 对 Value 的多次调用（使用相同的 key）会返回相同的结果。</span><br><span class="line">    //</span><br><span class="line">    // 仅将 context 的值用于跨进程和 API 边界的请求范围数据传递，</span><br><span class="line">    // 而不是将可选参数传递给函数。</span><br><span class="line">    Value(key any) any</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>上下文包有两个主要目的：</p><ul><li>提供一个可以取消你的调用图中分支的API。</li><li>提供用于通过呼叫传输请求范围数据的数据包。</li></ul><p>让我们关注第一个方面：取消。<br>正如我们在本章前面“防止goroutine泄漏”中所学到的，函数中的取消有三个方面：</p><ul><li>goroutine的父goroutine可能想要取消它。</li><li>一个goroutine可能想要取消它的子goroutine。</li><li>goroutine中的任何阻塞操作都必须是可抢占的，以便它可以被取消。</li></ul><p>context包帮助管理所有这三个东西。<br>正如我们所提到的，context类型将是你的函数的第一个参数。如果你看看context接口上的方法，你会发现没有任何东西可以改变底层结构的状态。<br>此外，接收context的函数并不能取消它。这保护了调用堆栈上的函数被子函数取消上下文的情况。<br>结合done channel提供的完成函数，运行上下文类型安全的管理其子上下文的取消。</p><p>下面的函数都接收一个 Context 参数，并返回一个 Context。其中还有些其他参数，比如截止时间和超时参数。<br>这些函数用来生成新的 Context 实例（父子上下文）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancelCause</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelCauseFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadlineCause</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeoutCause</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val any)</span></span> Context</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithoutCancel</span><span class="params">(parent Context)</span></span> Context</span><br></pre></td></tr></table></figure><p>WithCancel返回一个新的Context,它在调用返回的cancel函数时关闭其done channel。<br>WithDeadline返回一个新的Context,当机器的时钟超过给定的最后期限时，它关闭完成的channel。<br>WithTimeout返回一个新的Context,它在给定的超时时间后关闭其完成的channel。</p><p>如果你的函数需要以某种方式在调用图中取消它后面的函数，它将调用其中一个函数并传递给它的上下文，然后将返回的上下文传递给它的子元素。<br>如果你的函数不需要修改取消行为，那么函数只传递给定的上下文。<br>通过这种方式，调用图的连续图层可以创建符合其需求的上下文，而不会影响其父母节点。<br>这为如何管理调用图的分支提供了一个非常可组合的优雅解决方案。</p><p>context包就是本着这种精神来串联起你程序的调用图的。<br>在面向对象的范例中，通常将对经常使用的数据的引用存储为成员变量，但重要的是不要使用context.Context的实例来执行此操作。<br>context.Context的实例可能与外部看起来相同，但在内部它们可能会在每个栈帧更改。<br>出于这个原因，总是将context的实例传递给你的函数是很重要的。通过这种方式，函数具有用于它的上下文，而不是用于堆栈N的上下文。<br>在异步调用图的顶部，你的代码可能不会传递上下文。要启动链，上下文包提供了两个函数来创建上下文的空实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func Background()Context</span><br><span class="line">func TODO()Context</span><br></pre></td></tr></table></figure><p><code>Background()</code>只是返回一个空的上下文。<code>TODO()</code>不是用于生产，而是返回一个空的上下文。<br><code>TODO()</code>的预期目的是作为一个占位符，当你不知道使用哪个上下文，或者你希望你的代码被提供一个上下文，但上游代码还没有提供。</p><p>来看一个使用完成channel模式的例子，并且看看我们可以从切换到使用context包获得什么好处。<br>这是一个同时打印问候和告别的程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">if</span> err := printGreeting(done); err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Printf(<span class="string">"%v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">if</span> err := printFarewell(done); err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Printf(<span class="string">"%v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printGreeting</span><span class="params">(done &lt;-<span class="keyword">chan</span> any)</span></span> <span class="type">error</span> {</span><br><span class="line">greeting, err := genGreeting(done)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">}</span><br><span class="line">fmt.Printf(<span class="string">"%s world!\n"</span>, greeting)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printFarewell</span><span class="params">(done &lt;-<span class="keyword">chan</span> any)</span></span> <span class="type">error</span> {</span><br><span class="line">farewell, err := genFarewell(done)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">}</span><br><span class="line">fmt.Printf(<span class="string">"%s world!\n"</span>, farewell)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genGreeting</span><span class="params">(done &lt;-<span class="keyword">chan</span> any)</span></span> (<span class="type">string</span>, <span class="type">error</span>) {</span><br><span class="line"><span class="keyword">switch</span> locale, err := locale(done); {</span><br><span class="line"><span class="keyword">case</span> err != <span class="literal">nil</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line"><span class="keyword">case</span> locale == <span class="string">"EN/US"</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"hello"</span>, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"unsupported locale"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genFarewell</span><span class="params">(done &lt;-<span class="keyword">chan</span> any)</span></span> (<span class="type">string</span>, <span class="type">error</span>) {</span><br><span class="line"><span class="keyword">switch</span> locale, err := locale(done); {</span><br><span class="line"><span class="keyword">case</span> err != <span class="literal">nil</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line"><span class="keyword">case</span> locale == <span class="string">"EN/US"</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"goodbye"</span>, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"unsupported locale"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">locale</span><span class="params">(done &lt;-<span class="keyword">chan</span> any)</span></span> (<span class="type">string</span>, <span class="type">error</span>) {</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"canceled"</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Minute):</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="string">"EN/US"</span>, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">goodbye world!</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p>忽略竞争条件（我们可以在收到问好之前接收到我们的告别！），我们可以看到我们的程序有两个分支同时运行。<br>我们通过创建完成通道并将其传递给我们的调用图来设置标准抢占方法。如果我们在main的任何一点关闭完成的频道，那么两个分支都将被取消。<br>通过引入goroutine,我们已经开辟了以几种不同且有趣的方式来控制该程序的可能性。</p><p>在每个堆栈框架中，一个函数可以影响其下的整个调用堆栈。<br>使用done channel模式，我们可以通过将传入的done channel包装到其他done channel中，然后在其中任何一个通道启动时返回，<br>但我们不会获得关于Context给我们的最后期限和错误的额外信息。<br>下面是使用context包实现的（设置 genGreeting 在放弃调用 locale 之前等待1s，超时时间为1s。并且如果 genGreeting 不成功，也会取消 printFarewall 的调用）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">if</span> err := printGreeting(ctx); err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Printf(<span class="string">"cannot print greeting: %v\n"</span>, err)</span><br><span class="line">cancel()</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">if</span> err := printFarewell(ctx); err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Printf(<span class="string">"cannot print farewell: %v\n"</span>, err)</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printGreeting</span><span class="params">(ctx context.Context)</span></span> <span class="type">error</span> {</span><br><span class="line">greeting, err := genGreeting(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">}</span><br><span class="line">fmt.Printf(<span class="string">"%s world!\n"</span>, greeting)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printFarewell</span><span class="params">(ctx context.Context)</span></span> <span class="type">error</span> {</span><br><span class="line">farewell, err := genFarewell(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">}</span><br><span class="line">fmt.Printf(<span class="string">"%s world!\n"</span>, farewell)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genGreeting</span><span class="params">(ctx context.Context)</span></span> (<span class="type">string</span>, <span class="type">error</span>) {</span><br><span class="line">ctx, cancel := context.WithTimeout(ctx, <span class="number">1</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> locale, err := locale(ctx); {</span><br><span class="line"><span class="keyword">case</span> err != <span class="literal">nil</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line"><span class="keyword">case</span> locale == <span class="string">"EN/US"</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"hello"</span>, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"unsupported locale"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genFarewell</span><span class="params">(ctx context.Context)</span></span> (<span class="type">string</span>, <span class="type">error</span>) {</span><br><span class="line"><span class="keyword">switch</span> locale, err := locale(ctx); {</span><br><span class="line"><span class="keyword">case</span> err != <span class="literal">nil</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line"><span class="keyword">case</span> locale == <span class="string">"EN/US"</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"goodbye"</span>, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"unsupported locale"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">locale</span><span class="params">(ctx context.Context)</span></span> (<span class="type">string</span>, <span class="type">error</span>) {</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, ctx.Err()</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Minute):</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="string">"EN/US"</span>, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cannot print greeting: context deadline exceeded</span><br><span class="line">cannot print farewell: context canceled</span><br></pre></td></tr></table></figure><p>genGreeting构建自定义的Context.Context以满足其需求，而不必影响父级的context。<br>如果genGreeting成功返回，并且printGreeting需要再次调用，则可以在不泄漏有关genGreeting如何操作的信息的情况下进行。<br>这种可组合性使你能够编写大型系统，而无需在整个调用图中混淆问题。</p><p>我们可以对这个程序进行另一个改进：因为我们知道loca1e需要大约一分钟的时间来运行，所以我们可以检查是否给了我们最后期限，如果是的话，我们是否会遇到它。<br>即使用context.Context的Deadline方法（在locale上增加截止时间的判断）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">if</span> err := printGreeting(ctx); err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Printf(<span class="string">"cannot print greeting: %v\n"</span>, err)</span><br><span class="line">cancel()</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">if</span> err := printFarewell(ctx); err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Printf(<span class="string">"cannot print farewell: %v\n"</span>, err)</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printGreeting</span><span class="params">(ctx context.Context)</span></span> <span class="type">error</span> {</span><br><span class="line">greeting, err := genGreeting(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">}</span><br><span class="line">fmt.Printf(<span class="string">"%s world!\n"</span>, greeting)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printFarewell</span><span class="params">(ctx context.Context)</span></span> <span class="type">error</span> {</span><br><span class="line">farewell, err := genFarewell(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">}</span><br><span class="line">fmt.Printf(<span class="string">"%s world!\n"</span>, farewell)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genGreeting</span><span class="params">(ctx context.Context)</span></span> (<span class="type">string</span>, <span class="type">error</span>) {</span><br><span class="line">ctx, cancel := context.WithTimeout(ctx, <span class="number">1</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> locale, err := locale(ctx); {</span><br><span class="line"><span class="keyword">case</span> err != <span class="literal">nil</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line"><span class="keyword">case</span> locale == <span class="string">"EN/US"</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"hello"</span>, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"unsupported locale"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genFarewell</span><span class="params">(ctx context.Context)</span></span> (<span class="type">string</span>, <span class="type">error</span>) {</span><br><span class="line"><span class="keyword">switch</span> locale, err := locale(ctx); {</span><br><span class="line"><span class="keyword">case</span> err != <span class="literal">nil</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line"><span class="keyword">case</span> locale == <span class="string">"EN/US"</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"goodbye"</span>, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"unsupported locale"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">locale</span><span class="params">(ctx context.Context)</span></span> (<span class="type">string</span>, <span class="type">error</span>) {</span><br><span class="line"><span class="keyword">if</span> deadline, ok := ctx.Deadline(); ok {</span><br><span class="line"><span class="keyword">if</span> time.Now().Add(<span class="number">1</span> * time.Minute).After(deadline) {</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, context.DeadlineExceeded</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, ctx.Err()</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Minute):</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="string">"EN/US"</span>, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>虽然这个更改差异很小，但它允许 locale 函数快速失败。在调用成本很高的程序中，可能会节省大量资源和时间，它允许立即失败，而不必等待实际的超时发生。<br>但现实中实践起来非常困难，因为必须要知道下级调用需要多长时间。</p><p>最后来介绍用于存储和检索请求范围数据的Context的数据包。<br>请记住，当一个函数创建一个goroutine和Context时，它通常会启动一个将为请求提供服务的goroutine,并且进一步向下的函数可能需要有关请求的信息。<br>以下是如何在上下文中存储数据以及如何检索数据的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">ProcessRequest(<span class="string">"jane"</span>, <span class="string">"abc123"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProcessRequest</span><span class="params">(userID, authToken <span class="type">string</span>)</span></span> {</span><br><span class="line">ctx := context.WithValue(context.Background(), <span class="string">"userID"</span>, userID)</span><br><span class="line">ctx = context.WithValue(ctx, <span class="string">"authToken"</span>, authToken)</span><br><span class="line">HandleResponse(ctx)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleResponse</span><span class="params">(ctx context.Context)</span></span> {</span><br><span class="line">fmt.Printf(</span><br><span class="line"><span class="string">"handling response for %v (%v)"</span>,</span><br><span class="line">ctx.Value(<span class="string">"userID"</span>),</span><br><span class="line">ctx.Value(<span class="string">"authToken"</span>),</span><br><span class="line">)</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>输出如下：<code>handling response for jane (abc123)</code></p><p>很简单的东西。唯一的限制条件是：</p><ul><li>键值必须满足Go语言的可比性概念，也就是运算符<code>==</code>和<code>!=</code>在使用时需要返回正确的结果。</li><li>返回值必须安全，才能从多个goroutine访问。</li></ul><p><strong>由于Context的键和值都被定义为<code>interface{}</code>,所以当试图检索值时，我们会失去Go语言的类型安全性。</strong><br>key可以是不同的类型，或者与我们提供的key略有不同。值可能与我们预期的不同。<br>出于这些原因，Go语言作者建议你在从Context中存储和检索值时遵循一些规则。<br>首先，他们建议你<strong>在软件包中定义一个自定义键类型。只要其他软件包执行相同的操作，则可以防止上下文中的冲突。</strong><br>作为一个提醒，为什么让我们看看一个简短的程序，试图将键存储在具有不同类型的映射中，但具有相同的基础值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> foo <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> bar <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[any]<span class="type">int</span>)</span><br><span class="line">m[foo(<span class="number">1</span>)] = <span class="number">1</span></span><br><span class="line">m[bar(<span class="number">1</span>)] = <span class="number">2</span></span><br><span class="line">fmt.Printf(<span class="string">"%v"</span>, m)</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>输出如下：<code>map[1:2 1:1]</code></p><p>虽然基础值是相同的，但不同的类型信息在map中区分它们。</p><p>同时由于我们不应该导出存储数据的key，所以必须导出检索数据的函数。允许这些数据使用者使用静态的、类型安全的函数。<br>最佳实践：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">ProcessRequest(<span class="string">"jane"</span>, <span class="string">"abc123"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ctxKey <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">ctxUserId ctxKey = <span class="literal">iota</span></span><br><span class="line">ctxAuthToken</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserId</span><span class="params">(c context.Context)</span></span> <span class="type">string</span> {</span><br><span class="line"><span class="keyword">return</span> c.Value(ctxUserId).(<span class="type">string</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthToken</span><span class="params">(c context.Context)</span></span> <span class="type">string</span> {</span><br><span class="line"><span class="keyword">return</span> c.Value(ctxAuthToken).(<span class="type">string</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProcessRequest</span><span class="params">(userID, authToken <span class="type">string</span>)</span></span> {</span><br><span class="line">ctx := context.WithValue(context.Background(), ctxUserId, userID)</span><br><span class="line">ctx = context.WithValue(ctx, ctxAuthToken, authToken)</span><br><span class="line">HandleResponse(ctx)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleResponse</span><span class="params">(ctx context.Context)</span></span> {</span><br><span class="line">fmt.Printf(</span><br><span class="line"><span class="string">"handling response for %v (%v)"</span>,</span><br><span class="line">UserId(ctx),</span><br><span class="line">AuthToken(ctx),</span><br><span class="line">)</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>运行结果：<code>handling response for jane (abc123)</code></p><p>现在有一种类型安全的函数来从context获取值，如果消费者在不同的包中，他们不会知道或关心用于存储信息的ky。<br>但是，这种技术确实会造成问题。（循环依赖）<br>在前面的例子里，假如 ProcessRequest 在 process 包中、HandleResponse 在 response 包中。<br>process 包需要导入 response 包，调用函数。而 context 的 key 定义在 process 包中，response 包需要导入 process 包。<br>会造成循环依赖。</p><p>这会迫使体系结构设计时，将所有导入的数据类型放在一个包中。这也许是件好事。</p><p>关于 context 中存储什么样的数据是有争议的，因为它可以存储任意数据，并且类型不安全会引发错误。</p><p>关于什么是适当的、最普遍的指导，下面是上下文包中的下面有点含糊的注释：</p><blockquote><p>仅将上下文值用于传输进程和请求的请求范围数据，API边界，而不是将可选参数传递给函数。</p></blockquote><p>下面是启发式的建议：</p><ol><li>数据应该通过进程或API边界。<br>数据应该用于在进程之间或API 边界传递请求范围的信息（如用户身份、请求 ID、跟踪信息等）。</li><li>数据应该是不可变的<br>如果不是，那么它就不再是请求范围的数据，而是可能被任意修改的共享状态。</li><li>数据应趋向简单类型。<br>数据应该是简单的类型（如 string、int、bool 等），而不是复杂的结构体或对象。</li><li>数据应该是数据，而不是类型与方法。<br>数据应该是纯粹的数据（如 userID、requestID 等），而不是包含方法或行为的类型。</li><li>数据应该有助于修饰操作，而不是驱动它们。<br>数据应该用于修饰操作（如提供额外的上下文信息），而不是驱动操作（如控制算法的行为）。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第四章-Go语言的并发模式&quot;&gt;&lt;a href=&quot;#第四章-Go语言的并发模式&quot; class=&quot;headerlink&quot; title=&quot;第四章 - Go语言的并发模式&quot;&gt;&lt;/a&gt;第四章 - Go语言的并发模式&lt;/h2&gt;&lt;p&gt;前面讲了Go语言的并发原语的基本原理，这章要</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://cooooing.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="go" scheme="https://cooooing.github.io/tags/go/"/>
    
    <category term="并发" scheme="https://cooooing.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="《go语言并发之道》" scheme="https://cooooing.github.io/tags/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%81%93%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《go语言并发之道》读书笔记-并发组件</title>
    <link href="https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%B9%B6%E5%8F%91%E7%BB%84%E4%BB%B6/"/>
    <id>https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%B9%B6%E5%8F%91%E7%BB%84%E4%BB%B6/</id>
    <published>2025-01-14T02:35:39.000Z</published>
    <updated>2025-01-14T02:35:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第三章-Go语言并发组件"><a href="#第三章-Go语言并发组件" class="headerlink" title="第三章 - Go语言并发组件"></a>第三章 - Go语言并发组件</h2><p>这章介绍Go中的特性，以及它如何支持并发。（终于到实际使用了</p><h3 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h3><p>goroutine是Go语言程序中最基本的组织单位之一。<br>每个Go语言程序都至少有一个goroutine:main goroutine，它在进程开始时自动创建并启动。<br>几乎在所有的项目中，你迟早会使用goroutine来解决Go语言编程遇到的问题。所以，它们是什么？</p><p>简单地说，goroutine是一个并发的函数（记住：不一定是并行的），与其他代码一起运行。<br>你可以简单地在一个函数之前添加go关键字来触发：<code>go sum()</code><br>同样可以作为匿名函数使用！这里有一个例子和前面的例子一样。<br>然而，我们不是创建一个基于函数的goroutine,而是创建一个基于匿名函数 goroutine:<code>go func() { // ... }()</code></p><p>下面的内容来看看 goroutine 是如何工作的？它们是OS线程吗？绿色线程？我们能创造多少个 goroutine？</p><p>Go语言中的goroutine是独一无二的（尽管其他的一些语言有类似的并发原语)。<br>它们不是OS线程，也不是绿色线程（由语言运行时管理的线程），它们是一个更高级别的抽象，称为协程。<br><strong>协程是一种非抢占式的简单并发子goroutine(函数、闭包或方法)，也就是说，它们不能被中断。</strong> 取而代之的是，协程有多个点，允许暂停或重新进入。</p><p>goroutine的独特之处在于它们与Go语言的运行时的深度集成。goroutine没有定义自己的暂停方法或再运行点。<br><strong>Go语言的运行时会观察goroutine的运行时行为，并在它们阻塞时自动挂起它们，然后在它们不被阻塞时恢复它们。</strong><br><strong>在某种程度上，这使它们成为可抢占的，但只是在goroutine被阻塞的情况。</strong> 在运行时和goroutine的逻辑之间，是一种优雅的伙伴关系。<br>因此，goroutine可以被认为是一种特殊类型的协程。</p><p>协程和goroutine都是隐式并发结构，但并发并不是协程的属性：必须同时托管多个协程，并给每个协程一个执行的机会。否则，它们就不会并发！<br>请注意，这并不意味着协程是隐式并行的。当然有可能有几个协程按顺序并行执行的假象，事实上，这种情况一直在发生。</p><p>Go语言的主机托管机制是一个名为M:N调度器的实现，这意味着它将M个绿色线程映射到N个OS线程。然后将goroutine安排在绿色线程上。<br>当我们的goroutine数量超过可用的绿色线程时，调度程序将处理分布在可用线程上的goroutine,并确保当这些goroutine被阻塞时，其他的goroutine可以运行。<br>这里只介绍Go语言的并发模型，细节在后续章节中。</p><p>Go语言遵循一个称为ork-join的并发模型。<br>fork这个词指的是在程序中的任意一点，它可以将执行的子分支与共父节点同时运行。<br>jon这个词指的是，在将来某个时候，这些并发的执行分支将会合并在一起。<br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%B9%B6%E5%8F%91%E7%BB%84%E4%BB%B6/fork-join%E7%A4%BA%E6%84%8F%E5%9B%BE.png"                        alt="img.png"                 ></p><p>Go语言是如何执行fork的，执行的子线程是goroutine。<br>让我们回到简单的goroutine例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sayHello := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> sayHello()</span><br><span class="line"><span class="comment">//继续执行自己的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，sayHello函数将在goroutine上运行，而程序的其余部分将继续执行。<br>在本例中，没有join点。执行sayHello的goroutine将在未来的某个不确定的时间退出，而程序的其余部分将会继续执行。</p><p>但是，这个例子有一个问题：正如上面所写的程序，它不确定sayHello函数是否会运行。<br>goroutine将会被创建，并计划在Go语言运行时执行，但是它实际上可能没有机会在main goroutine退出之前运行。</p><p>实际上，因为我们省略了min函数的其余部分，为了简单起见，当运行这个小示例时，几乎可以肯定的是，程序将在goroutine被系统调用之前完成执行。<br>因此，你不会看到“hello’”这个词被打印到stdout。你可以在创建goroutine之后执行time.Sleep,但是要记住，这实际上并没有创建一个join点，只有一个竞争条件。<br>如果回顾第1章，你增加了goroutine在程序退出前执行的概率，但你并不能保证一定会执行。<strong>join点是保证程序正确性和消除竞争条件的关键。</strong></p><p>为了创建一个join点，你必须同步main goroutine和sayHello goroutine。<br>这可以通过多种方式实现，这里使用：sync.Waitgroup。<br>下面是一个正确的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">sayHello := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> sayHello()</span><br><span class="line">wg.Wait() <span class="comment">// 这就是连接点的使用方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下： <code>hello</code></p><p>这个例子将决定main goroutine,直到goroutine托管sayHello函数为止。<br>我们在示例中使用了许多匿名函数来创建快速goroutine样例。让我们把注意力转移到闭包上。<br>闭包可以从创建它们的作用域中获取变量。如果你在goroutine中运行一个闭包，那么闭包是在这些变量的副本上运行，还是原值的引用上运行？<br>让我们试试看：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">salutation := <span class="string">&quot;hello&quot;</span></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">salutation = <span class="string">&quot;welcome&quot;</span> <span class="comment">// 尝试修改 salutation 变量</span></span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(salutation)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<code>welcome</code><br>事实证明，goroutine在它们所创建的相同地址空间内执行，因此我们的程序打印出“welcome”这个词。<br>让我们再看一个例子。你认为这个程序会输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> _, salutation := <span class="keyword">range</span> []<span class="type">string</span>&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;greetings&quot;</span>, <span class="string">&quot;good day&quot;</span>&#125; &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Println(salutation) <span class="comment">// 引用了字符串类型的切片作为创建循环变量的salutation值</span></span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案比大多数人想象的要复杂得多，而且是为数不多的令人惊讶的事情之一。<br>大多数人直觉上认为这将会不确定顺序地打印出“hello”“greetings”和“good day”,但看看它做了什么：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">good day</span><br><span class="line">good day</span><br><span class="line">good day</span><br></pre></td></tr></table></figure><p>这里真的是这样吗？在我电脑上的输出是符合大多数人的直觉的：会以不确定的顺序打印出“hello”“greetings”和“good day”。<br>为什么呢？查了资料后发现，这是循环迭代器变量引用的问题：<a class="link"   href="https://go.dev/wiki/CommonMistakes" >常见错误<i class="fas fa-external-link-alt"></i></a> <a class="link"   href="https://go.dev/ref/spec#For_statements" >For 语句<i class="fas fa-external-link-alt"></i></a><br>在1.22及后不会出现循环迭代器变量引用的问题。每个循环迭代器变量都是一个新的副本，所以上面程序的输出会是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">greetings</span><br><span class="line">good day</span><br></pre></td></tr></table></figure><p>并且是乱序的（每次输出都不一致），下面的讨论在1.22之前，1.22及后不会出现。<br>在上面的示例中，goroutine正在运行一个闭包，<strong>该闭包使用变量salutation时，字符串的迭代已经结束。</strong><br>当我们循环迭代时，salutation被分配到slice literal中的下一个字符串值。因为计划中的goroutine可能在未来的任何时间点运行，它不确定在goroutine中会打印出什么值。<br>在性能比较好的机器上，在goroutine开始之前循环有很高的概率会退出。这意味着变量的salutation值不在范围之内。然后会发生什么呢？<br>goroutine还能引用一些已经超出范围的东西吗？goroutine不会访问那些可能被垃圾回收的内存吗？<br>这是一个关于如何管理内存的有趣的点。Go语言运行时会足够小心地将对变量salutation值的引用仍然保留，由内存转移到堆，以便goroutine可以继续访问它。</p><p>通常在我的计算机上，在任何goroutine开始运行之前，循环就会退出，所以salutation会被转移到堆中，在我的字符串切片中引用最后一个值“good day”。<br>所以我通常会看到三次“good day”。编写这个循环的正确方法是将salutation的副本传递到闭包中，这样当goroutine运行时，它将从循环的迭代中操作数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> _, salutations := <span class="keyword">range</span> []<span class="type">string</span>&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;greetings&quot;</span>, <span class="string">&quot;good day&quot;</span>&#125; &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(salutations <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Println(salutations)</span><br><span class="line">&#125;(salutations)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，在1.22及以后的版本是不需要这么写的。</p><p>这些goroutine在相同的地址空间中运行，并且只有简单的宿主函数，所有使用goroutine编写非并发代码是非常自然的。<br>Go语言的编译器很好地处理了内存中的变量，这样goroutine就不会意外地访问被释放的内存，这使得开发人员可以专注于他们的问题空间而不是内存管理。<br>然而，这不是一张空白支票。</p><p>由于多个goroutine可以在同一个地址空间上运行，所以我们仍然需要担心同步问题。<br>正如我们已经讨论过的，我们可以选择同步访问goroutine访问的共享内存，或者可以使用CSP原语通过通信来共享内存。</p><p>goroutine的另一个好处是它们非常轻。下面是“Go语言FAQ”的摘录：</p><blockquote><p>一个新创建的goroutine被赋予了几千字节，这在大部分情况都是足够的。<br>当它不运行时，Go语言运行时就会自动增长（缩小）存储堆栈的内存，允许许多goroutine存在适当的内存中。<br>每个函数调用CPU的开销平均为3个廉价指令。在同一个地址空间中创建成千上万的goroutine是可行的。如果goroutine只是线程，系统的资源消耗会更小。</p></blockquote><p>每个goroutine几千字节，这并没有什么问题！让我们来验证一下。<br>但是在我们开始之前，我们必须讨论一个关于goroutine有趣的事情：<br><strong>GC并没有回收被丢弃的goroutine。</strong><br>如果我写如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//将永远阻塞的操作</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">//开始工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的goroutine将一直存在直到进程退出（<strong>协程泄露！</strong>）。在下一个例子中，我们将利用这一点来实际测算goroutine的大小。</p><p>在下面的例子中，我们将goroutine不被GC的事实与运行时的自省能力结合起来，并测算在goroutine创建之前和之后分配的内存数量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">memConsumed := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">uint64</span> &#123;</span><br><span class="line">runtime.GC()</span><br><span class="line"><span class="keyword">var</span> s runtime.MemStats</span><br><span class="line">runtime.ReadMemStats(&amp;s)</span><br><span class="line"><span class="keyword">return</span> s.Sys</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c &lt;-<span class="keyword">chan</span> any</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">noop := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; wg.Done(); &lt;-c &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numGoroutines = <span class="number">1e6</span></span><br><span class="line">wg.Add(numGoroutines)</span><br><span class="line">before := memConsumed()</span><br><span class="line"><span class="keyword">for</span> i := numGoroutines; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line"><span class="keyword">go</span> noop()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">after := memConsumed()</span><br><span class="line">fmt.Printf(<span class="string">&quot;%fkb&quot;</span>, <span class="type">float64</span>(after-before)/numGoroutines/<span class="number">1024</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要一个永远不会退出的goroutine.,这样就可以在内存中保留一段时间用于测侧算。<br>定义了要创建的goroutine的数量。我们将用大数定律，渐渐地接近一个goroutine的大小。<br>输出结果为：<code>8.560508kb</code>，这里go版本为1.22.4。老版本goroutine的大小会更小。</p><p>理论上百万个goroutine内存占用只有9G。这也足以说明goroutine的轻量。<br><strong>可能会影响性能的是上下文切换，即当一个被托管的并发进程必须保存它的状态以切换到一个不同的运行并发进程时。</strong><br>如果我们有太多的并发进程，可能会将所有的CPU时间消耗在它们之间的上下文切换上，而没有资源完成任何真正需要CPU的工作。<br>在操作系统级别，使用线程可能非常昂贵。OS线程必须保存如寄存器值、查找表和内存映射之类的东西，以便能够在有限的时间内成功地切换回当前线程。<br>然后，它必须为传入的线程加载相同的信息。</p><p>软件中的上下文切换相对来说要廉价得多。<br>在一个软件定义的调度器下，运行时可以更有选择性地保存数据用于检索，如何持久化，以及何时需要持久化。<br>让我们来看看在OS线程和goroutine之间切换的上下文的相对性能。<br>首先，我们将利用Linux的内置基准测试套件来度量在相同核心的两个线程之间发送消息需要多长时间（需要安装perf工具，需要与内核版本匹配：<code>sudo apt install linux-tools-common linux-tools-generic</code>）：<br><code>taskset -c 0 perf bench sched pipe -T</code></p><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Running &#x27;sched/pipe&#x27; benchmark:</span><br><span class="line"># Executed 1000000 pipe operations between two threads</span><br><span class="line"></span><br><span class="line">     Total time: 5.855 [sec]</span><br><span class="line"></span><br><span class="line">       5.855618 usecs/op</span><br><span class="line">         170776 ops/sec</span><br></pre></td></tr></table></figure><p>这个基准实际上度量了在线程上发送和接收消息所需的时间，因此我们将计算结果并将其除以2。<br>我们用了<code>2.927μs</code>来进行上下文切换。这看起来不算太糟，但还是保留判断，直到我们检查goroutine之间的上下文切换。</p><p>我们将使用Go语言构建一个类似的基准。下面的示例将创建两个goroutine并在它们之间发送一条消息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkContextSwitch</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">begin := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">var</span> token <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">sender := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">&lt;-begin</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">c &lt;- token</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">receiver := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">&lt;-begin</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">&lt;-c</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> sender()</span><br><span class="line"><span class="keyword">go</span> receiver()</span><br><span class="line">b.StartTimer()</span><br><span class="line"><span class="built_in">close</span>(begin)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果（<code>go test -bench=. -cpu=1</code>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkContextSwitch   6329348        218.8 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok   learn 1.582s</span><br></pre></td></tr></table></figure><p>每个上下文切换需要<code>218.8ns</code>，2.927μs的7.48%<br>很难断言goroutine会导致上下文切换过于频繁，但上限可能不会成为使用goroutine的阻碍。</p><h3 id="sync包"><a href="#sync包" class="headerlink" title="sync包"></a>sync包</h3><p><strong>sync包包含对低级别内存访问同步最有用的并发原语</strong>。<br>如果你使用的语言主要通过内存访问同步来处理并发，那么你可能已经熟悉了这些类型。<br>Go语言和这些语言之间的区别在于，Go语言已经在内存访问同步原语之上构建了一组新的并发原语，以向你提供一组扩展的工作。<br>正如我们在第2章“Go语言的并发哲学”中所讨论的，这些操作都有它们的用途，主要是在诸如struct这样的小范围内。由你决定何时进行内存访问同步。<br>说到这里，让我们开始看一下sync包公开的各种原语。</p><h4 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h4><p>当你不关心并发操作的结果，或者你有其他方法来收集它们的结果时，WaitGroup是等待一组并发操作完成的好方法。<br>如果这两个条件都不满足，我建议你使用channel和select语句。<br>下面是一个使用WaitGroup等待goroutine完成的基本例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Println(<span class="string">&quot;1st goroutine sleeping...&quot;</span>)</span><br><span class="line">time.Sleep(<span class="number">1</span>)</span><br><span class="line">&#125;()</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Println(<span class="string">&quot;2nd goroutine sleeping...&quot;</span>)</span><br><span class="line">time.Sleep(<span class="number">2</span>)</span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">&quot;All goroutines completed.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2nd goroutine sleeping...</span><br><span class="line">1st goroutine sleeping...</span><br><span class="line">All goroutines completed.</span><br></pre></td></tr></table></figure><p>可以将WaitGroup视为一个并发-安全的计数器：<strong>调用通过传入的整数执行add方法增加计数器的增量，并调用Done方法对计数器进行递减。Wait阻塞，直到计数器为零。</strong></p><p>注意，添加的Add调用是在他们帮助跟踪的goroutine之外完成的。<br>如果我们不这样做，我们就会引人一种竞争条件，因为在本章前面“goroutines’”中，我们不能保证goroutine何时会被调度，可以在goroutine开始调度前调用Wait方法。<br>如果将调用Add的方法添加到goroutine的闭包中，那么Wait调用可能会直接返回，而且不会阻塞，因为Add调用不会发生。</p><h5 id="互斥锁与读写锁"><a href="#互斥锁与读写锁" class="headerlink" title="互斥锁与读写锁"></a>互斥锁与读写锁</h5><p>Mutex 是“互斥”的意思，是保护程序中临界区的一种方式。<br>临界区是你程序中需要独占访问共享资源的区域。<br>Mutex提供了一种安全的方式来表示对这些共享资源的独占访问。<br>为了使用一个资源，channel通过通信共享内存，而Mutex通过开发人员的约定同步访问共享内存。<br>你可以通过使用Mutex对内存进行保护来协调对内存的访问。<br>这里有一个简单的例子，两个goroutine试图增加和减少一个共同的值，它们使用Mutex互斥锁来同步访问：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line">increment := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">count++</span><br><span class="line">fmt.Printf(<span class="string">&quot;Incrementing: %d\n&quot;</span>, count)</span><br><span class="line">&#125;</span><br><span class="line">decrement := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">count--</span><br><span class="line">fmt.Printf(<span class="string">&quot;Decrementing: %d\n&quot;</span>, count)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 增量</span></span><br><span class="line"><span class="keyword">var</span> arithmetic sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">arithmetic.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> arithmetic.Done()</span><br><span class="line">increment()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 减量</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">arithmetic.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> arithmetic.Done()</span><br><span class="line">decrement()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">arithmetic.Wait()</span><br><span class="line">fmt.Println(<span class="string">&quot;Arithmetic complete.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Incrementing: 1</span><br><span class="line">Decrementing: 0</span><br><span class="line">Decrementing: -1</span><br><span class="line">Incrementing: 0</span><br><span class="line">Decrementing: -1</span><br><span class="line">Decrementing: -2</span><br><span class="line">Incrementing: -1</span><br><span class="line">Incrementing: 0</span><br><span class="line">Arithmetic complete.</span><br></pre></td></tr></table></figure><p>你会注意到，<strong>我们总是在defer语句中调用Unlock。这是一个十分常见的习惯用法，它使用Mutex互斥锁来确保即使出现了panic,调用也总是发生。如果不这样做，可能会导致程序陷人死锁。</strong><br>关键部分之所以如此命名，是因为它们反映了程序中的瓶颈。进入和退出一个临界区是有消耗的，所以一般人会尽量减少在临界区的时间。<br>这样做的一个策略是减少临界区的范围。可能存在需要在多个并发进程之间共享内存的情况，但可能这些进程不是都需要读写此内存。<br>如果是这样，你可以利用不同类型的互斥对象：sync.RWMutex。</p><p>Sync.RWMutex在概念上和互斥是一样的：它守卫着对内存的访问，然而，RWMutex让你对内存有了更多控制。<br>你可以请求一个锁用于读处理，在这种情况下你将被授予访问权限，除非该锁被用于写处理。<br>这意味着，任意数量的读消费者可以持有一个读锁，只要没有共他事物持有一个写锁。<br>这里有一个例子，它演示了一个生产者，它不像代码中创建的众多消费者那样活跃：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;text/tabwriter&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">producer := <span class="function"><span class="keyword">func</span><span class="params">(wg *sync.WaitGroup, l sync.Locker)</span></span> &#123; <span class="comment">// 第二个参数是 sync.Locker 类型。这个接口有两个方法，Lock和Unlock。go包中有两个实现，sync.Mutex和sync.RWMutex。</span></span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">5</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">l.Lock()</span><br><span class="line">l.Unlock()</span><br><span class="line">time.Sleep(<span class="number">1</span>) <span class="comment">// 让 producer 等待，使其比观察者的 goroutine 更不活跃。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">observer := <span class="function"><span class="keyword">func</span><span class="params">(wg *sync.WaitGroup, l sync.Locker)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">l.Lock()</span><br><span class="line"><span class="keyword">defer</span> l.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">test := <span class="function"><span class="keyword">func</span><span class="params">(count <span class="type">int</span>, mutex, rwMutex sync.Locker)</span></span> time.Duration &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(count + <span class="number">1</span>)</span><br><span class="line">beginTestTime := time.Now()</span><br><span class="line"><span class="keyword">go</span> producer(&amp;wg, mutex)</span><br><span class="line"><span class="keyword">for</span> i := count; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line"><span class="keyword">go</span> observer(&amp;wg, rwMutex)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="keyword">return</span> time.Since(beginTestTime)</span><br><span class="line">&#125;</span><br><span class="line">tw := tabwriter.NewWriter(os.Stdout, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">defer</span> tw.Flush()</span><br><span class="line"><span class="keyword">var</span> m sync.RWMutex</span><br><span class="line">fmt.Fprintf(tw, <span class="string">&quot;Readers\tRWMutext\tMutex\n&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">count := <span class="type">int</span>(math.Pow(<span class="number">2</span>, <span class="type">float64</span>(i)))</span><br><span class="line">fmt.Fprintf(</span><br><span class="line">tw,</span><br><span class="line"><span class="string">&quot;%d\t%v\t%v\n&quot;</span>,</span><br><span class="line">count,</span><br><span class="line">test(count, &amp;m, m.RLocker()),</span><br><span class="line">test(count, &amp;m, &amp;m),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Readers  RWMutext    Mutex</span><br><span class="line">1        76.0748ms   78.666ms</span><br><span class="line">2        77.9551ms   77.8809ms</span><br><span class="line">4        78.9414ms   77.7889ms</span><br><span class="line">8        61.973ms    78.1634ms</span><br><span class="line">16       77.1572ms   61.3356ms</span><br><span class="line">32       62.9075ms   77.792ms</span><br><span class="line">64       61.6918ms   76.5042ms</span><br><span class="line">128      61.6087ms   77.0605ms</span><br><span class="line">256      62.1438ms   77.894ms</span><br><span class="line">512      62.8352ms   46.7669ms</span><br><span class="line">1024     46.7329ms   47.4825ms</span><br><span class="line">2048     46.5684ms   31.1086ms</span><br><span class="line">4096     47.5138ms   62.2136ms</span><br><span class="line">8192     7.0075ms    38.8685ms</span><br><span class="line">16384    12.4982ms   4.732ms</span><br><span class="line">32768    6.505ms     8.7366ms</span><br><span class="line">65536    14.3337ms   16.2156ms</span><br><span class="line">131072   32.3444ms   35.852ms</span><br><span class="line">262144   58.6523ms   71.3403ms</span><br><span class="line">524288   117.7048ms  147.1611ms</span><br></pre></td></tr></table></figure><h4 id="cond"><a href="#cond" class="headerlink" title="cond"></a>cond</h4><p>对于cond类型的注释确实很好地描述了它的用途：</p><blockquote><p>…一个goroutine的集合点，等待或发布一个event。</p></blockquote><p>在这个定义中，一个“event”是两个或两个以上的goroutine之间的任意信号，除了它已经发生的事实外，没有任何信息。<br>通常情况下，在goroutine继续执行之前，你需要等待其中一个信号。如果我们要研究如何在没有Cond类型的情况下实现这一目标，一个简单的方法就是使用无限循环：<code>for conditionTrue() == false {}</code><br>然而，这将消耗一个CPU核心的所有周期。为了解决这个问题，我们可以引入一个time.Sleep：<code>for conditionTrue() == false { time.Sleep(1*time.Millisecond) }</code><br>这样更好，但它仍然是低效的，而且你必须弄清楚要等待多久：太长，会人为地降低性能：太短，会不必要地消耗太多的CPU时间。<br>如果有一种方法可以让goroutine有效地等待，直到它发出信号并检查它的状态，那就更好了。<br>这正是Cond类型为我们所做的。使用Cond,我们可以这样编写前面例子的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := sync.NewCond(&amp;sync.Mutex&#123;&#125;) <span class="comment">// 实例化一个cond。NewCond函数创建一个类型，满足sync.Locker接口。这使得cond类型能够以一种并发安全的方式与其他goroutine协调</span></span><br><span class="line">c.L.Lock()                       <span class="comment">// 锁定这个条件。这是必要的，因为在进入Locker的时候，执行wait会自动执行unlock。</span></span><br><span class="line"><span class="keyword">for</span> conditionTrue() == <span class="literal">false</span> &#123;</span><br><span class="line">c.Wait() <span class="comment">// 等待通知，条件已经发生。这是一个阻塞通信，goroutine将被暂停。</span></span><br><span class="line">&#125;</span><br><span class="line">c.L.Unlock() <span class="comment">// 为这个条件Locker执行解锁操作。这是必要的，因为当执行Wait退出操作的时候，它会在Locker上调用Lock方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法效率更高。注意，调用Wait不只是阻塞，它挂起了当前的goroutine,允许其他goroutine在OS线程上运行。<br>当你调用Wait时，会发生一些其他事情：<strong>进入Wait后，在Cond变量的Locker上调用Unlock方法，在退出Wait时，在Cond变量的Locker上执行Lock方法。</strong><br>它实际上是方法的一个隐藏的副作用。看起来我们在等待条件发生的时候一直持有这个锁，但事实并非如此。当你浏览代码时，你需要留意这个模式。</p><p>让我们扩展这个例子，并显示等式的两边：等待信号的goroutine和发送信号的goroutine。<br>假设我们有一个固定长度为2的队列，还有10个我们想要推送到队列中的项目。<br>我们想要在有房间的情况下尽快排队，所以就希望在队列中有空间时能立即得到通知。<br>让我们尝试使用Cond来管理这种调度：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">queue := <span class="built_in">make</span>([]any, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">removeFromQueue := <span class="function"><span class="keyword">func</span><span class="params">(delay time.Duration)</span></span> &#123;</span><br><span class="line">time.Sleep(delay)</span><br><span class="line">c.L.Lock()</span><br><span class="line">queue = queue[<span class="number">1</span>:]</span><br><span class="line">fmt.Println(<span class="string">&quot;Removed from queue&quot;</span>)</span><br><span class="line">c.L.Unlock()</span><br><span class="line">c.Signal()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">c.L.Lock()</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(queue) == <span class="number">2</span> &#123;</span><br><span class="line">c.Wait()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Adding to queue&quot;</span>)</span><br><span class="line">queue = <span class="built_in">append</span>(queue, <span class="keyword">struct</span>&#123;&#125;&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> removeFromQueue(<span class="number">1</span> * time.Second)</span><br><span class="line">c.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Adding to queue</span><br><span class="line">Adding to queue</span><br><span class="line">Removed from queue</span><br><span class="line">Adding to queue</span><br><span class="line">Removed from queue</span><br><span class="line">Adding to queue</span><br><span class="line">Removed from queue</span><br><span class="line">Adding to queue</span><br><span class="line">Removed from queue</span><br><span class="line">Adding to queue</span><br><span class="line">Removed from queue</span><br><span class="line">Removed from queue</span><br><span class="line">Adding to queue</span><br><span class="line">Adding to queue</span><br><span class="line">Removed from queue</span><br><span class="line">Adding to queue</span><br><span class="line">Removed from queue</span><br><span class="line">Adding to queue</span><br></pre></td></tr></table></figure><p>该程序成功地将所有10个项目添加到队列中（并且在它有机会将前两项删除之前退出)。<br>它也总是等待，直到至少有一个项目被排入队列，然后再进行另一个项目。<br>在这个例子中，我们还有一个新方法，Signal。这是Cond类型提供的两种方法中的一种，<strong>它提供通知goroutine阻塞的调用Wait,条件已经被触发。</strong><br>另一种方法叫做Broadcast。运行时内部维护一个FIFO列表，等待接收信号；<strong>Signal发现等待最长时间的goroutine并通知它，而Broadcast向所有等待的goroutine发送信号。</strong><br>Broadcast可以说是这两种方法中比较有趣的一种，因为它提供了一种同时与多个goroutine通信的方法。<br>我们可以通过channel对信号进行简单的复制，但是重复调用Broadcast的行为将会更加困难。<br>此外，与利用channel相比，Cond类型的性能要高很多。</p><p>为了了解使用Broadcast的方法，让我们假设正在创建一个带有按钮的GUI应用程序。我们想注册任意数量的函数，当该按钮被单击时，它将运行。<br>Cond可以完美胜任，因为我们可以使用它的Broadcast方法通知所有注册的处理程序。让我们看看它的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 定义 Button 类型，包含 Clicked 条件</span></span><br><span class="line"><span class="keyword">type</span> Button <span class="keyword">struct</span> &#123;</span><br><span class="line">Clicked *sync.Cond</span><br><span class="line">&#125;</span><br><span class="line">button := Button&#123;Clicked: sync.NewCond(&amp;sync.Mutex&#123;&#125;)&#125;</span><br><span class="line"><span class="comment">// 定义订阅函数，提供注册函数以处理来自条件的信号的功能</span></span><br><span class="line">subscribe := <span class="function"><span class="keyword">func</span><span class="params">(c *sync.Cond, fn <span class="keyword">func</span>()</span></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> goroutineRunning sync.WaitGroup</span><br><span class="line">goroutineRunning.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">goroutineRunning.Done()</span><br><span class="line">c.L.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.L.Unlock()</span><br><span class="line">c.Wait()</span><br><span class="line">fn()</span><br><span class="line">&#125;()</span><br><span class="line">goroutineRunning.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> clickRegistered sync.WaitGroup</span><br><span class="line">clickRegistered.Add(<span class="number">3</span>)</span><br><span class="line">subscribe(button.Clicked, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Maximizing window.&quot;</span>)</span><br><span class="line">clickRegistered.Done()</span><br><span class="line">&#125;)</span><br><span class="line">subscribe(button.Clicked, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Displaying annoying dialog box!&quot;</span>)</span><br><span class="line">clickRegistered.Done()</span><br><span class="line">&#125;)</span><br><span class="line">subscribe(button.Clicked, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Mouse clicked.&quot;</span>)</span><br><span class="line">clickRegistered.Done()</span><br><span class="line">&#125;)</span><br><span class="line">button.Clicked.Broadcast()</span><br><span class="line">clickRegistered.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mouse clicked.</span><br><span class="line">Maximizing window.</span><br><span class="line">Displaying annoying dialog box!</span><br></pre></td></tr></table></figure><p>可以看到，在 Click Cond 上调用 Broadcast ，所有三个处理程序都将运行。<br>如果不是 clickRegistered 的 WaitGroup,我们可以调用button.Clicked.Broadcast()多次，并且.每次都调用三个处理程序。<br>这是channel不太容易做到的，因此是利用Cond类型的主要原因之一。</p><p>与sync包中所包含的大多数其他东西一样，Cond的使用最好被限制在一个紧凑的范围中，或者是通过封装它的类型来暴露在更大范围内。</p><h4 id="once"><a href="#once" class="headerlink" title="once"></a>once</h4><p>once 比较简单，顾名思义：只会被执行一次。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line">increment := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">count++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"><span class="keyword">var</span> increments sync.WaitGroup</span><br><span class="line">increments.Add(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> increments.Done()</span><br><span class="line">once.Do(increment)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">increments.Wait()</span><br><span class="line">fmt.Printf(<span class="string">&quot;Count is %d\n&quot;</span>, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：<code>Count is 1</code></p><p>sync.Once是一种类型，它在内部使用一些sync原语，以确保即使在不同的goroutine上，也只会调用一次Do方法处理传递进来的函数。<br>这确实是因为我们将调用sync.Once方式执行Do方法。</p><p>使用sync.Once有几件事需要注意。让我们看另一个例子，你认为它会打印什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line">increment := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; count++ &#125;</span><br><span class="line">decrement := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; count-- &#125;</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line">once.Do(increment)</span><br><span class="line">once.Do(decrement)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Count: %d\n&quot;</span>, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：<code>Count: 1</code></p><p><strong>sync.Once只计算调用Do方法的次数，而不是多少次唯一调用Do方法。</strong><br>这样，<strong>sync.Once的副本与所要调用的函数紧密耦合</strong>，我们再次看到如何在一个严格的范围内合理使用sync包中的类型以发挥最佳效果。<br>我建议你通过将sync.Once包装在一个小的语法块中来形式化这种耦合：要么是一个小函数，要么是将两者包装在一个结构体中。<br>这个例子你认为会发生什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> onceA, onceB sync.Once</span><br><span class="line"><span class="keyword">var</span> initB <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">initA := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; onceB.Do(initB) &#125;</span><br><span class="line">initB = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; onceA.Do(initA) &#125; <span class="comment">// 1</span></span><br><span class="line">onceA.Do(initA)                    <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1这个调用在2返回之前不能进行。<br>这个程序将会死锁，因为在1调用的Do直到2调用Do并退出后才会继续，这是死锁的典型例子。<br>对一些人来说，这可能有点违反直觉，因为它看起来好像我们使用的sync.Once是为了防止多重初始化，但sync.Once唯一能保证的是你的函数只被调用一次。<br>有时，这是通过死锁程序和暴露逻辑中的缺陷来完成的，在这个例子中是一个循环引用。</p><h4 id="池"><a href="#池" class="headerlink" title="池"></a>池</h4><p>池(Pool)是<a class="link"   href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F" >Pool模式<i class="fas fa-external-link-alt"></i></a>的并发安全实现。<br>在较高的层次上，Pool模式是一种创建和提供可供使用的固定数量实例或 Pool实例的方法。<br>它通常用于约束创建昂贵的场景（如数据库连接），以便只创建固定数量的实例，但不确定数量的操作仍然可以请求访问这些场景。<br>对于Go语言的sync.Pool,这种数据类型可以被多个goroutine安全地使用。</p><p>Pool的主接口是它的Get方法。当调用时，Get将首先检查池中是否有可用的实例返回给调用者，如果没有，调用它的new方法来创建一个新实例。<br>当完成时，调用者调用Put方法把工作的实例归还到池中，以供其他进程使用。<br>这里有一个简单的例子来说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">myPool := &amp;sync.Pool&#123;</span><br><span class="line">New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> any &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Creating new instance.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;&#125;</span><br><span class="line">myPool.Get()             <span class="comment">// 调用 Pool 的 get 方法，会执行 Pool 中定义的 New 函数，因为实例还没有实例化。 </span></span><br><span class="line">instance := myPool.Get() <span class="comment">// 同上</span></span><br><span class="line">myPool.Put(instance)     <span class="comment">// 将之前的实例放回池中，增加了池内可用数量。</span></span><br><span class="line">myPool.Get()             <span class="comment">// 再调用时，会重用之前的示例，不会调用 New 函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只看到两个对New函数的调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Creating new instance.</span><br><span class="line">Creating new instance.</span><br></pre></td></tr></table></figure><p>那么，为什么要使用 Pool,而不只是在运行时实例化对象呢？Go语言是有 GC 的，因此实例化的对象将被自动清理。<br>有什么意义？考虑下面这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> numCalcsCreated <span class="type">int</span></span><br><span class="line">calcPool := &amp;sync.Pool&#123;</span><br><span class="line">New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> any &#123;</span><br><span class="line">numCalcsCreated += <span class="number">1</span></span><br><span class="line">mem := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line"><span class="keyword">return</span> &amp;mem <span class="comment">// 存储bytes切片的地址</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用4KB初始化 pool</span></span><br><span class="line">calcPool.Put(calcPool.New())</span><br><span class="line">calcPool.Put(calcPool.New())</span><br><span class="line">calcPool.Put(calcPool.New())</span><br><span class="line">calcPool.Put(calcPool.New())</span><br><span class="line"><span class="keyword">const</span> numWorkers = <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(numWorkers)</span><br><span class="line"><span class="keyword">for</span> i := numWorkers; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">mem := calcPool.Get().(*[]<span class="type">byte</span>)</span><br><span class="line"><span class="keyword">defer</span> calcPool.Put(mem)</span><br><span class="line"><span class="comment">// 做一些有趣的假设，但是很快就会用这个内存完成</span></span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d calculators were created.&quot;</span>, numCalcsCreated)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：<code>23 calculators were created.</code><br>如果我没有用sync.Pool运行这个例子，尽管结果是不确定的，在最坏的情况下，我可能尝试分配一个十亿字节的内存，但是正如你从输出看到的，我只分配了4KB。<br>另一种常见的情况是，用Pool来尽可能快地将预先分配的对象缓存加载启动。在这种情况下，我们不是试图通过限制创建的对象的数量来节省主机的内存，而是通过提前加载获取引用到另一个对象所需的时间，来节省消费者的时间。<br>这在编写高吞吐量网络服务器时十分常见，服务器试图快速响应请求。让我们来看看这样的场景。<br>首先，让我们创建一个模拟创建到服务的连接的函数。我们会让这次连接花很长时间：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectToService</span><span class="params">()</span></span> any &#123;</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，让我们了解一下，如果服务为每个请求都启动一个新的连接，那么网络服务的性能如何。<br>我们将编写一个网络处理程序，为每个请求都打开一个新的连接。<br>为了使基准测试简单，我们只允许一次连接：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startNetworkDaemon</span><span class="params">()</span></span> *sync.WaitGroup &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">server, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;cannot listen:%v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> server.Close()</span><br><span class="line">wg.Done()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := server.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;cannot accept connection:%v&quot;</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">connectToService()</span><br><span class="line">fmt.Fprintln(conn, <span class="string">&quot;&quot;</span>)</span><br><span class="line">conn.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> &amp;wg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectToService</span><span class="params">()</span></span> any &#123;</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们的基准如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">daemonStarted := startNetworkDaemon()</span><br><span class="line">daemonStarted.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkNetworkRequest</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">b.Fatalf(<span class="string">&quot;cannot dial host:%v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, err := ioutil.ReadAll(conn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">b.Fatalf(<span class="string">&quot;cannot read:%v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">conn.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkNetworkRequest</span><br><span class="line">BenchmarkNetworkRequest-20          101010578820 ns/op</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure><p>看看 sync.Pool 改进的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">warmServiceConnCache</span><span class="params">()</span></span> *sync.Pool &#123;</span><br><span class="line">p := &amp;sync.Pool&#123;</span><br><span class="line">New: connectToService,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">p.Put(p.New())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startNetworkDaemon</span><span class="params">()</span></span> *sync.WaitGroup &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">connPool := warmServiceConnCache()</span><br><span class="line">server, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;cannot listen:%v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> server.Close()</span><br><span class="line">wg.Done()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := server.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;cannot accept connection:%v&quot;</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">svcConn := connPool.Get()</span><br><span class="line">fmt.Fprintln(conn, <span class="string">&quot;&quot;</span>)</span><br><span class="line">connPool.Put(svcConn)</span><br><span class="line">conn.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> &amp;wg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectToService</span><span class="params">()</span></span> any &#123;</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkNetworkRequest</span><br><span class="line">BenchmarkNetworkRequest-20        3800   4567334 ns/op</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure><p>快了三个数量级，在处理代价昂贵的事务时使用这种模式可以极大的提高响应时间。</p><p>当你的并发进程需要请求一个对象，但是在实例化之后很快地处理它们时，或者在这些对象的构造可能会对内存产生负面影响，这时最好使用Pool设计模式。<br>然而，有些情况下要谨慎决定你是否应该使用Pool:如果你使用Pool代码所需要的东西不是大概同质的，那么从Pool中转化检索到所需要的内容的时间可能比重新实例化内容要花费的时间更多。<br>例如，如果你的程序需要随机和可变长度的切片，那么Pool将不会对你有多大帮助。你直接从Pool中获得一个正确的切片的概率是很低的。</p><p>所以当你使用Pool工作时，记住以下几点：</p><ul><li>当实例化sync.Pool,使用new方法创建一个成员变量，在调用时是线程安全的。</li><li>当你收到一个来自 Get 的实例时，不要对所接收的对象的状态做出任何假设。</li><li>当你用完了一个从Pool中取出来的对象时，一定要调用Put,否则，Pool就无法复用这个实例了。通常情况下，这是用defer完成的。</li><li>Pool内的分布必须大致均匀。</li></ul><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>channel是由Hoare的CSP派生的同步原语之一。<br>虽然它们可以用来同步内存访问，但它们最好用于在goroutine之间传递信息。<br>正如我们在第2章“Go语言的并发哲学”中所讨论的，在任何大小的程序中，channel都非常有用，因为它们可以组合在一起。</p><p>就像河流一样，一个channel充当着信息传送的管道，值可以沿着channel传递，然后在下游读出。<br>当你使用channel时，你会将一个值传递给一个chan变量，然后你程序中的某个地方将它从channel中读出。<br>程序中不同的部分不需要相互了解，只需要在channel所在的内存中引用相同的位置即可。这可以通过对程序上下游的channel引用来完成。</p><p>创建一个channel非常简单。使用内置的make函数：<code>dataChan := make(chan any)</code> 这是一个双向的channel。<br>channel也可以声明为只支持单向的数据流，也就是说，可以定义一个channel只支持发送或接收信息：<code>dataChan := make(chan&lt;- any)</code> or <code>dataChan := make(&lt;-chan any)</code><br>通过 <code>&lt;-</code> 的方向来区分，还是非常直观的。</p><p>但我们通常不会看到单向channel实例化，但是会经常看到它们用作函数参数和返回类型。<br><strong>当需要时，Go语言会隐式地将双向channel转换为单向channel。</strong><br>这里有一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> receiveChan &lt;-<span class="keyword">chan</span> any</span><br><span class="line"><span class="keyword">var</span> sendChan <span class="keyword">chan</span>&lt;- any</span><br><span class="line">dataStream := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="comment">// 有效的语法：</span></span><br><span class="line">receiveChan = datastream</span><br><span class="line">sendChan = dataStream</span><br></pre></td></tr></table></figure><p>使用 channel 也是通过 <code>&lt;-</code> 操作符来完成。<br>将数据放到channel中：<code>dataChan &lt;- data</code><br>从channel中读取数据：<code>data := &lt;-dataChan</code></p><p>尝试向只读的channel写数据会报错：<code>invalid operation: cannot send to receive-only channel readOnlyCh (variable of type &lt;-chan int)</code><br>尝试从只写的channel读数据会报错：<code>invalid operation: cannot receive from send-only channel writeOnlyCh (variable of type chan&lt;- int)</code><br>这是Go语言的类型系统的一部分，它允许我们在处理并发原语时使用type-safety。</p><p><strong>Go语言中的channel是阻塞的。</strong><br>这意味着只有 channel 内的数据被消费后，新的数据才能写入，而任何试图从空channel 读取数据的goroutine将等待至少一条数据被写入channel后才能读到。</p><p>如果不正确地构造程序，这会导致死锁：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">stringStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="number">0</span> != <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">stringStream &lt;- <span class="string">&quot;Hello channels!&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(&lt;-stringStream)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过 <code>&lt;-</code> 操作符的接受形式也可以选择返回两个值：<code>data, ok := &lt;-dataChan</code></strong><br><strong>ok 是一个布尔值。当channel关闭时，ok为false，data为零值。当channel开启时，ok为true，data为channel中存储的值。如果没有数据，则会阻塞。</strong><br><strong>使用 <code>close(dataChan)</code> 关闭一个channel。</strong></p><p>这为我们提供了一些新的模式。<br>第一个是从channel中获取。通过range关键作为参数遍历（与for语句一起使用），并且<strong>在channel关闭时自动中断循环。</strong><br>这允许对channel上的值进行简洁的迭代。让我们看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">intstream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 我们确保在goroutine退出之前channel是关闭的。这是一个很常见的模式。</span></span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(intstream)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">intstream &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// 遍历了 intstream</span></span><br><span class="line"><span class="keyword">for</span> integer := <span class="keyword">range</span> intstream &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v &quot;</span>, integer)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<code>1 2 3 4 5 </code></p><p><strong>注意该循环不需要退出条件，并且 range 方法不返回第二个布尔值。处理一个已关闭的 channel 的细节可以让你保持循环简洁。</strong></p><p><strong>关闭 channel 也是一种同时给多个 goroutine 发信号的方法。</strong> 如果有 n 个 goroutine 在一个 channel 上等待，而不是在 channel 上写 n 次来打开每个 goroutine,你可以简单地关闭 channel。<br>由于一个被关闭的 channel 可以被无数次读取，所以不管有多少 goroutine 在等待它，关闭 channel 都比执行 n 次更适合，也更快。<br>这里有一个例子，可以同时打开多个 goroutine:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">begin := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">&lt;-begin <span class="comment">// goroutine会一直等待，直到它被告知可以继续。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v has begun\n&quot;</span>, i)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Unblocking goroutines...&quot;</span>)</span><br><span class="line"><span class="built_in">close</span>(begin) <span class="comment">// 关闭channel,从而同时打开所有的goroutine。</span></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以看到，在我们关闭开始channel之前，所有的goroutine都没有开始运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Unblocking goroutines...</span><br><span class="line">4 has begun</span><br><span class="line">2 has begun</span><br><span class="line">3 has begun</span><br><span class="line">o has begun</span><br><span class="line">1 has begun</span><br></pre></td></tr></table></figure><p>请记住在本章前面“sync包”中，我们讨论了使用sync.Cond类型执行相同的行为。你当然可以使用它，但是正如我们已经讨论过的，channel是可组合的。<br>我们还可以创建 buffered channel,它是在实例化时提供容量的 channel。<br>这意味着即使没有在 channel 上执行读取操作，goroutine 仍然可以执行 n 写入，其中 n 是缓冲 channel 的容量。<br><strong><code>dataChan := make(chan any, 4)</code>创建一个有4个容量的缓冲channel。</strong> 这意味着我们可以把4个东西放到 channel 上，不管它是否被读取。<br>这有点意思，因为它意味着 goroutine 可以控制实例化一个 channel 时否需要缓冲。这表明，创建一个 channel 应该与 goroutines 紧密耦合，而 goroutines 将会在它上面执行写操作，这样我们就可以更容易地推断它的行为和性能。</p><p>没有缓冲的 channel 也被定义为缓冲 channel,一个无缓冲channel只是一个以0的容量创建的缓冲channel。<br><strong><code>a := make(chan any)</code>和<code>b := make(chan any, 0)</code> 是等价的。</strong><br>请记住，当我们讨论阻塞时，如果说 channel 是满的，那么写入 channel 阻塞，如果 channel 是空的，则从 channels 读取的是什么？<br>“Full”和“empty”是容量或缓冲区大小的函数。无缓冲channel的容量为零，因此在任何写人之前channel已经满了。<br>一个没有下游接受的容量为4的缓冲channel在被写4次之后就满了，并且在写第5次的时候阻塞，因为它没有其他地方放置第五个元素。<br>与未缓冲的channel一样，缓冲channel仍然阻塞；channel为空或满的前提条件是不同的。<br>通过这种方式，缓冲channel是一个内存中的FIFO队列，用于并发进程进行通信。</p><p>为了帮助理解这一点，让我们用例子来解释一个具有4个容量的缓冲 channel 的情况。<br>首先，让我们来初始化： <code>c ：= make(chan rune, 4)</code><br>从逻辑上讲，这创建了一个带有四个槽的缓冲区。现在让我们往channel里写数据： <code>c &lt;- &#39;A&#39;</code><br>当这个channel没有下游读取时，一个数据将被放置在channel缓冲区的第一个槽中。<br>然后 <code>c &lt;- &#39;B&#39;</code>、<code>c &lt;- &#39;C&#39;</code>、<code>c &lt;- &#39;D&#39;</code>，经过4次写入后，缓冲区已满。<br>再试图写入 <code>c &lt;- &#39;E&#39;</code>，执行这个写入操作的 goroutine 将被阻塞，直到有读取操作。<br>下游读取时会依次接受位于缓冲区中的数据，直到缓冲区为空。</p><p>如果一个缓冲 channel 是空的，并且有一个下游接收，那么缓冲区将被忽略，并且该值将直接从发送方传递到接收方。<br>在实践中这是透明的，但是对了解缓冲channel的配置是值得的。缓冲 channel 在某些情况下是有用的，但是应该小心地创建它们。<br><strong>缓冲channel很容易成为一个不成熟的优化，并且使隐藏的死锁更不容易发生。这听起来像是一件好事，但我猜你宁愿在第一次写代码的时候发现死锁，而不是在生产系统崩遗的时候才发现。</strong></p><p>程序如何与值为 nil 的 channel 交互？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataStream <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line">&lt;-dataStream</span><br><span class="line"><span class="comment">// 写入</span></span><br><span class="line">dataStream &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br></pre></td></tr></table></figure><p>会报错：<code>fatal error: all goroutines are asleep - deadlock!</code><br>尝试<code>close(dataStream)</code>也会报错：<code>panic: close of nil channel</code></p><hr><p>channel 操作的结果给出了 channel 的状态：</p><table><thead><tr><th>操作</th><th>Channel 状态</th><th>结果</th></tr></thead><tbody><tr><td>Read</td><td>nil</td><td>阻塞</td></tr><tr><td>Read</td><td>打开且非空</td><td>输出值</td></tr><tr><td>Read</td><td>打开且空</td><td>阻塞</td></tr><tr><td>Read</td><td>关闭</td><td>&lt;默认值&gt;,false</td></tr><tr><td>Read</td><td>只写</td><td>编译错误</td></tr><tr><td>Write</td><td>nil</td><td>阻塞</td></tr><tr><td>Write</td><td>打开但填满</td><td>阻塞</td></tr><tr><td>Write</td><td>打开且不满</td><td>写入值</td></tr><tr><td>Write</td><td>关闭</td><td>panic</td></tr><tr><td>Write</td><td>只读</td><td>编译错误</td></tr><tr><td>Close</td><td>nil</td><td>panic</td></tr><tr><td>Close</td><td>打开且非空</td><td>关闭Channel，读取成功，直到缓存被读完，然后读取生产者的默认值</td></tr><tr><td>Close</td><td>打开且空</td><td>关闭Channel，读取生产者的默认值</td></tr><tr><td>Close</td><td>关闭</td><td>panic</td></tr><tr><td>Close</td><td>只读</td><td>编译错误</td></tr></tbody></table><p>channel是吸引人们使用Go语言的原因之一。<br>结合了goroutine和闭包的简单性，我很清楚地知道编写干净、正确的并发代码是多么容易。<br>在很多方面，channel是将goroutine黏合在一起的黏合剂。<br>本章应该给了你一个关于什么是channel以及如何使用它们的很好的概述。<br>真正的乐趣始于我们开始编写channel以形成高阶并发设计模式。我们会在下一章讲到。</p><p>期待。</p><h3 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h3><p>select语句是将channel绑定在一起的黏合剂，这就是我们如何在一个程序中组合channel以形成更大的抽象事务的方式。<br>声明select语句是一个具有并发性的Go语言程序中最重要的事情之一，这并不是夸大共词。<br>在一个系统中两个或多个组件的交集中，可以在本地、单个函数或类型以及全局范围内找到select语句绑定在一起的channel。<br>除了连接组件之外，在程序中的这些关键节点上，select语句可以帮助安全地将channel与诸如取消、超时、等待和默认值之类的概念结合在一起。</p><p>那么这些强大的select语句是什么呢？我们如何使用它们，它们是如何工作的？<br>让我们先把它放出来。这里有一个很简单的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c1, c2 &lt;-<span class="keyword">chan</span> any</span><br><span class="line"><span class="keyword">var</span> c3 <span class="keyword">chan</span>&lt;- any</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-c1:</span><br><span class="line"><span class="comment">//执行某些逻辑</span></span><br><span class="line"><span class="keyword">case</span> &lt;-c2:</span><br><span class="line"><span class="comment">//执行某些逻辑</span></span><br><span class="line"><span class="keyword">case</span> c3 &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line"><span class="comment">// 执行某些逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它看起来有点像一个选择模块，一个select模块包含一系列的case语句，这些语句可以保护一系列语句。<br>然而，这就是相似之处。<strong>与switch块不同，select块中的case语句没有测试顺序，如果没有满足任何条件，执行也不会失败。</strong></p><p>相反，所有的channel读取和写入都需要查看是否有任何一个已准备就绪可以用的数据：在读取的情况下关闭channel,以及写入不具备下游消费能力的channel。<br>如果所有channel都没有谁备好，则执行整个select语句模块。当一个channel准备好了，这个操作就会继续，它相应的语句就会执行。<br>让我们来看一个简单的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 等待5s后关闭channel</span></span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(<span class="string">&quot;Blocking on read...&quot;</span>)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-c:</span><br><span class="line"><span class="comment">// 尝试在channel上读取数据</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Unblocked %v later.\n&quot;</span>, time.Since(start))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Blocking on read...</span><br><span class="line">Unblocked 5.0109829s later.</span><br></pre></td></tr></table></figure><p>在进人select模块后大约5秒，我们就会解锁。这是一种简单而有效的方法来阻止我们等待某事的发生，但如果我们思考一下，我们可以提出一些问题：</p><ul><li>当多个channel有数据可供给下游读取的时候会发生什么？</li><li>如果没有任何可用的channel怎么办？</li><li>如果我们想要做一些事情，但是没有可用的channels怎么办？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="built_in">close</span>(c1)</span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="built_in">close</span>(c2)</span><br><span class="line"><span class="keyword">var</span> c1Count, c2Count <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1000</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-c1:</span><br><span class="line">c1Count++</span><br><span class="line"><span class="keyword">case</span> &lt;-c2:</span><br><span class="line">c2Count++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;c1Count:%d\nc2Count:%d\n&quot;</span>, c1Count, c2Count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1Count:485</span><br><span class="line">c2Count:515</span><br></pre></td></tr></table></figure><p>在一千次迭代中，大约有一半的时间从c1读取se1ect语句，大约一半的时间从c2读取。这看起来很有趣，也许有点太巧了。事实如此！<br><strong>Go 语言运行时将在一组case语句中执行伪随机选择。这就意味着，在你的case语句集合中，每一个都有一个被执行的机会。</strong><br>乍一看，这似乎并不重要，但背后的原因却非常有趣。<br>让我们先做一个很明显的阐述：Go语言运行时无法解析select语句的意图，也就是说，它不能推断出问题空间，或者说为什么将一组channel组合到一个select语句中。正因为如此，运行时所能做的最好的事情就是在平均情况下运行良好。<br>一种很好的方法是将一个随机变量引入到等式中（在这种情况下，se1ect后续的channel)。通过加权平均每个channel被使用的机会，所有使用select语句的程序将在平均情况下表现良好。</p><p>关于第二个问题：如果没有任何channel可用，会发生什么？如果所有的channel都被阻塞了，如果没有可用的，但是你可能不希望永远阻塞，可能需要超时机制。<br>Go语言的time包提供了一种优雅的方式，可以在select语句中很好地使用channel。<br>这里有一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c &lt;-<span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-c:</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">fmt.Println(<span class="string">&quot;Timed out.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个case语句永远不会被解锁，因为我们是从 nil channel 读取的。<br>输出如下：<code>Timed out.</code><br>time.After 函数通过传入 time.Duration 参数返回一个数值并写入 channel,该channel会返回执行后的时间。这为select语句提供了一种简明的方法。</p><p>最后一个问题：当没有可用channel时，我们需要做些什么？<br>像case语句一样，select语句也允许默认的语句。就像“case”语句一样，当“select’”语句中的所有channel都被阻塞的时候，“select”语句也允许你调用默认语句。<br>以下是一个实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line"><span class="keyword">var</span> c1, c2 &lt;-<span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-c1:</span><br><span class="line"><span class="keyword">case</span> &lt;-c2:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;In default after %v\n&quot;</span>, time.Since(start))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：<code>In default after 0s</code><br>可以看到，它几乎是瞬间运行了默认语句。这允许在不阻塞的情况下退出 select 模块。<br>通常，你将看到一个默认的子句，它与 for-select 循环一起使用。<br>这允许goroutine在等待另一个goroutine上报结果的同时，可以继续执行自己的操作。<br>这里有一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line"><span class="built_in">close</span>(done)</span><br><span class="line">&#125;()</span><br><span class="line">workCounter := <span class="number">0</span></span><br><span class="line">loop:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">break</span> loop</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟工作行为</span></span><br><span class="line">workCounter++</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Achieved %v cycles of work before signalled to stop.\n&quot;</span>, workCounter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：<code>Achieved 5 cycles of work before signalled to stop.</code></p><p>在这种情况下，我们有一个循环，它在执行某种操作，偶尔检查它是否应该被停止。<br>最后，对于空的select语句有一个特殊的情况：选择没有case子句的语句。<br>看起来像这样： <code>select {}</code> 这个语句将永远阻塞。<br>在第6章中，我们将深入研究select语句是如何工作的。从更高层次的角度来看，它应该是显而易见的，它可以帮助你安全高效地组合各种概念和子系统。</p><h3 id="GOMAXPROCS-控制"><a href="#GOMAXPROCS-控制" class="headerlink" title="GOMAXPROCS 控制"></a>GOMAXPROCS 控制</h3><p>在runtime包中，有一个函数称为GoMAXPR0CS。<br>这个名称是有误导性的：人们通常认为这个函数与主机上的逻辑处理器的数量有关（而且与它调度方式有关)，但实际上这个函数控制的OS线程的数量将承载所谓的“工作队列”。<br>有关这个函数的更多信息以及它的工作原理，请参见第6章。<br>在Go语言1.5之前，GoMAXPR0CS总是被设置为1，通常你会在大多数Go语言程序中找到这段代码：<code>runtime.GOMAXPROCS(runtime.NumCPU())</code><br>几乎大部分开发人员希望当他们的程序正在运行时，可以充分利用机器上的所有CPU核心。<del>（我还真干过）</del><br>因此，在随后的Go语言版本中，它自动设置为主机上逻辑CPU的数量。</p><p>那么为什么要调整这个值呢？大部分时间你都不太想去调节它。<br><strong>Go语言的调度算法在大多数情况下已经足够好了，在增加或减少工作队列和线程数量的情况下，可能会造成更多的问题，但是仍然有一些情况会改变这个值。</strong><br>例如，我在一个项目上调试，这个项目有一个测试组件，它被竞争环境困扰。<br>不管怎么说，这个团队有几个包，有时候测试失败。我们运行测试的主机有四个逻辑CPU,因此在任何一个点上，我们都有四个goroutines同时执行。<br>通过增加GoMAXPROCS以超过我们拥有的逻辑CPU数量，我们能够更频繁地触发竞争条件，从而更快地修复它们。</p><p>其他人可能通过实验发现，他们的程序在一定数量的工作队列和线程上运行得更好，但我更主张谨慎些。<br>如果你通过调整这个方法来压缩性能，那么在每次提交之后，当你使用不同的硬件，以及使用不同版本的Go语言时，一定要这样做。<br>调整这个值会使你的程序更接近它所运行的硬件，但以抽象和长期性能稳定为代价。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第三章-Go语言并发组件&quot;&gt;&lt;a href=&quot;#第三章-Go语言并发组件&quot; class=&quot;headerlink&quot; title=&quot;第三章 - Go语言并发组件&quot;&gt;&lt;/a&gt;第三章 - Go语言并发组件&lt;/h2&gt;&lt;p&gt;这章介绍Go中的特性，以及它如何支持并发。（终于到实</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://cooooing.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="go" scheme="https://cooooing.github.io/tags/go/"/>
    
    <category term="并发" scheme="https://cooooing.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="《go语言并发之道》" scheme="https://cooooing.github.io/tags/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%81%93%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《go语言并发之道》读书笔记-关于并发</title>
    <link href="https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%85%B3%E4%BA%8E%E5%B9%B6%E5%8F%91/"/>
    <id>https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%85%B3%E4%BA%8E%E5%B9%B6%E5%8F%91/</id>
    <published>2025-01-02T09:52:21.000Z</published>
    <updated>2025-01-02T09:52:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>又开新书了，按照原来的计划，其实这次应该读的是 Kafka 相关的。<br>但奈何计划赶不上变化。</p><p>前几天给鱼排论坛写了聊天室的消息分发节点 <a class="link"   href="https://github.com/FishPiOffical/rhyus-golang" >rhyus-golang<i class="fas fa-external-link-alt"></i></a>，纯纯的多线程需要考虑并发的应用（虽然并发不高）。<br>所以变成了并发相关的书。</p><p>这篇计划阅读前两章，是关于并发概念的。</p><h2 id="第一章-并发概述"><a href="#第一章-并发概述" class="headerlink" title="第一章 - 并发概述"></a>第一章 - 并发概述</h2><p>书中前面关于摩尔定律、Web Scale和云计算相关的话题就跳过了。</p><h3 id="为什么并发很难？"><a href="#为什么并发很难？" class="headerlink" title="为什么并发很难？"></a>为什么并发很难？</h3><p>众所周知，并发代码是很难正确构建的。它通常需要完成几个迭代才能让它按预期的方式工作，即使这样，在某些时间点（更高的磁盘利用率、更多的用户登录到系统等)到达之前，bug在代码中存在数年的事情也不少见，以至于以前未被发现的bug在后面显露出来。<br>这段话我是有点体会的，上面的节点程序我迭代了很多次，很多问题都得在高并发或者高负载时才会出现。</p><h3 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h3><p><strong>当两个或多个操作必须按正确的顺序执行，而程序并未保证这个顺序，就会发生竞争条件。</strong><br>大多数情况下，这将在所谓的数据中出现，其中一个并发操作尝试读取一个变量，而在某个不确定的时间，另一个并发操作试图写入同一个变量。</p><p>下面是一个基本示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> data <span class="type">int</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">data++</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">if</span> data == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;the value is %v.\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里，第8行和第11行都试图访问变量data,但并不能保证以什么顺序进行访问。<br>运行这段代码有三种可能的结果：</p><ol><li>不打印任何东西。在这种情况下，第8行在第10行之前执行。</li><li>打印“the value is 0.”。在这种情况下，第10行和第11行在第8行之前执行。</li><li>打印“the value is 1.”。在这种情况下，第8行在第10行之前执行，但第8行在第11行之前执行。</li></ol><p><strong>如你所见，虽然只有几行不正确的代码，但在你的程序中引入了巨大的不确定性。</strong><br>在并发代码中定位问题是非常困难的，需要考虑到各种可能出现的情况。</p><p><strong>有时候想象在两个操作之间会经过很长一段时间很有帮助。</strong><br>假设调用goroutine的时间和它运行的时间相差1h。那程序的其余部分将如何运行呢？<br>如果在goroutine执行成功和程序执行到if语句之间也花费了一小时，又会发生什么呢？<br>以这种方式思考对我很有帮助，因为对于计算机来说，规模可能不同，但相对的时间差异或多或少是相同的。</p><p>所以有时候，会出现下面的代码（在程序中大量使用休眠语句）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> data <span class="type">int</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">data++</span><br><span class="line">&#125;()</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">// 这种方式非常不优雅</span></span><br><span class="line"><span class="keyword">if</span> data == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;the value is %v.\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们的数据竞争问题解决了吗？并没有。事实上，在这个程序中之前的三个结果仍然有可能出现，只是可能性更小了。<br>我们在调用 goroutine 和检查数据值之间的休眠的时间越长，我们的程序就越接近正确，但那只是概率上接近逻辑的正确性：它永远不会真的变成逻辑上的正确。</p><p>除此之外，<strong>这让我们的算法变得低效</strong>。我们现在不得不休眠1s,来降低我们的程序出现数据竞争的可能。<br>所以，我们应该始终以逻辑正确性为目标。在代码中引人休眠可以方便地调试并发程序，但这并不能称之为一个解决方案。</p><blockquote><p>竞争条件是最难以发现的并发bug类型之一，因为它们可能在代码投人生产多年之后才出现。<br>通常代码正在执行时环境产生变化，或发生了某些罕见的事情，都有可能使其浮现出来。<br>往往代码只是看上去在用正确的方式来执行，但是事实上只是执行的顺序是正确的这件事本身的概率比较大而已，最终早晚有可能会出现一些意想之外的结果。</p></blockquote><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p><strong>当某些东西被队为是原子的，或者具有原子性的时候，这意味着在它运行的环境中，它是不可分割的或不可中断的。</strong></p><p>那么这到底意味着什么，为什么在使用并发代码时知道这一点很重要？<br>第一件非常重要的事情是“上下文(context)”这个词。<br>可能在某个上下文中有些东西是原子性的，而在另一个上下文中却不是。<br>在你的进程上下文中进行原子操作在操作系统的上下文中可能就不是原子操作；<br>在操作系统环境中原子操作在机器环境中可能就不是原子的，在你的机器上下文中原子操作在你的应用程序的上下文中可能不是原子的。<br>换句话说，操作的原子性可以根据当前定义的范围而改变。这种特性对你来说有利有弊！</p><p><strong>在考虑原子性时，经常第一件需要做的事就是定义上下文或范围，然后再考虑这些操作是否是原子性的。一切都应当遵循这个原则。</strong></p><p>术语“不可分割”(indivisible)和“不可中断”(uninterruptible)。<br>这些术语意味着在你所定义的上下文中，原子的东西将被完整的运行，而在这种情况下不会同时发生任何事情。<br>这仍然是一个整体，所以我们来看一个例子：<br><code>i++</code><br>这是一个任何人都可以设计的简单例子，但它很容易证明原子性的概念。它<br>可能看起来很原子，但是简要地分析一下就会发现其中有以下步骤：</p><ol><li>检索i的值。</li><li>增加i的值。</li><li>存储i的值。</li></ol><p>尽管这些操作中的每一个都是原子的，但三者的结合就可能不是，这取决于你的上下文。<br>这揭示了原子操作的一个有趣的性质：将它们结合并不一定会产生更大的原子操作。<br>使一个操作变为原子操作取决于你想让它在哪个上下文中。<br>如果你的上下文是一个没有并发进程的程序，那么该代码在该上下文中就是原子的。<br>如果你的上下文是一个goroutine,它不会将i暴露给其他 goroutine ,那么这个代码就是原子的。</p><p>为什么我们要关心这些呢？原子性非常重要，**因为如果某个东西是原子的，隐含的意思是它在并发环境中是安全的。**这使我们能够编写逻辑上正确的程序，并且这甚至可以作为优化并发程序的一种方式。<br>但大多数语句不是原子的，更不用说函数、方法和程序了。后面会通过各种方法来调和这个矛盾。</p><h3 id="内存访问同步"><a href="#内存访问同步" class="headerlink" title="内存访问同步"></a>内存访问同步</h3><p>假设有这样一个数据竞争：两个并发进程试图访问相同的内存区域，它们访问内存的方式不是原子的。<br>将之前的数据竞争的例子稍作修改就可以说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> data <span class="type">int</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; data++ &#125;()</span><br><span class="line"><span class="keyword">if</span> data == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;the value is 0.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;the value is %v.\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这里添加了一个e1se子句，所以不管数据的值如何，我们总会得到一些输出。请记住，正如之前所介绍，如果有一个数据竞争存在，那么该程序的输出将是完全不确定的。<br>实际上，<strong>程序中需要独占访问共享资源的部分有一个专有名词，叫临界区(critical section)。</strong><br>在这个例子中，我们有三个临界区：</p><ul><li>我们的 goroutine 正在增加数据变量。</li><li>我们的 if 语句，它检查数据的值是否为0。</li><li>我们的 fmt.Printf 语句，在检索并输出数据的值。</li></ul><p>有很多方法可以保护你的程序的临界区，go语言在设计时有一些更好的想法来解决这个问题，不过解决这个问题的其中一个办法是在你的临界区之间内存访问做同步。（加锁）<br>下面的代码不是Go语言中惯用的方法（我不建议像这样解决你的数据竞争问题)，但它很简单地演示了内存访问同步。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> memoryAccess sync.Mutex</span><br><span class="line"><span class="keyword">var</span> value <span class="type">int</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">memoryAccess.Lock()</span><br><span class="line">value++</span><br><span class="line">memoryAccess.Unlock()</span><br><span class="line">&#125;()</span><br><span class="line">memoryAccess.Lock()</span><br><span class="line"><span class="keyword">if</span> value == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;the value is %v.\n&quot;</span>, value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;the value is %v.\n&quot;</span>, value)</span><br><span class="line">&#125;</span><br><span class="line">memoryAccess.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这里添加一个变量 memoryAccess，它将允许我们的代码对内存数据的访问做同步。（锁，后续介绍）<br>这样虽然解决了数据竞争，但是并没有解决竞争条件。即这个程序的操作顺序仍然是不确定的，只是缩小了非确定性的范围。</p><p>从表面上看，这似乎很简单：如果你发现你的代码中有临界区，那就添加锁来同步内存访问！<br>虽然通过内存访问同步来解决一些问题，但正如我们刚刚看到的，它不会自动解决数据竞争或逻辑正确性问题。此外，它也可能造成维护和性能问题。</p><p>还有个问题就是 Lock 的调用会使我们的程序变慢。每次执行这些操作时，我们的程序就会暂停一段时间。<br>这会带来两个问题：</p><ol><li>临界区是否是频繁进入和退出？（锁竞争）</li><li>临界区应该有多大？（锁的粒度）</li></ol><p>在程序的上下文中解决这两个问题是一种艺术，并且增加了内存访问同步的难度。</p><h3 id="死锁、活锁和饥饿"><a href="#死锁、活锁和饥饿" class="headerlink" title="死锁、活锁和饥饿"></a>死锁、活锁和饥饿</h3><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁程序是所有的并发进程彼此等待的程序。在这种情况下，如果没有外界的干预，这个程序将永远无法恢复。</p><p>这听起来很严峻，那是因为的确如此！Go语言的运行时会尽其所能，检测一些死锁（所有的goroutine必须被阻塞，或者“<a class="link"   href="https://github.com/golang/go/issues/13759" >asleep<i class="fas fa-external-link-alt"></i></a>”），但是这对于防止死锁并没有太多的帮助。</p><p>下面是一个死锁的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> value <span class="keyword">struct</span> &#123;</span><br><span class="line">mu    sync.Mutex</span><br><span class="line">value <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">printSum := <span class="function"><span class="keyword">func</span><span class="params">(v1, v2 *value)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">v1.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> v1.mu.Unlock()</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">v2.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> v2.mu.Unlock()</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;sum = %v\n&quot;</span>, v1.value+v2.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a, b value</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> printSum(&amp;a, &amp;b)</span><br><span class="line"><span class="keyword">go</span> printSum(&amp;b, &amp;a)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行会报错 <code>fatal error: all goroutines are asleep - deadlock!</code></p><p>事实证明，出现死锁有儿个必要条件。I971年，Edgar Coffman 在一篇论文中列举了这些条件。这些条件现在被称为 Coffman 条件，是帮助检测、防止和纠正死锁的技术依据。<br>Coffman 条件如下：</p><ol><li>互斥条件 - 并发进程同时拥有资源的独占权。</li><li>占有并等待条件 - 并发进程必须同时拥有一个资源，并等待额外的资源。</li><li>非抢占条件 - 并发进程拥有的资源只能被该进程释放，即可满足这个条件。</li><li>循环等待条件 - 一个并发进程(P1)必须等待一系列其他并发进程(P2),这些并发进程同时也在等待进程(P1),这样便满足了这个最终条件。</li></ol><p>这些规则也帮助我们防止死锁。如果确保至少有一个条件不成立，我们可以防止发生死锁。不幸的是，实际上这些条件很难推理，因此很难预防。</p><h4 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h4><p>活锁是正在主动执行并发操作的程序，但是这些操作无法向前推进程序的状态。</p><p>你曾经在走廊走向另一个人吗？她移动到一边让你通过，但你也做了同样的事情。所以你转到另一边，但她也是这样做的。想象一下这个情形永远持续下去，你就明白了活锁。<br><del>这个倒是经常发生</del></p><p>下面是一个活锁的例子，就是上面所说的情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> value <span class="keyword">struct</span> &#123;</span><br><span class="line">mu    sync.Mutex</span><br><span class="line">value <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">cadence := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> time.Tick(<span class="number">1</span> * time.Millisecond) &#123;</span><br><span class="line">cadence.Broadcast()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">takeStep := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">cadence.L.Lock()</span><br><span class="line">cadence.Wait()</span><br><span class="line">cadence.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">tryDir := <span class="function"><span class="keyword">func</span><span class="params">(dirName <span class="type">string</span>, dir *<span class="type">int32</span>, out *bytes.Buffer)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">fmt.Fprintf(out, <span class="string">&quot; %v&quot;</span>, dirName)</span><br><span class="line">atomic.AddInt32(dir, <span class="number">1</span>)</span><br><span class="line">takeStep()</span><br><span class="line"><span class="keyword">if</span> atomic.LoadInt32(dir) == <span class="number">1</span> &#123;</span><br><span class="line">fmt.Fprint(out, <span class="string">&quot;Success!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">takeStep()</span><br><span class="line">atomic.AddInt32(dir, <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> left, right <span class="type">int32</span></span><br><span class="line">tryLeft := <span class="function"><span class="keyword">func</span><span class="params">(out *bytes.Buffer)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> tryDir(<span class="string">&quot;left&quot;</span>, &amp;left, out) &#125;</span><br><span class="line">tryRight := <span class="function"><span class="keyword">func</span><span class="params">(out *bytes.Buffer)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> tryDir(<span class="string">&quot;right&quot;</span>, &amp;right, out) &#125;</span><br><span class="line"></span><br><span class="line">walk := <span class="function"><span class="keyword">func</span><span class="params">(walking *sync.WaitGroup, name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> out bytes.Buffer</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Println(out.String()) &#125;()</span><br><span class="line"><span class="keyword">defer</span> walking.Done()</span><br><span class="line">fmt.Fprintf(&amp;out, <span class="string">&quot;%v is trying to scoot:&quot;</span>, name)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> tryLeft(&amp;out) || tryRight(&amp;out) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Fprintf(&amp;out, <span class="string">&quot;\n%v tosses her hands up in exasperation!&quot;</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> peopleInHallway sync.WaitGroup</span><br><span class="line">peopleInHallway.Add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> walk(&amp;peopleInHallway, <span class="string">&quot;Alice&quot;</span>)</span><br><span class="line"><span class="keyword">go</span> walk(&amp;peopleInHallway, <span class="string">&quot;Barbara&quot;</span>)</span><br><span class="line">peopleInHallway.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Alice is trying to scoot: left right left right left right left right left right</span><br><span class="line">Alice tosses her hands up in exasperation!</span><br><span class="line">Barbara is trying to scoot: left right left right left right left right left right</span><br><span class="line">Barbara tosses her hands up in exasperation!</span><br></pre></td></tr></table></figure><p>你可以看到，Alice和Barbara在最终退出之前，会持续竞争。</p><ol><li>tryDir 函数允许一个人尝试向一个方向移动，并返回是否成功。dir 表示试图朝这个方向移动的人数。</li><li>首先，宣布尝试向这个方向移动，atomic 使 dir 原子操作加一。</li><li>takeStep 函数调用 cadence.Wait 来等待其他并发进程，用以同步每个协程的节奏。因为要演示活锁，每个人都必须以相同的速度或节奏移动。</li><li>当意识到不能向这个方向走时，便放弃。将 dir 减一。</li><li>walk 函数中，人为限制了尝试的次数，<strong>否则，它将会一直无意义执行下去。</strong></li><li>walk 中，会尝试向左走，如果失败，则尝试向右走。</li></ol><p>这个例子演示了使用活锁的一个十分常见的原因：两个或两个以上的并发进程试图在没有协调的情况下防止死锁。<br>这就好比，如果走廊里的人都同意，只有一个人会移动，那就不会有活锁；一个人会站着不动，另一个人会移到另一边，他们就会继续移动。<br>在我看来，活锁要比死锁更复杂，因为它看起来程序好像在工作。<br>如果一个活锁程序在你的机器上运行，那你可以通过查看CPU利用率来确定它是否在做处理某些逻辑，你可能会认为它确实是在工作。<br>根据活锁的不同，它甚至可能发出其他信号，让你认为它在工作。然而，你的程序将会一直上演“hallway-shuffle’”的循环游戏。</p><p>活锁是一组被称为“饥饿”的更大问题的子集。</p><h4 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h4><p>饥饿是在任何情况下，并发进程都无法获得执行工作所需的所有资源。</p><p>当我们讨论活锁时，每个goroutine的资源是一个共享锁。</p><p>活锁保证讨论与饥饿是无关的，因为在活锁中，所有并发进程都是相同的，并且没有完成工作。<br>更广泛地说，饥饿通常意味着有一个或多个贪婪的并发进程，它们不公平地阻止一个或多个并发进程，以尽可能有效地完成工作，或者阻止全部并发进程。</p><p>下面的例子有一个贪婪的 goroutine 和一个平和的 goroutine：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> sharedLock sync.Mutex</span><br><span class="line"><span class="keyword">const</span> runtime = <span class="number">1</span> * time.Second</span><br><span class="line"></span><br><span class="line">greedyWorker := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> begin := time.Now(); time.Since(begin) &lt;= runtime; &#123;</span><br><span class="line">sharedLock.Lock()</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Nanosecond)</span><br><span class="line">sharedLock.Unlock()</span><br><span class="line">count++</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Greedy worker was able to execute %v work loops.\n&quot;</span>, count)</span><br><span class="line">&#125;</span><br><span class="line">politeWorker := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> begin := time.Now(); time.Since(begin) &lt; runtime; &#123;</span><br><span class="line">sharedLock.Lock()</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Nanosecond)</span><br><span class="line">sharedLock.Unlock()</span><br><span class="line">sharedLock.Lock()</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Nanosecond)</span><br><span class="line">sharedLock.Unlock()</span><br><span class="line">sharedLock.Lock()</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Nanosecond)</span><br><span class="line">sharedLock.Unlock()</span><br><span class="line">count++</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Polite worker was able to execute %v work loops.\n&quot;</span>, count)</span><br><span class="line">&#125;</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> greedyWorker()</span><br><span class="line"><span class="keyword">go</span> politeWorker()</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Greedy worker was able to execute 33 work loops.</span><br><span class="line">Polite worker was able to execute 12 work loops.</span><br></pre></td></tr></table></figure><p>贪婪的 worker 会贪婪地抢占共享锁，以完成整个工作循环，而平和的 worker 只会在必要时锁定。<br>两种 worker 都做到同样的工作（sleep 3 ns），但贪婪的 worker 工作量会比平和的 worker 多得多。</p><p>通过记录和采样确定进程工作速度是否符合预期，可以发现和解决饥饿。<br>所以，饥饿会导致你的程序表现不佳或不正确。前面的示例演示了低效场景，但是如果你有一个非常贪婪的并发进程，以至于完全阻止另一个并发进程完成工作，那么你就会遇到一个更大的问题。<br>我们还应该考虑到来自于外部过程的饥饿。请记住，饥饿也可以应用于CPU、内存、文件句柄、数据库连接：<strong>任何必须共享的资源都是饥饿的候选者</strong>。</p><h2 id="第二章-对你的代码建：通信顺序进程"><a href="#第二章-对你的代码建：通信顺序进程" class="headerlink" title="第二章 - 对你的代码建：通信顺序进程"></a>第二章 - 对你的代码建：通信顺序进程</h2><h3 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h3><blockquote><p>并发属于代码，并行属于一个运行中的程序。</p></blockquote><p>这个区别其实仔细体会一下，描述得很清楚。<br>比如，我写了一个两部分可以并行运行的程序，但我却在一个只有一个核心的机器上运行它。那么同一时刻只会有一个部分被执行，他不可能是并行的。但如果是多个核心的机器，那么两个部分就可以并行执行。<br>但这两台机器上我们都可以认为它是并发的，因为并发是一段时间内两个部分都被执行就认为是并发的。（当然，这句是我以前的观点。学习操作系统进程相关知识时的观点）</p><p>但这章中的观点是：并行是一个时间或者上下文的函数。<br>上一章中，上下文被定义为一个操作被认为是原子性的界限。这里，上下文定义为两个或以上的操作被认为是并行的界限。</p><p>比如，我们的上下文是一段5s的时长，执行了两个分别消耗1s的操作，我们应该认为这些操作是并行执行的。但如果我们的上下文是1s，应该认为这些操作是分别运行的。</p><p>对于我们来说，用不同的时间对上下文的概念进行重定义并不是一件好事，但是请记住上下文和时间并设有关系。<br>我们可以把上下文定义成我们程序所在运行的进程，一个操作系统的线程，或者是一台机器。<br>这很重要，因为你所定义的上下文是和并发性以及正确性密切相关。<br>就像原子操作可以按照你所定义的上下文来定义是否为原子性，并发操作也依据你所定义的上下文来确定正确性。一切都是相关的。</p><h3 id="什么是-CSP"><a href="#什么是-CSP" class="headerlink" title="什么是 CSP"></a>什么是 CSP</h3><p>CSP即“Communicating Sequential Processes’”(通信顺序进程)，既是个技术名词，也是介绍这种技术的论文的名字。<br>在1978年，Charles Antony Richard Hoare在Association for Computing Machinery(一般被称作ACM)中发表的论文。<br>在这篇论文里，Hoar认为输入与输出是两个被忽略的编程原语，尤其是在并发代码中。<br>在Hoare写作这篇论文的同时，关于如何架构程序的相关研究还在进行中，但是大部分的研究都是针对编写顺序代码的方法：goto语句的使用正在被讨论，面向对象范型正在成为编程的基石。并发操作并没有被给予过多的思考。<br>Hoare开始纠正这个现象，所以，关于CSP的这篇论文就横空出世了。<br>在1978年的论文中，CSP仅是一个完全用来展示通信顺序进程的能力的一个简单的编程语言。<br>事实上，他甚至在论文中写道：<code>因此，本文介绍的概念和符号应该...不被认为适合作为一种编程语言，无论是抽象的还是具体的编程。</code></p><p>而且正是因为CSP的原始论文以及从论文中进化而来的原语正是Go语言并发模型的主要灵感，而这正是我们接下来所要聚焦的。</p><p>用来支撑他关于输入与输出需要被按照语言的原语来考虑，Hoare的CSP编程语言包含用来建模输入与输出，或者说“在进程间正确通信”（这就是论文名字的由来)的原语。<br>为了在进程之间进行通信，Hoar心创造了输入与输出的命令：！代表发送输入到一个进程，？代表读取一个进程的输出。<br>每一个指令都需要指定具体是一个输出变量（从一个进程中读取一个变量的情况），还是一个目的地（将输入发送到一个进程的情况)。<br>有时，这两种方法会引用相同的东西，在这种情况下，这两个过程会被认为是相对应的。<br>换言之，一个进程的输出应该直接流向另一个进程的输入。</p><p>这种语言同时利用了一个所谓的守护命令，也就是Edgar Dijkstra在一篇之前在I974年所写的论文中介绍的，“Guarded commands,nondeterminacy and formal derivation of programs’”。<br>一个有守护的命令仅仅是一个带有左和右倾向的语句，由一来分割。左侧服务是有运行条件的，或者是守护右侧服务，如果左侧服务运行失败，或者在一个命令执行后，返回false或者退出，右侧服务永远不会被执行。<br>将这些与Hoare的I&#x2F;O命令组合起来，为Hoare的通信过程奠定了基础，从而实现了channel。</p><p>经验判断Hoare的建议是正确的，然而，有趣的是，在Go语言发布之前，很少有语言能够真正地为这些原语提供支持。<br><strong>大多数流行的语言都支持共享和内存访问同步到CSP的消息传递样式。</strong> 当然也有例外，但不幸的是，这些都局限于没有广泛采用的语言。<br>Go语言是最早将CSP的原则纳人共核心的语言之一，并将这种并发编程风格引入到大众中。它的成功也使得其他语言尝试添加这些原语。内存访问同步并不是天生就不好。<br>在Go语言中，甚至有时共享内存在某些情况下是合适的。但是，共享内存模型很难正确地使用，特别是在大型或复杂的程序中。<br>正是由于这个原因，并发被认为是Go语言的优势之一，它从一开始就建立在CSP的原则之上，因此很容易阅读、编写和推理。</p><h3 id="Go语言的并发哲学"><a href="#Go语言的并发哲学" class="headerlink" title="Go语言的并发哲学"></a>Go语言的并发哲学</h3><p>CSP一直都是Go语言设计的重要组成部分。然而，Go语言还支持通过内存访问同步和遵循该技术的原语来编写并发代码的传统方式。sync与其他包中的结构体与方法可以让你执行锁，创建资源池取代goroutine等。</p><p>能够在CSP原语和内存访问同步之间选择对于你来说很棒，因为它让你去编写解决问题的并发代码上有了更多选择，但这可能显得有些莫名其妙。<br>Go语言的初学者总是认为CSP样式编写并发代码是Go语言编写并发代码的唯一方式。<br>比如说，在sync包的文档中，有如下描述：</p><blockquote><p>sync包提供了基本的同步基元，如互斥锁。除了Once类型和WaitGroup类型，大部分都是适用低水平程序线程，高水平的同步使用channel通信更好一些。</p></blockquote><p>在Go语言的FAQ中，有如下陈述：</p><blockquote><p>为了尊重mutex,sync包实现了mutex,但是我们希望Go语言的编程风格将会鼓励人们尝试更高等级的技巧。尤其是考虑构建你的程序，以便一次只有一个goroutine负责某个特定的数据。<br>不要通过共享内存进行通信。相反，通过通信来共享内存。有数不清的关于Go语言核心图队的文章、讲座和访谈，相对于使用像sync.Mutex这样的原语，他们更加拥护CSP。</p></blockquote><p>因此，Go语言团队为什么选择公开内存访问同步原语会感到困惑是完全可以理解的。更令人因惑的是，你通常会在外面看到出现的同步原语。<br>见到人们抱怨过度使用channel,也会听到一些Go语言团队成员说使用它们是“OK”的。<br>Go语言的维基上有一个关于此的引用：</p><blockquote><p>Go语言的一个座右铭是，“<strong>使用通信来共享内存，而不是通过共享内存来通信。</strong>”<br>这就是说，Go语言确实在syc包中提供了传统的锁机制。大多数的锁问题都可以通过channel或者传统的锁两者之一来解决。<br>所以说，我该用哪个？<br>使用最好描述和最简单的那个方式。</p></blockquote><p>这是很好的建议，也是你在使用Go语言时经常看到的谁则，但它有点含糊。<br>我们如何理解什么更具表现力、更简单？我们应该使用什么标准？<br>幸运的是，我们可以使用一些标准来帮助我们做正确的事情。<br>正如我们将看到的那样，我们主要的区分方式来自于试图管理并发的地方：主观地想象一个狭窄的范围，或者在我们的系统外部。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%85%B3%E4%BA%8E%E5%B9%B6%E5%8F%91/%E5%86%B3%E7%AD%96%E6%A0%91.png"                        alt="决策树"                 ></p><p>让我们逐步来介绍这些决策：</p><p><strong>你想要转让数据的所有权么？</strong><br>如果你有一块产生计算结果并想共享这个结果给其他代码块的代码，你所实际做的事情是传递了数据的所有权。<br>如果你对内存所有制且不支持GC的语言很熟悉的话，对于这个概念你应该是很熟悉的：数据拥有所有者，并发程序安全就是保证同时只有一个并发上下文拥有数据的所有权。<br>channel通过将这个意图编写进channel类型本身来帮助我们表达这个意图。</p><p>这么做的一个很大的好处就是可以创建一个带缓存的channel来实现一个低成本的在内存中的队列来解耦你的生产者与消费者。<br>另一个好处就是通过使用channel确保你的并发代码可以和其他的并发代码进行组合。</p><p><strong>你是否试图在保护某个结构的内部状态？</strong><br>这时候内存访问同步原语的一个很好的选择，也是一个你不应该使用channel的很好的示例。<br>通过使用内存访问同步原语，可以为你的调用者隐藏关于重要代码块的实现细节。<br>这是一个线程安全类型的小例子，且不会给调用者带来复杂性：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span></span><br><span class="line">mu    sync.Mutex</span><br><span class="line">value <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> Increment() &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">c.value++</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果你能回想起关于原子性的细节，可以说我们在这里所做的就是定义了Counter类型的原子性范围。调用增量可被认为是原子的。<br>记住这里的关键词是“内部的”。如果你发现自己正在将锁暴露在一个类型之外，这时侯你应该注意了。试着将你的锁放在一个小的字典范围内。</p><p><strong>你是否试图协调多个逻辑片段？</strong><br>请记住，channel本质上比内存访问同步原语更具可组合性。<br>将锁分散在整个对象图中听起来像是一场噩梦，但是，将channel编写的随处可见是被鼓励以及期待的！<br>我可以组合channel,但是我不能轻易的组合锁或者有返回值的方法。</p><p>你会发现，因为Go语言的select语句，以及channel可以当作队列使用和被安全的随意传递。<br>所以，当在使用channel的时候，你可以更简单的控制你软件中出现的激增的复杂性。<br>如果你发现正在挣扎着理解你的并发代码是如何工作的，为什么会出现死锁以及竞争，而你正在只用原语，这是一个你应该切换到channel的好示例。</p><p><strong>这是一个对性能要求很高的临界区吗？</strong><br>这绝对不意味着“我想让我的程序拥有高性能，因此，我应该只是用mutex’”。<br>当然，如果你程序中的某部分，事实证明是一个主要的性能瓶颈，比程序的其他部分慢几个数量级，使用内存访问同步原语可能会帮助这个重要的部分在负载下执行。<br>这是因为channel使用内存访问同步来操作，因此它们只能更慢。<br>然而，在我们考虑这一点之前，性能至关重要的程序部分可能暗示着需要重新规划我们的程序。</p><p>希望这可以清楚地说明是否利用CSP风格的并发或内存访问同步。<br>还有其他一些模式和做法在使用操作系统线程作为并发抽象方式的语言中很有用。<br>在使用操作系统线程作为主要并发抽象的语言中还有其他的方式以及实践。<br>比如说，像是线程池之类的东西经常出现。因为这些抽象大多数都是为了利用操作系统线程的优点与缺点。<br>Go语言的并发性哲学可以这样总结：<strong>追求简洁，尽量使用channel,并且认为goroutine的使用是没有成本的。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;又开新书了，按照原来的计划，其实这次应该读的是 Kafka 相关的。&lt;br&gt;但奈何计划赶不上变化。&lt;/p&gt;
&lt;p&gt;前几天给鱼排论坛写了聊天室</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://cooooing.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="go" scheme="https://cooooing.github.io/tags/go/"/>
    
    <category term="并发" scheme="https://cooooing.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="《go语言并发之道》" scheme="https://cooooing.github.io/tags/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%81%93%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>2024年年终总结</title>
    <link href="https://cooooing.github.io/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/2024%E5%B9%B4%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://cooooing.github.io/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/2024%E5%B9%B4%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</id>
    <published>2024-12-22T06:29:54.000Z</published>
    <updated>2024-12-22T06:29:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>2024年过的平平淡淡，让我回忆一下，然后下面就是流水账时间…</p><h2 id="上半年"><a href="#上半年" class="headerlink" title="上半年"></a>上半年</h2><p>上半年都在实习公司度过，因为去年年底项目才上线，年初也比较忙，没有什么记录，基本就是上班。<br>不过因为忙，人手不够，所以也让我开始写Java了，不再是低代码平台和写写sql了。（不过，写CURD接口和写sql区别也不是特别大）</p><p>三月份配了台新电脑，花了四千三。内存也是上到了64G，不过很少跑满，跑一半的情况都比较少。不过基本不用担心内存不够的问题了，minecraft几百个mod的大型整合包我也能边开服务器边开客户端玩。<br>可惜的就是板U，买了Q1HY，工程测试的版本。便宜是真便宜，就是不稳定，频率高了会蓝屏。现在也基本默频在用，没有超频了。</p><p>到五月份，重要的事情就是毕设答辩了。<br>毕业设计这个东西的代码我从去年8月左右在实训的时候就开始写了。那时候很闲，处于慢慢写的状态，基本完成的差不多了。<br>也庆幸那时候就开始了，不然按实习那个工作强度，再加上毕设的代码和论文。会过得非常痛苦。<br>论文基本上第一遍就过了，后面按导师的意见改改格式，大体上的内容基本没有改动。<br>然后就是五月回学校答辩，答辩其实很水，感觉还是ppt和讲为主。最后展示系统的时候，三个老师看一个教师大概三十人，分开看。其实基本也就扫一眼，十秒左右。<br>总的来说，除了拿学位证之外，没有任何意义。（当然，也可以自己赋予意义。可惜的是，我赋予的意义最终也像大部分项目一样烂尾了。因为最初这个项目是为了给墨夏使用的。</p><p>五月另一个重要的事就是拍毕业照了。和不太熟悉的同班同学聊聊近况，和熟悉的朋友聊聊未来打算。<br>有人考上研，后面继续求学；有人考研失败，继续备考；有人和我一样找工作，问我怎么面试的；还有找到实习和我一样当牛马的。<br>大家都有各自的人生轨迹，也有计划，但无一例外地我觉得大家都很迷茫，只是短暂地享受着最后一个月的大学生活。<br>和室友不是一个专业，单独拍了一些照片（下面放个我在中间的宿舍合照吧）。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/2024%E5%B9%B4%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/9-304%E5%AE%BF%E8%88%8D%E5%90%88%E7%85%A7.jpg"                        alt="9-304宿舍合照.jpg"                 ></p><p>最后说下舍友的情况吧，除了我他们都没有干计算机相关的工作。<br>左一，家境不错，回昆山找了个工作。steam全是游戏，三年前只狼就七周末乱杀…是个富哥。<br>左二，河南的小伙，在考公。第一次考就进了面，但面试被刷了，现在也依然在考公。很有梗，是个非常有趣的人。<br>右一，健身快三年了，合照可以看出来练得非常好。现在继续健身，并且在做电商主播（直播、模特、卖货应该）。把爱好当饭吃，很有个性的人。<br>还有一个不在的富哥，大二去澳大利亚留学了。<br>另外两个朋友也大概说下吧，他们在我隔壁宿舍，和我舍友是一个专业，转专业后和我是一个专业。非常巧的是，我们三个宿舍连在一起。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/2024%E5%B9%B4%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/302-303-304.png"                        alt="302-303-304.png"                 ></p><p>左一，考研失败了。在学校附近找了份实习，同时继续备考。是周教授的关门大弟子，实验室唯一的本科生，三年来都没新生加入。搞人工智能高手。<br>右二，富哥，申请了美国的大学，现在也在美国待了很久了。是个心态上很摆的人，但事情做得很好。高考复读了一次，作文偏题吧。很牛逼的人。<br>左二，我们计算机院的章院长，现在被调到生物院了好像。</p><p>六月底，到毕业的时候了。又回了趟学校。<br>回去就两件事</p><ol><li>拿毕业证和学位证</li><li>和朋友们告别</li></ol><p>所有的一切都像走流程一样，没有太大的伤感氛围。<br>和舍友最后聚了一次，后面估计很难再在一起了。（不过他们三个前几天倒是聚了一次</p><h2 id="下半年"><a href="#下半年" class="headerlink" title="下半年"></a>下半年</h2><p>七月一号，我签了劳动合同，继续在这家公司干。还是牛马的生活。<br>不过项目暂时没那么忙了，就是年底会非常地忙。（大概是总部的业绩要求没有达到吧</p><p>七月底搬了次家，搬到现在住的地方。离公司更近了，但离地铁站更远了，为此买了辆山地车。（很烂的车，后悔了<br>搬家是因为原来租的房子涨价了，当初租房也十分地草率。去年的年终里有提<br>今年新租的房子是和同事整租的，他和他老婆原来住在她姐家，六楼的步梯房。因为他老婆怀孕不方便所以换房子。<br>那周末找了个中介和他跑了一下午，看了好几间。有一间是很有矛盾的，很合适的房子，但是才装修一年，他老婆觉得有甲醛所以否决掉了。<br>当时已经要放弃了，同时满足我们俩要求的房子实在是太少了。让中介找了最后一间，也就是这间基本满足了。<br>搬家是真累，我真要吐槽六楼的步梯房。（他俩东西还多</p><p>后面就正常上班，一直到十二月之前都不怎么忙。<br>这段时间看了两本书，《收获，不止Oracle》和《Redis设计与实现》。<br>还有两本本原来是在计划里的。一本是《收获，不止SQL优化》，看了大纲，和开发相关性不大，和DBA的相关性很大，所以就不准备读了。<br>另一本是《Apache Kafka实战》，因为太忙了，暂时也搁置了。这本后面有空还是会读的，在计划中。<br>期间也看了点《Haskell函数式编程入门（第2版）第1卷》，前面的概念太复杂了，而且语法也非常地抽象。可以说和现有的几乎所有编程语言都不一样。<br>最终也是只搭了环境，草草地跟着书写了一点就结束了。</p><p>后面打算自己写个项目，准备用p2p，整了很久也没整出来。研究 BitTorrent协议 和 内网穿透 研究了很久。后面应该会继续做吧<br>最后就是前几天，给鱼排的聊天室节点用go实现了一个版本。经过站长阿达的高强度测试，最终也是上了北京的节点暂时运行一周看看情况。<br>最开始五十多个客户端，阿达疯狂输管理员命令（管理员命令会广播两次，命令本身和系统回复）。会出现卡顿和明显地吞消息情况。<br>再到后来为每个消息都用协程发送，虽然改善了吞消息，但是并发一大就会崩。<br>最后改成为每个ws连接创建协程，终于是稳定了，250左右的连接测试时也非常流畅。（让阿达测上限，说上限是他的硬盘，250个连接电脑已经很卡了）<br>测试过程中，阿达一直说原本的实现就不会这样随便造。真是太欠了。那是netty牛逼，我要是能纯手搓出netty这样的，我做梦都能笑醒。（阿达骂人表情包.jpg）<br>还给我提了个限制流量的需求，真是难搞啊。</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>是非常想换工作的一年，也是面试全部失败的一年，也是我第一次不想写java的一年。<br>想转go，不知前路如何。自己还是和前两年一样迷茫。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2024年过的平平淡淡，让我回忆一下，然后下面就是流水账时间…&lt;/p&gt;
&lt;h2 id=&quot;上半年&quot;&gt;&lt;a href=&quot;#上半年&quot; class=&quot;headerlink&quot; title=&quot;上半年&quot;&gt;&lt;/a&gt;上半年&lt;/h2&gt;&lt;p&gt;上半年都在实习公司度过，因为去年年底项目才上线，年初也</summary>
      
    
    
    
    <category term="记录生活" scheme="https://cooooing.github.io/categories/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="记录生活" scheme="https://cooooing.github.io/tags/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>云服日常被攻击（三）</title>
    <link href="https://cooooing.github.io/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/%E4%BA%91%E6%9C%8D%E6%97%A5%E5%B8%B8%E8%A2%AB%E6%94%BB%E5%87%BB%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://cooooing.github.io/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/%E4%BA%91%E6%9C%8D%E6%97%A5%E5%B8%B8%E8%A2%AB%E6%94%BB%E5%87%BB%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2024-11-28T01:55:13.000Z</published>
    <updated>2024-11-28T01:55:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>又又又被攻击了，这次是通过stp挂在公网的rdp。方便我远程访问家里云。</p><p>起初是看到了v站的一篇帖子：<a class="link"   href="https://v2ex.com/t/1092714" >求助，被入侵了，如何减小损失？<i class="fas fa-external-link-alt"></i></a><br>大致内容就是他通过ftp挂在公网的rdp被入侵了，常用的网站密码都泄露了。</p><p>然后我就想起来，这人的操作和我一样啊。赶紧上服务器看下日志：<br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/%E4%BA%91%E6%9C%8D%E6%97%A5%E5%B8%B8%E8%A2%AB%E6%94%BB%E5%87%BB%EF%BC%88%E4%B8%89%EF%BC%89/%E6%97%A5%E5%BF%971.png"                        alt="日志1"                 ></p><p>看到日志这么大我就知道坏了，进去翻了一下，基本就是几个ip一直在连接：<br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/%E4%BA%91%E6%9C%8D%E6%97%A5%E5%B8%B8%E8%A2%AB%E6%94%BB%E5%87%BB%EF%BC%88%E4%B8%89%EF%BC%89/%E6%97%A5%E5%BF%972.png"                        alt="日志2"                 ></p><p>再去翻一下家里云windows的日志：<br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/%E4%BA%91%E6%9C%8D%E6%97%A5%E5%B8%B8%E8%A2%AB%E6%94%BB%E5%87%BB%EF%BC%88%E4%B8%89%EF%BC%89/%E6%97%A5%E5%BF%973.png"                        alt="日志3"                 ><br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/%E4%BA%91%E6%9C%8D%E6%97%A5%E5%B8%B8%E8%A2%AB%E6%94%BB%E5%87%BB%EF%BC%88%E4%B8%89%EF%BC%89/%E6%97%A5%E5%BF%974.png"                        alt="日志4"                 ></p><p>基本就是用几个用户名在一直尝试，总共试了三万多次，我看日志的时候还在试是最难绷的。<br>把ftp服务听了之后，想想有什么办法防止这种情况。</p><p>windows的服务被暴露出来，首先肯定是从windows源头入手，看看有什么办法阻断。<br>看了windows的安全策略，默认多次登陆失败后账户会被锁定10分钟。<br>这个调不调整问题也不大，因为它似乎跑的是字典，连我的用户名都没试出来。（试出来的概率也不大<br>另外就是加ip黑名单，这个不现实。因为ftp服务，所有的请求都是从公网的服务器转发来的。</p><p>但是在服务器的层面加ip黑名单是可以的。<br>bash脚本我就不是很熟了，连夜和gpt一起写了个脚本，检测ftp的日志，把频繁访问的都加到防火墙的ip黑名单里。<br>最后配置个定时任务运行脚本。就完成了。</p><h2 id="bash-脚本"><a href="#bash-脚本" class="headerlink" title="bash 脚本"></a>bash 脚本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置参数</span></span><br><span class="line">LOG_FILE=<span class="string">&quot;/home/ubuntu/frp/frps.log&quot;</span>        <span class="comment"># 日志文件路径</span></span><br><span class="line">THRESHOLD=100                                <span class="comment"># 黑名单阈值</span></span><br><span class="line">BLACKLIST_FILE=<span class="string">&quot;/home/ubuntu/frp/blacklist.txt&quot;</span>  <span class="comment"># 黑名单文件路径</span></span><br><span class="line">CHAIN_NAME=<span class="string">&quot;FTP-BLACKLIST&quot;</span>                  <span class="comment"># 自定义防火墙链名称</span></span><br><span class="line">LOG_LINES=5000                             <span class="comment"># 只处理最近多少行日志</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建自定义防火墙链（如果不存在）</span></span><br><span class="line">iptables -L <span class="variable">$CHAIN_NAME</span> &amp;&gt; /dev/null</span><br><span class="line"><span class="keyword">if</span> [[ $? -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;创建自定义链: <span class="variable">$CHAIN_NAME</span>&quot;</span></span><br><span class="line">  iptables -N <span class="variable">$CHAIN_NAME</span></span><br><span class="line">  iptables -I INPUT -j <span class="variable">$CHAIN_NAME</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取日志中的 IP 地址并统计（只读最后 LOG_LINES 行）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;解析日志文件最后 <span class="variable">$LOG_LINES</span> 行：<span class="variable">$LOG_FILE</span>&quot;</span></span><br><span class="line">blacklist_ips=$(<span class="built_in">tail</span> -n <span class="string">&quot;<span class="variable">$LOG_LINES</span>&quot;</span> <span class="string">&quot;<span class="variable">$LOG_FILE</span>&quot;</span> \</span><br><span class="line">  | grep -oP <span class="string">&#x27;\b(?:[0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;\b&#x27;</span> \</span><br><span class="line">  | awk <span class="string">&#x27;&#123;counts[$1]++&#125; END &#123;for (ip in counts) if (counts[ip] &gt; &#x27;</span><span class="string">&quot;<span class="variable">$THRESHOLD</span>&quot;</span><span class="string">&#x27;) print ip&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有符合条件的 IP，直接退出</span></span><br><span class="line"><span class="keyword">if</span> [[ -z <span class="string">&quot;<span class="variable">$blacklist_ips</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;没有超过阈值的 IP&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 去重并写入黑名单文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;更新黑名单文件：<span class="variable">$BLACKLIST_FILE</span>&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="subst">$(dirname <span class="string">&quot;<span class="variable">$BLACKLIST_FILE</span>&quot;</span>)</span>&quot;</span></span><br><span class="line"><span class="built_in">touch</span> <span class="string">&quot;<span class="variable">$BLACKLIST_FILE</span>&quot;</span></span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> <span class="variable">$blacklist_ips</span>; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> ! grep -q <span class="string">&quot;^$ip$&quot;</span> <span class="string">&quot;<span class="variable">$BLACKLIST_FILE</span>&quot;</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$ip</span>&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$BLACKLIST_FILE</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取现有防火墙规则里的 IP</span></span><br><span class="line">existing_ips=$(iptables -L <span class="variable">$CHAIN_NAME</span> -v -n \</span><br><span class="line">  | grep -oP <span class="string">&#x27;\b(?:[0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;\b&#x27;</span> \</span><br><span class="line">  | <span class="built_in">sort</span> -u | grep -v <span class="string">&#x27;^0\.0\.0\.0$&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加新 IP 到防火墙</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;更新防火墙黑名单规则&quot;</span></span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> <span class="variable">$blacklist_ips</span>; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$existing_ips</span>&quot;</span> | grep -wq <span class="string">&quot;^$ip$&quot;</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;已存在规则：<span class="variable">$ip</span>&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;添加规则：<span class="variable">$ip</span>&quot;</span></span><br><span class="line">    iptables -A <span class="variable">$CHAIN_NAME</span> -s <span class="string">&quot;<span class="variable">$ip</span>&quot;</span> -j DROP</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;防火墙规则更新完成！&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/10 * * * * bash /home/ubuntu/frp/blacklist.sh &gt;&gt; /home/ubuntu/frp/blacklist.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><blockquote><p><code>2&gt;&amp;1</code>：将标准错误（stderr）重定向到标准输出，这样标准错误也会被追加到同一个日志文件中。</p></blockquote><table><thead><tr><th>名称</th><th>代码</th><th>操作符</th></tr></thead><tbody><tr><td>标准输入(stdin)</td><td>0</td><td>&lt; 或 &lt;&lt;</td></tr><tr><td>标准输出(stdout)</td><td>1</td><td>&gt;,&gt;&gt;,1&gt; 或 1&gt;&gt;</td></tr><tr><td>标准错误输出(stderr)</td><td>2</td><td>2&gt; 或 2&gt;&gt;</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;过程&quot;&gt;&lt;a href=&quot;#过程&quot; class=&quot;headerlink&quot; title=&quot;过程&quot;&gt;&lt;/a&gt;过程&lt;/h2&gt;&lt;p&gt;又又又被攻击了，这次是通过stp挂在公网的rdp。方便我远程访问家里云。&lt;/p&gt;
&lt;p&gt;起初是看到了v站的一篇帖子：&lt;a class=&quot;li</summary>
      
    
    
    
    <category term="编程记录" scheme="https://cooooing.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="网络安全" scheme="https://cooooing.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="云服务器" scheme="https://cooooing.github.io/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="防火墙" scheme="https://cooooing.github.io/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    
  </entry>
  
  <entry>
    <title>《Redis设计与实现》读书笔记-单机数据库的实现</title>
    <link href="https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2024-11-05T01:15:30.000Z</published>
    <updated>2024-11-05T01:15:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第九章-数据库"><a href="#第九章-数据库" class="headerlink" title="第九章 - 数据库"></a>第九章 - 数据库</h2><h3 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h3><p>Redis服务器将所有数据库都保存在服务器状态redis.h&#x2F;redisServer结构的db数组中，db数组的每个项都是一个redis.h&#x2F;redisDb结构，每个redisDb结构代表一个数据库：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 一个数组，保存着服务器中的所有数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在初始化服务器时，程序会根据服务器状态的dbnum属性来决定应该创建多少个数据库：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 服务器的数据库数量</span></span><br><span class="line">    <span class="type">int</span> dbnum;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>dbnum属性的值由服务器配置的database选项决定，默认情况下，该选项的值为16，所以Redis服务器默认会创建16个数据库。</p><h3 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h3><p>每个Redis客户端都有自己的目标数据库，每当客户端执行数据库写命令或者数据库读命令的时候，目标数据库就会成为这些命令的操作对象。<br>默认情况下，Redis客户端的目标数据库为0号数据库，但客户端可以通过执行SELECT命令来切换目标数据库。</p><p>在服务器内部，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个指向redisDb结构的指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 记录客户端当前正在使用的数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure><p>redisClient.db指针指向redisServer.db数组的其中一个元素，而被指向的元素就是客户端的目标数据库。<br>通过修改redisClient.db指针，让它指向服务器中的不同数据库，从而实现切换目标数据库的功能——这就是SELECT命令的实现原理。</p><h3 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h3><p>Redis是一个键值对（key-value pair）数据库服务器，服务器中的每个数据库都由一个redis.h&#x2F;redisDb结构表示。<br>其中，redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间（key space）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>键空间和用户所见的数据库是直接对应的：</p><ul><li>键空间的键也就是数据库的键，每个键都是一个字符串对象。</li><li>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。</li></ul><p>因为数据库的键空间是一个字典，所以所有针对数据库的操作，比如添加一个键值对到数据库，或者从数据库中删除一个键值对，又或者在数据库中获取某个键值对等，实际上都是通过对键空间字典进行操作来实现的。<br>除了这些针对之外，还有很多针对数据库本身的Redis命令，也可以通过对键空间的操作来实现。比如用于清空整个数据库的FLUSHDB命令，就是通过删除键空间中的所有键值对来实现的。</p><p><strong>读写键空间时的维护操作</strong><br>当使用Redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的维护操作，其中包括：</p><ul><li>在读取一个键之后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数，这两个值可以在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看。</li><li>在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用OBJECT idletime命令可以查看键key的闲置时间。</li><li>如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作。</li><li>如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏（dirty），从而让事务程序注意到这个键已经被修改过。</li><li>服务器每次修改一个键之后，都会对脏（dirty）键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作。</li><li>如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知。</li></ul><h3 id="设置键的生存时间或过期时间"><a href="#设置键的生存时间或过期时间" class="headerlink" title="设置键的生存时间或过期时间"></a>设置键的生存时间或过期时间</h3><p>通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time To Live，TTL），在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键。</p><p>SETEX命令可以在设置一个字符串键的同时为键设置过期时间（只能用于字符串键）。<br>与EXPIRE命令和PEXPIRE命令类似，客户端可以通过EXPIREAT命令或PEXPIREAT命令，以秒或者毫秒精度给数据库中的某个键设置过期时间（expire time）。<br><strong>过期时间是一个UNIX时间戳</strong>，当键的过期时间来临时，服务器就会自动从数据库中删除这个键。</p><p>过期时间是一个UNIX时间戳，当键的过期时间来临时，服务器就会自动从数据库中删除这个键。</p><h4 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h4><p>Redis有四个不同的命令可以用于设置键的生存时间（键可以存在多久）或过期时间（键什么时候会被删除）：</p><ul><li><code>EXPIRE &lt;key&gt; &lt;ttl&gt;</code>命令用于将键key的生存时间设置为ttl秒。</li><li><code>PEXPIRE &lt;key&gt; &lt;ttl&gt;</code>命令用于将键key的生存时间设置为ttl毫秒。</li><li><code>EXPIREAT &lt;key&gt; &lt;timestamp&gt;</code>命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳。</li><li><code>PEXPIREAT &lt;key&gt; &lt;timestamp&gt;</code>命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳。</li></ul><p>虽然有多种不同单位和不同形式的设置命令，但实际上EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的：无论客户端执行的是以上四个命令中的哪一个，经过转换之后，最终的执行效果都和执行PEXPIREAT命令一样。</p><h4 id="保存过期时间"><a href="#保存过期时间" class="headerlink" title="保存过期时间"></a>保存过期时间</h4><p>redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典：</p><ul><li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键）。</li><li>过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 过期字典，保存着键的过期时间</span></span><br><span class="line">    dict *expires;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>以下是PEXPIREAT命令的伪代码定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">PEXPIREAT</span>(<span class="params">key, expire_time_in_ms</span>):</span><br><span class="line">    <span class="comment"># 如果给定的键不存在于键空间，那么不能设置过期时间</span></span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> redisDb.<span class="built_in">dict</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 在过期字典中关联键和过期时间</span></span><br><span class="line">    redisDb.expires[key] = expire_time_in_ms</span><br><span class="line">    <span class="comment"># 过期时间设置成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="移除过期时间"><a href="#移除过期时间" class="headerlink" title="移除过期时间"></a>移除过期时间</h4><p>PERSIST命令可以移除一个键的过期时间。<br>PERSIST命令就是PEXPIREAT命令的反操作：PERSIST命令在过期字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联。</p><p>以下是PERSIST命令的伪代码定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">PERSIST</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="comment"># 如果键不存在，或者键没有设置过期时间，那么直接返回</span></span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> redisDb.expires:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 移除过期字典中给定键的键值对关联</span></span><br><span class="line">    redisDb.expires.remove(key)</span><br><span class="line">    <span class="comment"># 键的过期时间移除成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="计算并返回剩余生存时间"><a href="#计算并返回剩余生存时间" class="headerlink" title="计算并返回剩余生存时间"></a>计算并返回剩余生存时间</h4><p>TTL命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒为单位返回键的剩余生存时间。</p><p>TTL和PTTL两个命令都是通过计算键的过期时间和当前时间之间的差来实现的，以下是这两个命令的伪代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">PTTL</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="comment"># 键不存在于数据库</span></span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> redisDb.<span class="built_in">dict</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">2</span></span><br><span class="line">    <span class="comment"># 尝试取得键的过期时间</span></span><br><span class="line">    <span class="comment"># 如果键没有设置过期时间，那么 expire_time_in_ms 将为 None</span></span><br><span class="line">    expire_time_in_ms = redisDb.expires.get(key)</span><br><span class="line">    <span class="comment"># 键没有设置过期时间</span></span><br><span class="line">    <span class="keyword">if</span> expire_time_in_ms <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="comment"># 获得当前时间</span></span><br><span class="line">    now_ms = get_current_unix_timestamp_in_ms()</span><br><span class="line">    <span class="comment"># 过期时间减去当前时间，得出的差就是键的剩余生存时间</span></span><br><span class="line">    <span class="keyword">return</span> (expire_time_in_ms - now_ms)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">TTL</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="comment"># 获取以毫秒为单位的剩余生存时间</span></span><br><span class="line">    ttl_in_ms = PTTL(key)</span><br><span class="line">    <span class="keyword">if</span> ttl_in_ms &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 处理返回值为-2和-1的情况</span></span><br><span class="line">        <span class="keyword">return</span> ttl_in_ms</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 将毫秒转换为秒</span></span><br><span class="line">        <span class="keyword">return</span> ms_to_sec(ttl_in_ms)</span><br></pre></td></tr></table></figure><h4 id="过期键的判定"><a href="#过期键的判定" class="headerlink" title="过期键的判定"></a>过期键的判定</h4><p>通过过期字典，程序可以用以下步骤检查一个给定键是否过期：</p><ol><li>检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间。</li><li>检查当前UNIX时间戳是否大于键的过期时间：如果是的话，那么键已经过期；否则的话，键未过期。</li></ol><p>可以用伪代码来描述这一过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_expired</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="comment"># 取得键的过期时间</span></span><br><span class="line">    expire_time_in_ms = redisDb.expires.get(key)</span><br><span class="line">    <span class="comment"># 键没有设置过期时间</span></span><br><span class="line">    <span class="keyword">if</span> expire_time_in_ms <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 取得当前时间的UNIX时间戳</span></span><br><span class="line">    now_ms = get_current_unix_timestamp_in_ms()</span><br><span class="line">    <span class="comment"># 检查当前时间是否大于键的过期时间</span></span><br><span class="line">    <span class="keyword">if</span> now_ms &gt; expire_time_in_ms:</span><br><span class="line">        <span class="comment"># 是，键已经过期</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 否，键未过期</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>实现过期键判定的另一种方法是使用TTL命令或者PTTL命令，比如说，如果对某个键执行TTL命令，并且命令返回的值大于等于0，那么说明该键未过期。<br>在实际中，Redis检查键是否过期的方法和is_expired函数所描述的方法一致，因为直接访问字典比执行一个命令稍微快一些。</p><h3 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h3><p>如果一个键过期了，那么它什么时候会被删除呢？</p><p>这个问题有三种可能的答案，它们分别代表了三种不同的删除策略：</p><ul><li>定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。</li><li>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。</li><li>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li></ul><p>在这三种策略中，第一种和第三种为主动删除策略，而第二种则为被动删除策略。</p><h4 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h4><p>定时删除策略对内存是最友好的：通过使用定时器，定时删除策略可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存。<br>另一方面，定时删除策略的缺点是，它对CPU时间是最不友好的：在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间，在内存不紧张但是CPU时间非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。</p><p>例如，如果正有大量的命令请求在等待服务器处理，并且服务器当前不缺少内存，那么服务器应该优先将CPU时间用在处理客户端的命令请求上面，而不是用在删除过期键上面。<br>除此之外，创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个事件的时间复杂度为O（N）——并不能高效地处理大量时间事件。<br>因此，要让服务器创建大量的定时器，从而实现定时删除策略，在现阶段来说并不现实。</p><h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>惰性删除策略对CPU时间来说是最友好的：程序只会在取出键时才对键进行过期检查，这可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何CPU时间。<br>惰性删除策略的缺点是，它对内存是最不友好的：如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放。<br>在使用惰性删除策略时，如果数据库中有非常多的过期键，而这些过期键又恰好没有被访问到的话，那么它们也许永远也不会被删除（除非用户手动执行FLUSHDB），我们甚至可以将这种情况看作是一种内存泄漏——无用的垃圾数据占用了大量的内存，而服务器却不会自己去释放它们，这对于运行状态非常依赖于内存的Redis服务器来说，肯定不是一个好消息。</p><p>举个例子，对于一些和时间有关的数据，比如日志（log），在某个时间点之后，对它们的访问就会大大减少，甚至不再访问，如果这类过期数据大量地积压在数据库中，用户以为服务器已经自动将它们删除了，但实际上这些键仍然存在，而且键所占用的内存也没有释放，那么造成的后果肯定是非常严重的。</p><h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p>从上面对定时删除和惰性删除的讨论来看，这两种删除方式在单一使用时都有明显的缺陷：</p><ul><li>惰性删除浪费太多内存，有内存泄漏的危险。</li><li>定时删除占用太多CPU时间，影响服务器的响应时间和吞吐量。</li></ul><p>定期删除策略是前两种策略的一种整合和折中：</p><ul><li>定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li><li>除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费。</li></ul><p>定期删除策略的难点是确定删除操作执行的时长和频率：</p><ul><li>如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将CPU时间过多地消耗在删除过期键上面。</li><li>如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况。</li></ul><p>因此，如果采用定期删除策略的话，服务器必须根据情况，合理地设置删除操作的执行时长和执行频率。<br><strong>任何单一的方案都有各自的优势和不足，因此，通常情况都是将不同的方案组合，以尽可能的利用他们的优势，降低劣势。同时可以根据实际业务需要、服务器性能等实际情况进行调整。</strong></p><h3 id="Redis的过期键删除策略"><a href="#Redis的过期键删除策略" class="headerlink" title="Redis的过期键删除策略"></a>Redis的过期键删除策略</h3><p>Redis服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡。</p><h4 id="惰性删除策略的实现"><a href="#惰性删除策略的实现" class="headerlink" title="惰性删除策略的实现"></a>惰性删除策略的实现</h4><p>过期键的惰性删除策略由db.c&#x2F;expireIfNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查：</p><ul><li>如果输入键已经过期，那么expireIfNeeded函数将输入键从数据库中删除。</li><li>如果输入键未过期，那么expireIfNeeded函数不做动作。</li></ul><p>expireIfNeeded函数就像一个过滤器，它可以在命令真正执行之前，过滤掉过期的输入键，从而避免命令接触到过期键。</p><p>另外，因为每个被访问的键都可能因为过期而被expireIfNeeded函数删除，所以每个命令的实现函数都必须能同时处理键存在以及键不存在这两种情况：</p><ul><li>当键存在时，命令按照键存在的情况执行。</li><li>当键不存在或者键因为过期而被expireIfNeeded函数删除时，命令按照键不存在的情况执行。</li></ul><h4 id="定期删除策略的实现"><a href="#定期删除策略的实现" class="headerlink" title="定期删除策略的实现"></a>定期删除策略的实现</h4><p>过期键的定期删除策略由redis.c&#x2F;activeExpireCycle函数实现，每当Redis的服务器周期性操作redis.c&#x2F;serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。</p><p>整个过程可以用伪代码描述如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认每次检查的数据库数量</span></span><br><span class="line">DEFAULT_DB_NUMBERS = <span class="number">16</span></span><br><span class="line"><span class="comment"># 默认每个数据库检查的键数量</span></span><br><span class="line">DEFAULT_KEY_NUMBERS = <span class="number">20</span></span><br><span class="line"><span class="comment"># 全局变量，记录检查进度</span></span><br><span class="line">current_db = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">activeExpireCycle</span>():</span><br><span class="line">    <span class="comment"># 初始化要检查的数据库数量</span></span><br><span class="line">    <span class="comment"># 如果服务器的数据库数量比 DEFAULT_DB_NUMBERS 要小</span></span><br><span class="line">    <span class="comment"># 那么以服务器的数据库数量为准</span></span><br><span class="line">    <span class="keyword">if</span> server.dbnum &lt; DEFAULT_DB_NUMBERS:</span><br><span class="line">        db_numbers = server.dbnum</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        db_numbers = DEFAULT_DB_NUMBERS</span><br><span class="line">    <span class="comment"># 遍历各个数据库</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(db_numbers):</span><br><span class="line">        <span class="comment"># 如果current_db的值等于服务器的数据库数量</span></span><br><span class="line">        <span class="comment"># 这表示检查程序已经遍历了服务器的所有数据库一次</span></span><br><span class="line">        <span class="comment"># 将current_db重置为0，开始新的一轮遍历</span></span><br><span class="line">        <span class="keyword">if</span> current_db == server.dbnum:</span><br><span class="line">            current_db = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 获取当前要处理的数据库</span></span><br><span class="line">        redisDb = server.db[current_db]</span><br><span class="line">        <span class="comment"># 将数据库索引增1，指向下一个要处理的数据库</span></span><br><span class="line">        current_db += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 检查数据库键</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(DEFAULT_KEY_NUMBERS):</span><br><span class="line">            <span class="comment"># 如果数据库中没有一个键带有过期时间，那么跳过这个数据库</span></span><br><span class="line">            <span class="keyword">if</span> redisDb.expires.size() == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 随机获取一个带有过期时间的键</span></span><br><span class="line">            key_with_ttl = redisDb.expires.get_random_key()</span><br><span class="line">            <span class="comment"># 检查键是否过期，如果过期就删除它</span></span><br><span class="line">            <span class="keyword">if</span> is_expired(key_with_ttl):</span><br><span class="line">                delete_key(key_with_ttl)</span><br><span class="line">            <span class="comment"># 已达到时间上限，停止处理</span></span><br><span class="line">            <span class="keyword">if</span> reach_time_limit(): <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>activeExpireCycle函数的工作模式可以总结如下：</p><ul><li>函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键。</li><li>全局变量current_db会记录当前activeExpireCycle函数检查的进度，并在下一次activeExpireCycle函数调用时，接着上一次的进度进行处理。比如说，如果当前activeExpireCycle函数在遍历10号数据库时返回了，那么下次activeExpireCycle函数执行时，将从11号数据库开始查找并删除过期键。</li><li>随着activeExpireCycle函数的不断执行，服务器中的所有数据库都会被检查一遍，这时函数将current_db变量重置为0，然后再次开始新一轮的检查工作。</li></ul><h3 id="AOF、RDB和复制功能对过期键的处理"><a href="#AOF、RDB和复制功能对过期键的处理" class="headerlink" title="AOF、RDB和复制功能对过期键的处理"></a>AOF、RDB和复制功能对过期键的处理</h3><p>看看过期键对Redis服务器中其他模块的影响，看看RDB持久化功能、AOF持久化功能以及复制功能是如何处理数据库中的过期键的。</p><h4 id="生成RDB文件"><a href="#生成RDB文件" class="headerlink" title="生成RDB文件"></a>生成RDB文件</h4><p>在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。<br>数据库中包含过期键不会对生成新的RDB文件造成影响。</p><h4 id="载入RDB文件"><a href="#载入RDB文件" class="headerlink" title="载入RDB文件"></a>载入RDB文件</h4><p>在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：</p><ul><li>如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。</li><li>如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入RDB文件的从服务器也不会造成影响。</li></ul><h4 id="AOF文件写入"><a href="#AOF文件写入" class="headerlink" title="AOF文件写入"></a>AOF文件写入</h4><p>当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。<br>当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加（append）一条DEL命令，来显式地记录该键已被删除。</p><p>举个例子，如果客户端使用GET message命令，试图访问过期的message键，那么服务器将执行以下三个动作：</p><ol><li>从数据库中删除message键。</li><li>追加一条DEL message命令到AOF文件。</li><li>向执行GET命令的客户端返回空回复。</li></ol><h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>和生成RDB文件时类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。<br>数据库中包含过期键不会对AOF重写造成影响。</p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制：</p><ul><li>主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。</li><li>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。</li><li>从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。</li></ul><p>通过由主服务器来控制从服务器统一地删除过期键，可以保证主从服务器数据的一致性，也正是因为这个原因，当一个过期键仍然存在于主服务器的数据库时，这个过期键在从服务器里的复制品也会继续存在。</p><p><strong>在主从复制中，数据一致性至关重要。</strong> 主从服务器常用于读写分离，允许从服务器延迟一定的状态同步来提升读性能。</p><h3 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h3><p>数据库通知是Redis 2.8版本新增加的功能，这个功能可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况。</p><p>关注“某个键执行了什么命令”的通知称为<strong>键空间通知（key-space notification）</strong>，<br>除此之外，还有另一类称为<strong>键事件通知（key-event notification）</strong> 的通知，它们关注的是“某个命令被什么键执行了”。</p><p>服务器配置的 <code>notify-keyspace-events</code> 选项决定了服务器所发送通知的类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.</span><br><span class="line">E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.</span><br><span class="line">g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...</span><br><span class="line">$     String commands</span><br><span class="line">l     List commands</span><br><span class="line">s     Set commands</span><br><span class="line">h     Hash commands</span><br><span class="line">z     Sorted set commands</span><br><span class="line">t     Stream commands</span><br><span class="line">d     Module key type events</span><br><span class="line">x     Expired events (events generated every time a key expires)</span><br><span class="line">e     Evicted events (events generated when a key is evicted for maxmemory)</span><br><span class="line">m     Key miss events (events generated when a key that doesn&#x27;t exist is accessed)</span><br><span class="line">n     New key events (Note: not included in the &#x27;A&#x27; class)</span><br><span class="line">A     Alias for &quot;g$lshztxed&quot;, so that the &quot;AKE&quot; string means all the events except &quot;m&quot; and &quot;n&quot;.</span><br></pre></td></tr></table></figure><p>更多设置信息，可以参考官方文档：<a class="link"   href="https://redis.io/docs/latest/develop/use/keyspace-notifications/" >Redis keyspace notifications<i class="fas fa-external-link-alt"></i></a>。</p><h4 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h4><p>发送数据库通知的功能是由notify.c&#x2F;notifyKeyspaceEvent函数实现的： <code>void notifyKeyspaceEvent(int type,char *event,robj *key,int dbid);</code></p><p>函数的 type 参数是当前想要发送的通知的类型，程序会根据这个值来判断通知是否就是服务器配置 notify-keyspace-events 选项所选定的通知类型，从而决定是否发送通知。<br>event、keys 和 dbid 分别是事件的名称、产生事件的键，以及产生事件的数据库号码，函数会根据 type 参数以及这三个参数来构建事件通知的内容，以及接收通知的频道名。<br>每当一个Redis命令需要发送数据库通知的时候，该命令的实现函数就会调用 notify-KeyspaceEvent 函数，并向函数传递传递该命令所引发的事件的相关信息。</p><h4 id="发送通知的实现"><a href="#发送通知的实现" class="headerlink" title="发送通知的实现"></a>发送通知的实现</h4><p>以下是notifyKeyspaceEvent函数的伪代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">notifyKeyspaceEvent</span>(<span class="params"><span class="built_in">type</span>, event, key, dbid</span>):</span><br><span class="line">    <span class="comment"># 如果给定的通知不是服务器允许发送的通知，那么直接返回</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (server.notify_keyspace_events &amp; <span class="built_in">type</span>):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 发送键空间通知</span></span><br><span class="line">    <span class="keyword">if</span> server.notify_keyspace_events &amp; REDIS_NOTIFY_KEYSPACE:</span><br><span class="line">        <span class="comment"># 将通知发送给频道__keyspace@&lt;dbid&gt;__:&lt;key&gt;</span></span><br><span class="line">        <span class="comment"># 内容为键所发生的事件 &lt;event&gt;</span></span><br><span class="line">        <span class="comment"># 构建频道名字</span></span><br><span class="line">        chan = <span class="string">&quot;__keyspace@&#123;dbid&#125;__:&#123;key&#125;&quot;</span>.<span class="built_in">format</span>(dbid=dbid, key=key)</span><br><span class="line">        <span class="comment"># 发送通知</span></span><br><span class="line">        pubsubPublishMessage(chan, event)</span><br><span class="line">    <span class="comment"># 发送键事件通知</span></span><br><span class="line">    <span class="keyword">if</span> server.notify_keyspace_events &amp; REDIS_NOTIFY_KEYEVENT:</span><br><span class="line">        <span class="comment"># 将通知发送给频道__keyevent@&lt;dbid&gt;__:&lt;event&gt;</span></span><br><span class="line">        <span class="comment"># 内容为发生事件的键 &lt;key&gt;</span></span><br><span class="line">        <span class="comment"># 构建频道名字</span></span><br><span class="line">        chan = <span class="string">&quot;__keyevent@&#123;dbid&#125;__:&#123;event&#125;&quot;</span>.<span class="built_in">format</span>(dbid=dbid, event=event)</span><br><span class="line">        <span class="comment"># 发送通知</span></span><br><span class="line">        pubsubPublishMessage(chan, key)</span><br></pre></td></tr></table></figure><p>notifyKeyspaceEvent 函数执行以下操作：</p><ol><li>server.notify_keyspace_events 属性就是服务器配置 notify-keyspace-events 选项所设置的值，如果给定的通知类型type不是服务器允许发送的通知类型，那么函数会直接返回，不做任何动作。</li><li>如果给定的通知是服务器允许发送的通知，那么下一步函数会检测服务器是否允许发送键空间通知，如果允许的话，程序就会构建并发送事件通知。</li><li>最后，函数检测服务器是否允许发送键事件通知，如果允许的话，程序就会构建并发送事件通知。</li></ol><p>另外，pubsubPublishMessage 函数是 PUBLISH 命令的实现函数，执行这个函数等同于执行PUBLISH命令，订阅数据库通知的客户端收到的信息就是由这个函数发出的。</p><h2 id="第十章-RDB持久化"><a href="#第十章-RDB持久化" class="headerlink" title="第十章 - RDB持久化"></a>第十章 - RDB持久化</h2><p>Redis是一个键值对数据库服务器，服务器中通常包含着任意个非空数据库，而每个非空数据库中又可以包含任意个键值对，为了方便起见，我们将服务器中的非空数据库以及它们的键值对统称为数据库状态。</p><p>下面展示了一个包含三个非空数据库的Redis服务器，这三个数据库以及数据库中的键值对就是该服务器的数据库状态。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8A%B6%E6%80%81%E7%A4%BA%E4%BE%8B.png"                        alt="数据库状态示例.png"                 ></p><p>因为Redis是内存数据库，它将自己的数据库状态储存在内存里面，所以如果不想办法将储存在内存中的数据库状态保存到磁盘里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失不见。<br>为了解决这个问题，Redis提供了RDB持久化功能，这个功能可以将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失。</p><p>RDB持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某个时间点上的数据库状态保存到一个RDB文件中。<br>RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态。</p><p>因为RDB文件是保存在硬盘里面的，所以即使Redis服务器进程退出，甚至运行Redis服务器的计算机停机，但只要RDB文件仍然存在，Redis服务器就可以用它来还原数据库状态。</p><h3 id="RDB文件的创建与载入"><a href="#RDB文件的创建与载入" class="headerlink" title="RDB文件的创建与载入"></a>RDB文件的创建与载入</h3><p>有两个Redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE。</p><p><strong>SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止</strong>，在服务器进程阻塞期间，服务器不能处理任何命令请求。<br>和SAVE命令直接阻塞服务器进程的做法不同，<strong>BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。</strong></p><p>创建RDB文件的实际工作由rdb.c&#x2F;rdbSave函数完成，SAVE命令和BGSAVE命令会以不同的方式调用这个函数，通过以下伪代码可以明显地看出这两个命令之间的区别：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">SAVE</span>():</span><br><span class="line">    <span class="comment"># 创建RDB文件</span></span><br><span class="line">    rdbSave()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">BGSAVE</span>():</span><br><span class="line">    <span class="comment"># 创建子进程</span></span><br><span class="line">    pid = fork()</span><br><span class="line">    <span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 子进程负责创建RDB文件</span></span><br><span class="line">        rdbSave()</span><br><span class="line">        <span class="comment"># 完成之后向父进程发送信号</span></span><br><span class="line">        signal_parent()</span><br><span class="line">    <span class="keyword">elif</span> pid &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 父进程继续处理命令请求，并通过轮询等待子进程的信号</span></span><br><span class="line">        handle_request_and_wait_signal()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 处理出错情况</span></span><br><span class="line">        handle_fork_error()</span><br></pre></td></tr></table></figure><p>和使用SAVE命令或者BGSAVE命令创建RDB文件不同，RDB文件的载入工作是在服务器启动时自动执行的，所以Redis并没有专门用于载入RDB文件的命令，只要Redis服务器在启动时检测到RDB文件存在，它就会自动载入RDB文件。</p><p>另外值得一提的是，因为AOF文件的更新频率通常比RDB文件的更新频率高，所以：</p><ul><li>如果服务器开启了AOF持久化功能，那么服务器会<strong>优先使用AOF文件</strong>来还原数据库状态。</li><li>只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。</li></ul><h4 id="SAVE命令执行时的服务器状态"><a href="#SAVE命令执行时的服务器状态" class="headerlink" title="SAVE命令执行时的服务器状态"></a>SAVE命令执行时的服务器状态</h4><p>前面提到过，当SAVE命令执行时，Redis服务器会被阻塞，所以当SAVE命令正在执行时，客户端发送的所有命令请求都会被拒绝。<br>只有在服务器执行完SAVE命令、重新开始接受命令请求之后，客户端发送的命令才会被处理。</p><h4 id="BGSAVE命令执行时的服务器状态"><a href="#BGSAVE命令执行时的服务器状态" class="headerlink" title="BGSAVE命令执行时的服务器状态"></a>BGSAVE命令执行时的服务器状态</h4><p>因为 BGSAVE 命令的保存工作是由子进程执行的，所以在子进程创建 RDB 文件的过程中， Redis 服务器仍然可以继续处理客户端的命令请求。<br>但是，在 BGSAVE 命令执行期间，服务器处理 SAVE 、 BGSAVE 、 BGREWRITEAOF 三个命令的方式会和平时有所不同。</p><p>首先，在 BGSAVE 命令执行期间，客户端发送的 SAVE 命令会被服务器拒绝，服务器禁止 SAVE 命令和 BGSAVE 命令同时执行是为了避免父进程（服务器进程）和子进程同时执行两个 rdbSave 调用，防止产生竞争条件。<br>其次，在 BGSAVE 命令执行期间，客户端发送的 BGSAVE 命令会被服务器拒绝，因为同时执行两个 BGSAVE 命令也会产生竞争条件。<br>最后， BGREWRITEAOF 和 BGSAVE 两个命令不能同时执行：</p><ul><li>如果 BGSAVE 命令正在执行，那么客户端发送的 BGREWRITEAOF 命令会被延迟到 BGSAVE 命令执行完毕之后执行。</li><li>如果 BGREWRITEAOF 命令正在执行，那么客户端发送的 BGSAVE 命令会被服务器拒绝。</li></ul><p>因为 BGREWRITEAOF 和 BGSAVE 两个命令的实际工作都由子进程执行，所以这两个命令在操作方面并没有什么冲突的地方。<br>不能同时执行它们只是一个性能方面的考虑——并发出两个子进程，并且这两个子进程都同时执行大量的磁盘写入操作，这怎么想都不会是一个好主意。</p><h4 id="RDB文件载入时的服务器状态"><a href="#RDB文件载入时的服务器状态" class="headerlink" title="RDB文件载入时的服务器状态"></a>RDB文件载入时的服务器状态</h4><p><strong>服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止。</strong></p><h3 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h3><p>SAVE命令由服务器进程执行保存工作，BGSAVE命令则由子进程执行保存工作，所以SAVE命令会阻塞服务器，而BGSAVE命令则不会。</p><p>因为BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以Redis允许用户通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令。<br>用户可以通过save选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行BGSAVE命令。</p><h4 id="设置保存条件"><a href="#设置保存条件" class="headerlink" title="设置保存条件"></a>设置保存条件</h4><p>当Redis服务器启动时，用户可以通过指定配置文件或者传入启动参数的方式设置save选项，如果用户没有主动设置save选项，那么服务器会为save选项设置默认条件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><ul><li>服务器在900秒之内，对数据库进行了至少1次修改。</li><li>服务器在300秒之内，对数据库进行了至少10次修改。</li><li>服务器在60秒之内，对数据库进行了至少10000次修改。</li></ul><p>接着，服务器程序会根据save选项所设置的保存条件，设置服务器状态redisServer结构的saveparams属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 记录了保存条件的数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparams</span>;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>saveparams属性是一个数组，数组中的每个元素都是一个saveparam结构，每个saveparam结构都保存了一个save选项设置的保存条件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> &#123;</span></span><br><span class="line">    <span class="comment">// 秒数</span></span><br><span class="line">    <span class="type">time_t</span> seconds;</span><br><span class="line">    <span class="comment">// 修改数</span></span><br><span class="line">    <span class="type">int</span> changes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="dirty-计数器和-lastsave-属性"><a href="#dirty-计数器和-lastsave-属性" class="headerlink" title="dirty 计数器和 lastsave 属性"></a>dirty 计数器和 lastsave 属性</h4><p>除了 saveparams 数组之外，服务器状态还维持着一个 dirty 计数器，以及一个 lastsave 属性：</p><ul><li>dirty 计数器记录距离上一次成功执行 SAVE 命令或者 BGSAVE 命令之后，服务器对数据库状态（服务器中的所有数据库）进行了多少次修改（包括写入、删除、更新等操作）。</li><li>lastsave 属性是一个 UNIX 时间戳，记录了服务器上一次成功执行 SAVE 命令或者 BGSAVE 命令的时间。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 修改计数器</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> dirty;</span><br><span class="line">    <span class="comment">// 上一次执行保存的时间</span></span><br><span class="line">    <span class="type">time_t</span> lastsave;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当服务器成功执行一个数据库修改命令之后，程序就会对dirty计数器进行更新：命令修改了多少次数据库，dirty计数器的值就增加多少。</p><h4 id="检查保存条件是否满足"><a href="#检查保存条件是否满足" class="headerlink" title="检查保存条件是否满足"></a>检查保存条件是否满足</h4><p>Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足的话，就执行BGSAVE命令。</p><p>以下伪代码展示了serverCron函数检查保存条件的过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">serverCron</span>():</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="comment"># 遍历所有保存条件</span></span><br><span class="line">    <span class="keyword">for</span> saveparam <span class="keyword">in</span> server.saveparams:</span><br><span class="line">        <span class="comment"># 计算距离上次执行保存操作有多少秒</span></span><br><span class="line">        save_interval = unixtime_now() - server.lastsave</span><br><span class="line">        <span class="comment"># 如果数据库状态的修改次数超过条件所设置的次数</span></span><br><span class="line">        <span class="comment"># 并且距离上次保存的时间超过条件所设置的时间</span></span><br><span class="line">        <span class="comment"># 那么执行保存操作</span></span><br><span class="line">        <span class="keyword">if</span> server.dirty &gt;= saveparam.changes <span class="keyword">and</span> save_interval &gt; saveparam.seconds:</span><br><span class="line">            BGSAVE()</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>程序会遍历并检查saveparams数组中的所有保存条件，只要有任意一个条件被满足，那么服务器就会执行BGSAVE命令。</p><h3 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h3><p>RDB文件结构如下：</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/RDB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png"                        alt="RDB文件结构.png"                 ></p><p>RDB文件的最开头是REDIS部分，这个部分的长度为5字节，保存着“REDIS”五个字符。通过这五个字符，程序可以在载入文件时，快速检查所载入的文件是否RDB文件。<br>因为RDB文件保存的是二进制数据，而不是C字符串，为了简便起见，我们用”REDIS”符号代表’R’、’E’、’D’、’I’、’S’五个字符，而不是带’\0’结尾符号的C字符串’R’、’E’、’D’、’I’、’S’、’\0’。后续关于RDB文件的结构都是这样。</p><p>db_version长度为4字节，它的值是一个字符串表示的整数，这个整数记录了RDB文件的版本号，比如”0006”就代表RDB文件的版本为第六版。这里介绍的也是第六版RDB文件的结构。（虽然我看这本书的时候，redis最新版本已经是7.4.1了。）<br>databases部分包含着零个或任意多个数据库，以及各个数据库中的键值对数据：</p><ul><li>如果服务器的数据库状态为空（所有数据库都是空的），那么这个部分也为空，长度为0字节。</li><li>如果服务器的数据库状态为非空（有至少一个数据库非空），那么这个部分也为非空，根据数据库所保存键值对的数量、类型和内容不同，这个部分的长度也会有所不同。</li></ul><p>EOF常量的长度为1字节，这个常量标志着RDB文件正文内容的结束，当读入程序遇到这个值的时候，它知道所有数据库的所有键值对都已经载入完毕了。<br>check_sum是一个8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对REDIS、db_version、databases、EOF四个部分的内容进行计算得出的。服务器在载入RDB文件时，会将载入数据所计算出的校验和与check_sum所记录的校验和进行对比，以此来检查RDB文件是否有出错或者损坏的情况出现。</p><h4 id="databases部分"><a href="#databases部分" class="headerlink" title="databases部分"></a>databases部分</h4><p>一个RDB文件的databases部分可以保存任意多个非空数据库。</p><p>例如，如果服务器的0号数据库和3号数据库非空，那么服务器将创建一个如图所示的RDB文件，图中的database 0代表0号数据库中的所有键值对数据，而database 3则代表3号数据库中的所有键值对数据。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E5%B8%A6%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%9D%9E%E7%A9%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84RDB%E6%96%87%E4%BB%B6%E7%A4%BA%E4%BE%8B.png"                        alt="带有两个非空数据库的RDB文件示例.png"                 ></p><p>每个非空数据库在RDB文件中都可以保存为SELECTDB、db_number、key_value_pairs三个部分。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/RDB%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84.png"                        alt="RDB文件中的数据库结构.png"                 ></p><p>SELECTDB常量的长度为1字节，当读入程序遇到这个值的时候，它知道接下来要读入的将是一个数据库号码。<br>db_number保存着一个数据库号码，根据号码的大小不同，这个部分的长度可以是1字节、2字节或者5字节。当程序读入db_number部分之后，服务器会调用SELECT命令，根据读入的数据库号码进行数据库切换，使得之后读入的键值对可以载入到正确的数据库中。<br>key_value_pairs部分保存了数据库中的所有键值对数据，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起。根据键值对的数量、类型、内容以及是否有过期时间等条件的不同，key_value_pairs部分的长度也会有所不同。</p><h4 id="key-value-pairs部分"><a href="#key-value-pairs部分" class="headerlink" title="key_value_pairs部分"></a>key_value_pairs部分</h4><p>RDB文件中的每个key_value_pairs部分都保存了一个或以上数量的键值对，如果键值对带有过期时间的话，那么键值对的过期时间也会被保存在内。</p><p>不带过期时间的键值对在RDB文件中由<strong>TYPE、key、value</strong>三部分组成。</p><p>TYPE记录了value的类型，长度为1字节，值可以是以下常量的其中一个：</p><ul><li>REDIS_RDB_TYPE_STRING</li><li>REDIS_RDB_TYPE_LIST</li><li>REDIS_RDB_TYPE_SET</li><li>REDIS_RDB_TYPE_ZSET</li><li>REDIS_RDB_TYPE_HASH</li><li>REDIS_RDB_TYPE_LIST_ZIPLIST</li><li>REDIS_RDB_TYPE_SET_INTSET</li><li>REDIS_RDB_TYPE_ZSET_ZIPLIST</li><li>REDIS_RDB_TYPE_HASH_ZIPLIST</li></ul><p>以上列出的每个TYPE常量都代表了一种对象类型或者底层编码，当服务器读入RDB文件中的键值对数据时，程序会根据TYPE的值来决定如何读入和解释value的数据。key和value分别保存了键值对的键对象和值对象：</p><ul><li>其中key总是一个字符串对象，它的编码方式和REDIS_RDB_TYPE_STRING类型的value一样。根据内容长度的不同，key的长度也会有所不同。</li><li>根据TYPE类型的不同，以及保存内容长度的不同，保存value的结构和长度也会有所不同，稍后会详细说明每种TYPE类型的value结构保存方式。</li></ul><p>带有过期时间的键值对在RDB文件中由<strong>EXPIRETIME_MS、ms、TYPE、key、value</strong>五部分组成。</p><ul><li>EXPIRETIME_MS常量的长度为1字节，它告知读入程序，接下来要读入的将是一个以毫秒为单位的过期时间。</li><li>ms是一个8字节长的带符号整数，记录着一个以毫秒为单位的UNIX时间戳，这个时间戳就是键值对的过期时间。</li></ul><h4 id="value的编码"><a href="#value的编码" class="headerlink" title="value的编码"></a>value的编码</h4><p>RDB文件中的每个value部分都保存了一个值对象，每个值对象的类型都由与之对应的TYPE记录，根据类型的不同，value部分的结构、长度也会有所不同。</p><h5 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h5><p>如果TYPE的值为REDIS_RDB_TYPE_STRING，那么value保存的就是一个字符串对象，字符串对象的编码可以是REDIS_ENCODING_INT或者REDIS_ENCODING_RAW。</p><p>如果字符串对象的编码为REDIS_ENCODING_INT，那么说明对象中保存的是长度不超过32位的整数。<br>其中，ENCODING的值可以是REDIS_RDB_ENC_INT8、REDIS_RDB_ENC_INT16或者REDIS_RDB_ENC_INT32三个常量的其中一个，它们分别代表RDB文件使用8位（bit）、16位或者32位来保存整数值integer。</p><p>INT编码字符串对象的保存结构<br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/INT%E7%BC%96%E7%A0%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%84.png"                        alt="INT编码字符串对象的保存结构.png"                 ></p><p>如果字符串对象的编码为REDIS_ENCODING_RAW，那么说明对象所保存的是一个字符串值，根据字符串长度的不同，有压缩和不压缩两种方法来保存这个字符串：</p><ul><li>如果字符串的长度小于等于20字节，那么这个字符串会直接被原样保存。</li><li>如果字符串的长度大于20字节，那么这个字符串会被压缩之后再保存。</li></ul><p>以上两个条件是在假设服务器打开了RDB文件压缩功能的情况下进行的，如果服务器关闭了RDB文件压缩功能，那么RDB程序总以无压缩的方式保存字符串值。<br>具体信息可以参考redis.conf文件中关于rdbcompression选项的说明。</p><p>对于没有被压缩的字符串，RDB程序会以下图所示的结构来保存该字符串。<br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E6%97%A0%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%84.png"                        alt="无压缩字符串的保存结构.png"                 ></p><p>其中，string部分保存了字符串值本身，而len保存了字符串值的长度。<br>对于压缩后的字符串，RDB程序会以下图所示的结构来保存该字符串。<br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E5%8E%8B%E7%BC%A9%E5%90%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%84.png"                        alt="压缩后字符串的保存结构.png"                 ></p><p>其中，REDIS_RDB_ENC_LZF常量标志着字符串已经被<a class="link"   href="http://liblzf.plan9.de/" >LZF算法<i class="fas fa-external-link-alt"></i></a>压缩过了，读入程序在碰到这个常量时，会根据之后的compressed_len、origin_len和compressed_string三部分，对字符串进行解压缩：<br>其中compressed_len记录的是字符串被压缩之后的长度，而origin_len记录的是字符串原来的长度，compressed_string记录的则是被压缩之后的字符串。</p><h5 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h5><p>如果TYPE的值为REDIS_RDB_TYPE_LIST，那么value保存的就是一个REDIS_ENCODING_LINKEDLIST编码的列表对象，RDB文件保存这种对象的结构如下图所示。<br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/LINKEDLIST%E7%BC%96%E7%A0%81%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%84.png"                        alt="LINKEDLIST编码列表对象的保存结构.png"                 ></p><p>list_length记录了列表的长度，它记录列表保存了多少个项（item），读入程序可以通过这个长度知道自己应该读入多少个列表项。<br>图中以item开头的部分代表列表的项，因为每个列表项都是一个字符串对象，所以程序会以处理字符串对象的方式来保存和读入列表项。</p><h5 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h5><p>如果TYPE的值为REDIS_RDB_TYPE_SET，那么value保存的就是一个REDIS_ENCODING_HT编码的集合对象，RDB文件保存这种对象的结构如下图所示。<br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/HT%E7%BC%96%E7%A0%81%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%84.png"                        alt="HT编码集合对象的保存结构.png"                 ></p><p>其中，set_size是集合的大小，它记录集合保存了多少个元素，读入程序可以通过这个大小知道自己应该读入多少个集合元素。<br>图中以elem开头的部分代表集合的元素，因为每个集合元素都是一个字符串对象，所以程序会以处理字符串对象的方式来保存和读入集合元素。</p><h5 id="哈希表对象"><a href="#哈希表对象" class="headerlink" title="哈希表对象"></a>哈希表对象</h5><p>如果TYPE的值为REDIS_RDB_TYPE_HASH，那么value保存的就是一个REDIS_ENCODING_HT编码的集合对象，RDB文件保存这种对象的结构下图所示：</p><ul><li>hash_size记录了哈希表的大小，也即是这个哈希表保存了多少键值对，读入程序可以通过这个大小知道自己应该读入多少个键值对。</li><li>以key_value_pair开头的部分代表哈希表中的键值对，键值对的键和值都是字符串对象，所以程序会以处理字符串对象的方式来保存和读入键值对。</li></ul><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/HT%E7%BC%96%E7%A0%81%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%84.png"                        alt="HT编码哈希表对象的保存结构.png"                 ></p><p>结构中的每个键值对（key_value_pair）都以键紧挨着值的方式排列在一起。</p><h5 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h5><p>如果TYPE的值为REDIS_RDB_TYPE_ZSET，那么value保存的就是一个REDIS_ENCODING_SKIPLIST编码的有序集合对象，RDB文件保存这种对象的结构如图10-34所示。<br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/SKIPLIST%E7%BC%96%E7%A0%81%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%84.png"                        alt="SKIPLIST编码有序集合对象的保存结构.png"                 ></p><p>sorted_set_size记录了有序集合的大小，也即是这个有序集合保存了多少元素，读入程序需要根据这个值来决定应该读入多少有序集合元素。<br>以element开头的部分代表有序集合中的元素，每个元素又分为成员（member）和分值（score）两部分，成员是一个字符串对象，分值则是一个double类型的浮点数，程序在保存RDB文件时会先将分值转换成字符串对象，然后再用保存字符串对象的方法将分值保存起来。</p><h5 id="INTSET编码的集合"><a href="#INTSET编码的集合" class="headerlink" title="INTSET编码的集合"></a>INTSET编码的集合</h5><p>如果TYPE的值为REDIS_RDB_TYPE_SET_INTSET，那么value保存的就是一个整数集合对象，RDB文件保存这种对象的方法是，先将整数集合转换为字符串对象，然后将这个字符串对象保存到RDB文件里面。<br>如果程序在读入RDB文件的过程中，碰到由整数集合对象转换成的字符串对象，那么程序会根据TYPE值的指示，先读入字符串对象，再将这个字符串对象转换成原来的整数集合对象。</p><h5 id="ZIPLIST编码的列表、哈希表或者有序集合"><a href="#ZIPLIST编码的列表、哈希表或者有序集合" class="headerlink" title="ZIPLIST编码的列表、哈希表或者有序集合"></a>ZIPLIST编码的列表、哈希表或者有序集合</h5><p>如果TYPE的值为REDIS_RDB_TYPE_LIST_ZIPLIST、REDIS_RDB_TYPE_HASH_ZIPLIST或者REDIS_RDB_TYPE_ZSET_ZIPLIST，那么value保存的就是一个压缩列表对象，RDB文件保存这种对象的方法是：</p><ol><li>将压缩列表转换成一个字符串对象。</li><li>将转换所得的字符串对象保存到RDB文件。</li></ol><p>如果程序在读入RDB文件的过程中，碰到由压缩列表对象转换成的字符串对象，那么程序会根据TYPE值的指示，执行以下操作：</p><ol><li>读入字符串对象，并将它转换成原来的压缩列表对象。</li><li>根据TYPE的值，设置压缩列表对象的类型：如果TYPE的值为REDIS_RDB_TYPE_LIST_ZIPLIST，那么压缩列表对象的类型为列表；如果TYPE的值为REDIS_RDB_TYPE_HASH_ZIPLIST，那么压缩列表对象的类型为哈希表；如果TYPE的值为REDIS_RDB_TYPE_ZSET_ZIPLIST，那么压缩列表对象的类型为有序集合。</li></ol><p>从步骤2可以看出，由于TYPE的存在，即使列表、哈希表和有序集合三种类型都使用压缩列表来保存，RDB读入程序也总可以将读入并转换之后得出的压缩列表设置成原来的类型。</p><h3 id="分析RDB文件"><a href="#分析RDB文件" class="headerlink" title="分析RDB文件"></a>分析RDB文件</h3><p>使用od命令来分析Redis服务器产生的RDB文件，该命令可以用给定的格式转存（dump）并打印输入文件。<br>比如说，给定-c参数可以以ASCII编码的方式打印输入文件，给定-x参数可以以十六进制的方式打印输入文件，诸如此类，具体的信息可以参考od命令的文档。</p><h4 id="不包含任何键值对的RDB文件"><a href="#不包含任何键值对的RDB文件" class="headerlink" title="不包含任何键值对的RDB文件"></a>不包含任何键值对的RDB文件</h4><p>使用 <code>FLUSHALL</code> 清空数据库，使用 <code>SAVE</code> 创建一个数据库状态为空的RDB文件。<br>使用od命令，打印RDB文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@b9283e6096c1:/data# od -c dump.rdb</span><br><span class="line">0000000   R   E   D   I   S   0   0   1   2 372  \t   r   e   d   i   s</span><br><span class="line">0000020   -   v   e   r 005   7   .   4   .   1 372  \n   r   e   d   i</span><br><span class="line">0000040   s   -   b   i   t   s 300   @ 372 005   c   t   i   m   e 302</span><br><span class="line">0000060   g   d   1   g 372  \b   u   s   e   d   -   m   e   m 302   X</span><br><span class="line">0000100 316 021  \0 372  \b   a   o   f   -   b   a   s   e 300  \0 377</span><br><span class="line">0000120 272 257 332 306 334 330 026   w</span><br><span class="line">0000130</span><br></pre></td></tr></table></figure><p>第 7 版中新增加的操作符，以 0xFA （372 8进制） 作为标志。<br>可以存放多组 key-value，用来表示对应元信息。<br>每一对 key-value，都以0xFA 开头。key 和 value 均采用 rdb 字符串编码方法。 默认元信息列表：</p><ul><li>redis-ver：redis 版本信息。</li><li>redis-bits：输出 rdb 文件机器的位数，64bit 或 32 bit。</li><li>ctime：rdb 文件创建时间。</li><li>used-mem：rdb 加载到内存中的内存使用量。</li></ul><h4 id="包含字符串键的RDB文件"><a href="#包含字符串键的RDB文件" class="headerlink" title="包含字符串键的RDB文件"></a>包含字符串键的RDB文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@b9283e6096c1:/data# od -c dump.rdb</span><br><span class="line">0000000   R   E   D   I   S   0   0   1   2 372  \t   r   e   d   i   s</span><br><span class="line">0000020   -   v   e   r 005   7   .   4   .   1 372  \n   r   e   d   i</span><br><span class="line">0000040   s   -   b   i   t   s 300   @ 372 005   c   t   i   m   e 302</span><br><span class="line">0000060   /   r   1   g 372  \b   u   s   e   d   -   m   e   m 302   H</span><br><span class="line">0000100 220 022  \0 372  \b   a   o   f   -   b   a   s   e 300  \0 376</span><br><span class="line">0000120  \0 373 001  \0  \0 003   m   s   g 005   h   e   l   l   o 377</span><br><span class="line">0000140   g 270   o   c 003 235   ~   f</span><br><span class="line">0000150</span><br></pre></td></tr></table></figure><p>这里由于每个版本的格式并不一致，所以就不详细解读了。（书中版本较老，新版本加了很多东西）<br>可以参考这篇文章：<a class="link"   href="https://github.com/dalei2019/redis-study/blob/main/docs/redis-rdb-format.md" >Redis RDB 文件格式解析<i class="fas fa-external-link-alt"></i></a></p><h2 id="第十一章-AOF持久化"><a href="#第十一章-AOF持久化" class="headerlink" title="第十一章 - AOF持久化"></a>第十一章 - AOF持久化</h2><p>除了RDB持久化功能之外，Redis还提供了AOF（Append Only File）持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。</p><p>RDB持久化保存数据库状态的方法是将msg、fruits、numbers三个键的键值对保存到RDB文件中。<br>而AOF持久化保存数据库状态的方法则是将服务器执行的SET、SADD、RPUSH三个命令保存到AOF文件中。</p><p>被写入AOF文件的所有命令都是以Redis的命令请求协议格式（纯文本格式）保存的。</p><h3 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h3><p>AOF持久化功能的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。</p><h4 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h4><p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾。</p><h4 id="AOF文件的写入与同步"><a href="#AOF文件的写入与同步" class="headerlink" title="AOF文件的写入与同步"></a>AOF文件的写入与同步</h4><p>Redis的服务器进程就是一个事件循环（loop），这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。</p><p>因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲区里面，所以在服务器每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面，这个过程可以用以下伪代码表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">eventLoop</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 处理文件事件，接收命令请求以及发送命令回复</span></span><br><span class="line">        <span class="comment"># 处理命令请求时可能会有新内容被追加到 aof_buf 缓冲区中</span></span><br><span class="line">        processFileEvents()</span><br><span class="line">        <span class="comment"># 处理时间事件</span></span><br><span class="line">        processTimeEvents()</span><br><span class="line">        <span class="comment"># 考虑是否要将 aof_buf 中的内容写入和保存到 AOF 文件里面</span></span><br><span class="line">        flushAppendOnlyFile()</span><br></pre></td></tr></table></figure><p>flushAppendOnlyFile 函数的行为由服务器配置的 appendfsync 选项的值来决定，各个不同值产生的行为。</p><table><thead><tr><th><code>appendonly</code> 选项的值</th><th><code>flushAppendonlyFile</code> 函数的行为</th></tr></thead><tbody><tr><td><code>always</code></td><td>将 <code>aof_buf</code> 缓冲区中的所有内容写入并同步到 AOF 文件，确保数据实时持久化。</td></tr><tr><td><code>everysec</code></td><td>将 <code>aof_buf</code> 缓冲区中的所有内容写入 AOF 文件，每隔一秒钟检查上次同步时间，如果超过一秒则再次同步。同步由一个独立线程负责执行，以减少阻塞。</td></tr><tr><td><code>no</code></td><td>将 <code>aof_buf</code> 缓冲区中的所有内容写入 AOF 文件，但不立即同步，何时同步由操作系统决定，可能在后台缓冲区写满或其他条件下触发。</td></tr></tbody></table><p>如果用户没有主动为appendfsync选项设置值，那么appendfsync选项的默认值为everysec，关于appendfsync选项的更多信息，请参考Redis项目附带的示例配置文件redis.conf。</p><p><strong>文件的写入和同步</strong><br>为了提高文件的写入效率，在现代操作系统中，当用户调用write函数，将一些数据写入到文件的时候，操作系统通常会将写入数据暂时保存在一个内存缓冲区里面，等到缓冲区的空间被填满、或者超过了指定的时限之后，才真正地将缓冲区中的数据写入到磁盘里面。<br>这种做法虽然提高了效率，但也为写入数据带来了安全问题，因为如果计算机发生停机，那么保存在内存缓冲区里面的写入数据将会丢失。<br>为此，系统提供了fsync和fdatasync两个同步函数，它们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面，从而确保写入数据的安全性。</p><p><strong>AOF持久化的效率和安全性</strong><br>服务器配置appendfsync选项的值直接决定AOF持久化功能的效率和安全性。</p><ul><li>当appendfsync的值为always时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且同步AOF文件，所以always的效率是appendfsync选项三个值当中最慢的一个，但从安全性来说，always也是最安全的，因为即使出现故障停机，AOF持久化也只会丢失一个事件循环中所产生的命令数据。</li><li>当appendfsync的值为everysec时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且每隔一秒就要在子线程中对AOF文件进行一次同步。<br>从效率上来讲，everysec模式足够快，并且就算出现故障停机，数据库也只丢失一秒钟的命令数据。</li><li>当appendfsync的值为no时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，至于何时对AOF文件进行同步，则由操作系统控制。<br>因为处于no模式下的flushAppendOnlyFile调用无须执行同步操作，所以该模式下的AOF文件写入速度总是最快的，不过因为这种模式会在系统缓存中积累一段时间的写入数据，所以该模式的单次同步时长通常是三种模式中时间最长的。从平摊操作的角度来看，no模式和everysec模式的效率类似，当出现故障停机时，使用no模式的服务器将丢失上次同步AOF文件之后的所有写命令数据。</li></ul><h3 id="AOF文件的载入与数据还原"><a href="#AOF文件的载入与数据还原" class="headerlink" title="AOF文件的载入与数据还原"></a>AOF文件的载入与数据还原</h3><p>因为AOF文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态。</p><p>Redis读取AOF文件并还原数据库状态的详细步骤如下：</p><ol><li>创建一个不带网络连接的伪客户端（fake client）：因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行AOF文件保存的写命令，伪客户端执行命令的效果和带网络连接的客户端执行命令的效果完全一样。</li><li>从AOF文件中分析并读取出一条写命令。</li><li>使用伪客户端执行被读出的写命令。</li><li>一直执行步骤2和步骤3，直到AOF文件中的所有写命令都被处理完毕为止。</li></ol><h3 id="AOF重写-1"><a href="#AOF重写-1" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>因为AOF持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器运行时间的流逝，AOF文件中的内容会越来越多，文件的体积也会越来越大。<br>如果不加以控制的话，体积过大的AOF文件很可能对Redis服务器、甚至整个宿主计算机造成影响，并且AOF文件的体积越大，使用AOF文件来进行数据还原所需的时间就越多。</p><p>为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写（rewrite）功能。<br>通过该功能，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但新AOF文件不会包含任何浪费空间的冗余命令，所以新AOF文件的体积通常会比旧AOF文件的体积要小得多。</p><h4 id="AOF文件重写的实现"><a href="#AOF文件重写的实现" class="headerlink" title="AOF文件重写的实现"></a>AOF文件重写的实现</h4><p>虽然Redis将生成新AOF文件替换旧AOF文件的功能命名为“AOF文件重写”，但实际上，AOF文件重写并不需要对现有的AOF文件进行任何读取、分析或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的。<br>AOF重写功能的实现原理是 从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令。从而减少新AOF文件的体积。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">aof_rewrite</span>(<span class="params">new_aof_file_name</span>):</span><br><span class="line">    <span class="comment"># 创建新 AOF 文件</span></span><br><span class="line">    f = create_file(new_aof_file_name)</span><br><span class="line">    <span class="comment"># 遍历数据库</span></span><br><span class="line">    <span class="keyword">for</span> db <span class="keyword">in</span> redisServer.db:</span><br><span class="line">        <span class="comment"># 忽略空数据库</span></span><br><span class="line">        <span class="keyword">if</span> db.is_empty(): <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 写入SELECT命令，指定数据库号码</span></span><br><span class="line">        f.write_command(<span class="string">&quot;SELECT&quot;</span> + db.<span class="built_in">id</span>)</span><br><span class="line">        <span class="comment"># 遍历数据库中的所有键</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> db:</span><br><span class="line">            <span class="comment"># 忽略已过期的键</span></span><br><span class="line">            <span class="keyword">if</span> key.is_expired(): <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 根据键的类型对键进行重写</span></span><br><span class="line">            <span class="keyword">if</span> key.<span class="built_in">type</span> == String:</span><br><span class="line">                rewrite_string(key)</span><br><span class="line">            <span class="keyword">elif</span> key.<span class="built_in">type</span> == <span class="type">List</span>:</span><br><span class="line">                rewrite_list(key)</span><br><span class="line">            <span class="keyword">elif</span> key.<span class="built_in">type</span> == Hash:</span><br><span class="line">                rewrite_hash(key)</span><br><span class="line">            <span class="keyword">elif</span> key.<span class="built_in">type</span> == <span class="type">Set</span>:</span><br><span class="line">                rewrite_set(key)</span><br><span class="line">            <span class="keyword">elif</span> key.<span class="built_in">type</span> == SortedSet:</span><br><span class="line">                rewrite_sorted_set(key)</span><br><span class="line">            <span class="comment"># 如果键带有过期时间，那么过期时间也要被重写</span></span><br><span class="line">            <span class="keyword">if</span> key.have_expire_time():</span><br><span class="line">                rewrite_expire_time(key)</span><br><span class="line">    <span class="comment"># 写入完毕，关闭文件</span></span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rewrite_string</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="comment"># 使用GET命令获取字符串键的值</span></span><br><span class="line">    value = GET(key)</span><br><span class="line">    <span class="comment"># 使用SET命令重写字符串键</span></span><br><span class="line">    f.write_command(SET, key, value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rewrite_list</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="comment"># 使用LRANGE命令获取列表键包含的所有元素</span></span><br><span class="line">    item1, item2, ..., itemN = LRANGE(key, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 使用RPUSH命令重写列表键</span></span><br><span class="line">    f.write_command(RPUSH, key, item1, item2, ..., itemN)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rewrite_hash</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="comment"># 使用HGETALL命令获取哈希键包含的所有键值对</span></span><br><span class="line">    field1, value1, field2, value2, ..., fieldN, valueN = HGETALL(key)</span><br><span class="line">    <span class="comment"># 使用HMSET命令重写哈希键</span></span><br><span class="line">    f.write_command(HMSET, key, field1, value1, field2, value2, ..., fieldN, valueN)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rewrite_set</span>(<span class="params">key</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用SMEMBERS命令获取集合键包含的所有元素</span></span><br><span class="line">elem1, elem2, ..., elemN = SMEMBERS(key)</span><br><span class="line"><span class="comment"># 使用SADD命令重写集合键</span></span><br><span class="line">f.write_command(SADD, key, elem1, elem2, ..., elemN)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rewrite_sorted_set</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="comment"># 使用ZRANGE命令获取有序集合键包含的所有元素</span></span><br><span class="line">    member1, score1, member2, score2, ..., memberN, scoreN = ZRANGE(key, <span class="number">0</span>, -<span class="number">1</span>, <span class="string">&quot;WITHSCORES&quot;</span>)</span><br><span class="line">    <span class="comment"># 使用ZADD命令重写有序集合键</span></span><br><span class="line">    f.write_command(ZADD, key, score1, member1, score2, member2, ..., scoreN, memberN)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rewrite_expire_time</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="comment"># 获取毫秒精度的键过期时间戳</span></span><br><span class="line">    timestamp = get_expire_time_in_unixstamp(key)</span><br><span class="line">    <span class="comment"># 使用PEXPIREAT命令重写键的过期时间</span></span><br><span class="line">    f.write_command(PEXPIREAT, key, timestamp)</span><br></pre></td></tr></table></figure><p>因为aof_rewrite函数生成的新AOF文件只包含还原当前数据库状态所必须的命令，所以新AOF文件不会浪费任何硬盘空间。</p><p>在实际中，为了避免在执行命令时造成客户端输入缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合这四种可能会带有多个元素的键时，会先检查键所包含的元素数量，如果元素的数量超过了redis.h&#x2F;REDIS_AOF_REWRITE_ITEMS_PER_CMD常量的值，那么重写程序将使用多条命令来记录键的值，而不单单使用一条命令。</p><h4 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h4><p>上面介绍的AOF重写程序aof_rewrite函数可以很好地完成创建一个新AOF文件的任务，但是，因为这个函数会进行大量的写入操作，所以调用这个函数的线程将被长时间阻塞。<br>因为Redis服务器使用单个线程来处理命令请求，所以如果由服务器直接调用aof_rewrite函数的话，那么在重写AOF文件期间，服务期将无法处理客户端发来的命令请求。</p><p>很明显，作为一种辅佐性的维护手段，Redis不希望AOF重写造成服务器无法处理请求，所以Redis决定将AOF重写程序放到子进程里执行，这样做可以同时达到两个目的：</p><ul><li>子进程进行AOF重写期间，服务器进程（父进程）可以继续处理命令请求。</li><li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</li></ul><p>不过，使用子进程也有一个问题需要解决，因为子进程在进行AOF重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致。<br>为了解决这种数据不一致问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。</p><p>这也就是说，在子进程执行AOF重写期间，服务器进程需要执行以下三个工作：</p><ol><li>执行客户端发来的命令。</li><li>将执行后的写命令追加到AOF缓冲区。</li><li>将执行后的写命令追加到AOF重写缓冲区。</li></ol><p>这样一来可以保证：</p><ul><li>AOF缓冲区的内容会定期被写入和同步到AOF文件，对现有AOF文件的处理工作会如常进行。</li><li>从创建子进程开始，服务器执行的所有写命令都会被记录到AOF重写缓冲区里面。</li></ul><p>当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作：</p><ol><li>将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致。</li><li>对新的AOF文件进行改名，原子地（atomic）覆盖现有的AOF文件，完成新旧两个AOF文件的替换。</li></ol><p>这个信号处理函数执行完毕之后，父进程就可以继续像往常一样接受命令请求了。<br><strong>在整个AOF后台重写过程中，只有信号处理函数执行时会对服务器进程（父进程）造成阻塞，在其他时候，AOF后台重写都不会阻塞父进程，这将AOF重写对服务器性能造成的影响降到了最低。</strong></p><h2 id="第十二章-事件"><a href="#第十二章-事件" class="headerlink" title="第十二章 - 事件"></a>第十二章 - 事件</h2><p>Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：</p><ul><li>文件事件（file event）：Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</li><li>时间事件（time event）：Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</li></ul><h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><p>Redis基于Reactor模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）：</p><ul><li>文件事件处理器使用I&#x2F;O多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><p>虽然文件事件处理器以单线程方式运行，但通过使用I&#x2F;O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接，这保持了Redis内部单线程设计的简单性。</p><h4 id="文件事件处理器的构成"><a href="#文件事件处理器的构成" class="headerlink" title="文件事件处理器的构成"></a>文件事件处理器的构成</h4><p>文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答（accept）、写入、读取、关闭等操作时，就会产生一个文件事件。因为一个服务器通常会连接多个套接字，所以多个文件事件有可能会并发地出现。<br>I&#x2F;O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。<br>尽管多个文件事件可能会并发地出现，但I&#x2F;O多路复用程序总是会将所有产生事件的套接字都放到一个队列里面，然后通过这个队列，以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字。<br>当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕），I&#x2F;O多路复用程序才会继续向文件事件分派器传送下一个套接字。</p><p>文件事件分派器接收I&#x2F;O多路复用程序传来的套接字，并根据套接字产生的事件的类型，调用相应的事件处理器。<br>服务器会为执行不同任务的套接字关联不同的事件处理器，这些处理器是一个个函数，它们定义了某个事件发生时，服务器应该执行的动作。</p><h4 id="I-O多路复用程序的实现"><a href="#I-O多路复用程序的实现" class="headerlink" title="I&#x2F;O多路复用程序的实现"></a>I&#x2F;O多路复用程序的实现</h4><p>Redis的I&#x2F;O多路复用程序的所有功能都是通过包装常见的select、epoll、evport和kqueue这些I&#x2F;O多路复用函数库来实现的。<br>每个I&#x2F;O多路复用函数库在Redis源码中都对应一个单独的文件，比如ae_select.c、ae_epoll.c、ae_kqueue.c，诸如此类。</p><p>因为Redis为每个I&#x2F;O多路复用函数库都实现了相同的API，所以I&#x2F;O多路复用程序的底层实现是可以互换的</p><p>Redis在I&#x2F;O多路复用程序的实现源码中用#include宏定义了相应的规则，程序会在编译时自动选择系统中性能最高的I&#x2F;O多路复用函数库来作为Redis的I&#x2F;O多路复用程序的底层实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Include the best multiplexing layer supported by this system.</span></span><br><span class="line"><span class="comment">  * The following should be ordered by performances, descending. */</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> HAVE_EVPORT</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;ae_evport.c&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">    <span class="meta"># <span class="keyword">ifdef</span> HAVE_EPOLL</span></span><br><span class="line">    <span class="meta"># <span class="keyword">include</span> <span class="string">&quot;ae_epoll.c&quot;</span></span></span><br><span class="line">    <span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">        <span class="meta"># <span class="keyword">ifdef</span> HAVE_KQUEUE</span></span><br><span class="line">        <span class="meta"># <span class="keyword">include</span> <span class="string">&quot;ae_kqueue.c&quot;</span></span></span><br><span class="line">        <span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">        <span class="meta"># <span class="keyword">include</span> <span class="string">&quot;ae_select.c&quot;</span></span></span><br><span class="line">        <span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="事件的类型"><a href="#事件的类型" class="headerlink" title="事件的类型"></a>事件的类型</h4><p>I&#x2F;O多路复用程序可以监听多个套接字的ae.h&#x2F;AE_READABLE事件和ae.h&#x2F;AE_WRITABLE事件，这两类事件和套接字操作之间的对应关系如下：</p><ul><li>当套接字变得可读时（客户端对套接字执行write操作，或者执行close操作），或者有新的可应答（acceptable）套接字出现时（客户端对服务器的监听套接字执行connect操作），套接字产生AE_READABLE事件。</li><li>当套接字变得可写时（客户端对套接字执行read操作），套接字产生AE_WRITABLE事件。</li></ul><p>I&#x2F;O多路复用程序允许服务器同时监听套接字的AE_READABLE事件和AE_WRITABLE事件，如果一个套接字同时产生了这两种事件，那么文件事件分派器会优先处理AE_READABLE事件，等到AE_READABLE事件处理完之后，才处理AE_WRITABLE事件。<br>这也就是说，如果一个套接字又可读又可写的话，那么服务器将先读套接字，后写套接字。</p><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>ae.c&#x2F;aeCreateFileEvent函数接受一个套接字描述符、一个事件类型，以及一个事件处理器作为参数，将给定套接字的给定事件加入到I&#x2F;O多路复用程序的监听范围之内，并对事件和事件处理器进行关联。<br>ae.c&#x2F;aeDeleteFileEvent函数接受一个套接字描述符和一个监听事件类型作为参数，让I&#x2F;O多路复用程序取消对给定套接字的给定事件的监听，并取消事件和事件处理器之间的关联。<br>ae.c&#x2F;aeGetFileEvents函数接受一个套接字描述符，返回该套接字正在被监听的事件类型：</p><ul><li>如果套接字没有任何事件被监听，那么函数返回AE_NONE。</li><li>如果套接字的读事件正在被监听，那么函数返回AE_READABLE。</li><li>如果套接字的写事件正在被监听，那么函数返回AE_WRITABLE。</li><li>如果套接字的读事件和写事件正在被监听，那么函数返回AE_READABLE|AE_WRITABLE。</li></ul><p>ae.c&#x2F;aeWait函数接受一个套接字描述符、一个事件类型和一个毫秒数为参数，在给定的时间内阻塞并等待套接字的给定类型事件产生，当事件成功产生，或者等待超时之后，函数返回。<br>ae.c&#x2F;aeApiPoll函数接受一个sys&#x2F;time.h&#x2F;struct timeval结构为参数，并在指定的时间內，阻塞并等待所有被aeCreateFileEvent函数设置为监听状态的套接字产生文件事件，当有至少一个事件产生，或者等待超时后，函数返回。<br>ae.c&#x2F;aeProcessEvents函数是文件事件分派器，它先调用aeApiPoll函数来等待事件产生，然后遍历所有已产生的事件，并调用相应的事件处理器来处理这些事件。<br>ae.c&#x2F;aeGetApiName函数返回I&#x2F;O多路复用程序底层所使用的I&#x2F;O多路复用函数库的名称：返回”epoll”表示底层为epoll函数库，返回”select”表示底层为select函数库，诸如此类。</p><h4 id="文件事件的处理器"><a href="#文件事件的处理器" class="headerlink" title="文件事件的处理器"></a>文件事件的处理器</h4><p>Redis为文件事件编写了多个处理器，这些事件处理器分别用于实现不同的网络通信需求，比如说：</p><ul><li>为了对连接服务器的各个客户端进行应答，服务器要为监听套接字关联连接应答处理器。</li><li>为了接收客户端传来的命令请求，服务器要为客户端套接字关联命令请求处理器。</li><li>为了向客户端返回命令的执行结果，服务器要为客户端套接字关联命令回复处理器。</li><li>当主服务器和从服务器进行复制操作时，主从服务器都需要关联特别为复制功能编写的复制处理器。</li></ul><p>在这些事件处理器里面，服务器最常用的要数与客户端进行通信的连接应答处理器、命令请求处理器和命令回复处理器。</p><p><strong>连接应答处理器</strong><br>networking.c&#x2F;acceptTcpHandler函数是Redis的连接应答处理器，这个处理器用于对连接服务器监听套接字的客户端进行应答，具体实现为sys&#x2F;socket.h&#x2F;accept函数的包装。<br>当Redis服务器进行初始化的时候，程序会将这个连接应答处理器和服务器监听套接字的AE_READABLE事件关联起来，当有客户端用sys&#x2F;socket.h&#x2F;connect函数连接服务器监听套接字的时候，套接字就会产生AE_READABLE事件，引发连接应答处理器执行，并执行相应的套接字应答操作。</p><p><strong>命令请求处理器</strong><br>networking.c&#x2F;readQueryFromClient函数是Redis的命令请求处理器，这个处理器负责从套接字中读入客户端发送的命令请求内容，具体实现为unistd.h&#x2F;read函数的包装。<br>当一个客户端通过连接应答处理器成功连接到服务器之后，服务器会将客户端套接字的AE_READABLE事件和命令请求处理器关联起来，当客户端向服务器发送命令请求的时候，套接字就会产生AE_READABLE事件，引发命令请求处理器执行，并执行相应的套接字读入操作。</p><p><strong>命令回复处理器</strong><br>networking.c&#x2F;sendReplyToClient函数是Redis的命令回复处理器，这个处理器负责将服务器执行命令后得到的命令回复通过套接字返回给客户端，具体实现为unistd.h&#x2F;write函数的包装。<br>当服务器有命令回复需要传送给客户端的时候，服务器会将客户端套接字的AE_WRITABLE事件和命令回复处理器关联起来，当客户端准备好接收服务器传回的命令回复时，就会产生AE_WRITABLE事件，引发命令回复处理器执行，并执行相应的套接字写入操作。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.png"                        alt="客户端和服务器的通信过程.png"                 ></p><h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><p>Redis的时间事件分为以下两类：</p><ul><li>定时事件：让一段程序在指定的时间之后执行一次。比如说，让程序X在当前时间的30毫秒之后执行一次。</li><li>周期性事件：让一段程序每隔指定时间就执行一次。比如说，让程序Y每隔30毫秒就执行一次。</li></ul><p>一个时间事件主要由以下三个属性组成：</p><ul><li>id：服务器为时间事件创建的全局唯一ID（标识号）。ID号按从小到大的顺序递增，新事件的ID号比旧事件的ID号要大。</li><li>when：毫秒精度的UNIX时间戳，记录了时间事件的到达（arrive）时间。</li><li>timeProc：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。</li></ul><p>一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值：</p><ul><li>如果事件处理器返回ae.h&#x2F;AE_NOMORE，那么这个事件为定时事件：该事件在达到一次之后就会被删除，之后不再到达。</li><li>如果事件处理器返回一个非AE_NOMORE的整数值，那么这个事件为周期性时间：当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段时间之后再次到达，并以这种方式一直更新并运行下去。比如说，如果一个时间事件的处理器返回整数值30，那么服务器应该对这个时间事件进行更新，让这个事件在30毫秒之后再次到达。</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p><blockquote><p>这里说保存时间事件的链表为无序链表，指的不是链表不按ID排序，而是说，该链表不按when属性的大小排序。正因为链表没有按when属性进行排序，所以当时间事件执行器运行的时候，它必须遍历链表中的所有时间事件，这样才能确保服务器中所有已到达的时间事件都会被处理。<br><strong>无序链表并不影响时间事件处理器的性能</strong></p></blockquote><h4 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h4><p>ae.c&#x2F;aeCreateTimeEvent函数接受一个毫秒数milliseconds和一个时间事件处理器proc作为参数。<br>将一个新的时间事件添加到服务器，这个新的时间事件将在当前时间的milliseconds毫秒之后到达，而事件的处理器为proc。</p><p>ae.c&#x2F;aeDeleteFileEvent函数接受一个时间事件ID作为参数，然后从服务器中删除该ID所对应的时间事件。</p><p>ae.c&#x2F;aeSearchNearestTimer函数返回到达时间距离当前时间最接近的那个时间事件。</p><p>ae.c&#x2F;processTimeEvents函数是时间事件的执行器，这个函数会遍历所有已到达的时间事件，并调用这些事件的处理器。<br>已到达指的是，时间事件的when属性记录的UNIX时间戳等于或小于当前时间的UNIX时间戳。</p><h4 id="时间事件应用实例：serverCron函数"><a href="#时间事件应用实例：serverCron函数" class="headerlink" title="时间事件应用实例：serverCron函数"></a>时间事件应用实例：serverCron函数</h4><p>持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行，这些定期操作由redis.c&#x2F;serverCron函数负责执行，它的主要工作包括：</p><ul><li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。</li><li>清理数据库中的过期键值对。</li><li>关闭和清理连接失效的客户端。</li><li>尝试进行AOF或RDB持久化操作。</li><li>如果服务器是主服务器，那么对从服务器进行定期同步。</li><li>如果处于集群模式，对集群进行定期同步和连接测试。</li></ul><p>Redis服务器以周期性事件的方式来运行serverCron函数，在服务器运行期间，每隔一段时间，serverCron就会执行一次，直到服务器关闭为止。</p><p>在Redis2.6版本，服务器默认规定serverCron每秒运行10次，平均每间隔100毫秒运行一次。<br>从Redis2.8开始，用户可以通过修改hz选项来调整serverCron的每秒执行次数，具体信息请参考示例配置文件redis.conf关于hz选项的说明。</p><h3 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h3><p>因为服务器中同时存在文件事件和时间事件两种事件类型，所以服务器必须对这两种事件进行调度，决定何时应该处理文件事件，何时又应该处理时间事件，以及花多少时间来处理它们等等。</p><p>事件的调度和执行由ae.c&#x2F;aeProcessEvents函数负责，以下是该函数的伪代码表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">aeProcessEvents</span>():</span><br><span class="line">    <span class="comment"># 获取到达时间离当前时间最接近的时间事件</span></span><br><span class="line">    time_event = aeSearchNearestTimer()</span><br><span class="line">    <span class="comment"># 计算最接近的时间事件距离到达还有多少毫秒</span></span><br><span class="line">    remaind_ms = time_event.when - unix_ts_now()</span><br><span class="line">    <span class="comment"># 如果事件已到达，那么remaind_ms的值可能为负数，将它设定为0</span></span><br><span class="line">    <span class="keyword">if</span> remaind_ms &lt; <span class="number">0</span>:</span><br><span class="line">        remaind_ms = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 根据remaind_ms的值，创建timeval结构</span></span><br><span class="line">    timeval = create_timeval_with_ms(remaind_ms)</span><br><span class="line">    <span class="comment"># 阻塞并等待文件事件产生，最大阻塞时间由传入的timeval结构决定</span></span><br><span class="line">    <span class="comment"># 如果remaind_ms的值为0，那么aeApiPoll调用之后马上返回，不阻塞</span></span><br><span class="line">    aeApiPoll(timeval)</span><br><span class="line">    <span class="comment"># 处理所有已产生的文件事件</span></span><br><span class="line">    processFileEvents()</span><br><span class="line">    <span class="comment"># 处理所有已到达的时间事件</span></span><br><span class="line">    processTimeEvents()</span><br></pre></td></tr></table></figure><p>前面在介绍文件事件API的时候，并没有讲到processFileEvents这个函数，因为它并不存在，在实际中，处理已产生文件事件的代码是直接写在aeProcessEvents函数里面的，这里为了方便讲述，才虚构了processFileEvents函数。</p><p>将aeProcessEvents函数置于一个循环里面，加上初始化和清理函数，这就构成了Redis服务器的主函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 初始化服务器</span></span><br><span class="line">    init_server()</span><br><span class="line">    <span class="comment"># 一直处理事件，直到服务器关闭为止</span></span><br><span class="line">    <span class="keyword">while</span> server_is_not_shutdown():</span><br><span class="line">        aeProcessEvents()</span><br><span class="line">    <span class="comment"># 服务器关闭，执行清理操作</span></span><br><span class="line">    clean_server()</span><br></pre></td></tr></table></figure><p>以下是事件的调度和执行规则：</p><ol><li>aeApiPoll函数的最大阻塞时间由到达时间最接近当前时间的时间事件决定，这个方法既可以避免服务器对时间事件进行频繁的轮询（忙等待），也可以确保aeApiPoll函数不会阻塞过长时间。</li><li>因为文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍未有任何时间事件到达，那么服务器将再次等待并处理文件事件。随着文件事件的不断执行，时间会逐渐向时间事件所设置的到达时间逼近，并最终来到到达时间，这时服务器就可以开始处理到达的时间事件了。</li><li>对文件事件和时间事件的处理都是同步、有序、原子地执行的，服务器不会中途中断事件处理，也不会对事件进行抢占，因此，不管是文件事件的处理器，还是时间事件的处理器，它们都会尽可地减少程序的阻塞时间，并在有需要时主动让出执行权，从而降低造成事件饥饿的可能性。<br>比如说，在命令回复处理器将一个命令回复写入到客户端套接字时，如果写入字节数超过了一个预设常量的话，命令回复处理器就会主动用break跳出写入循环，将余下的数据留到下次再写；另外，时间事件也会将非常耗时的持久化操作放到子线程或者子进程执行。</li><li>因为时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的实际处理时间，通常会比时间事件设定的到达时间稍晚一些。</li></ol><h2 id="第十三章-客户端"><a href="#第十三章-客户端" class="headerlink" title="第十三章 - 客户端"></a>第十三章 - 客户端</h2><p>Redis服务器是典型的一对多服务器程序：一个服务器可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，而服务器则接收并处理客户端发送的命令请求，并向客户端返回命令回复。<br>通过使用由I&#x2F;O多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。</p><p>对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了相应的redis.h&#x2F;redisClient结构（客户端状态），这个结构保存了客户端当前的状态信息，以及执行相关功能时需要用到的数据结构，其中包括：</p><ul><li>客户端的套接字描述符。</li><li>客户端的名字。</li><li>客户端的标志值（flag）。</li><li>指向客户端正在使用的数据库的指针，以及该数据库的号码。</li><li>客户端当前要执行的命令、命令的参数、命令参数的个数，以及指向命令实现函数的指针。</li><li>客户端的输入缓冲区和输出缓冲区。</li><li>客户端的复制状态信息，以及进行复制所需的数据结构。</li><li>客户端执行BRPOP、BLPOP等列表阻塞命令时使用的数据结构。</li><li>客户端的事务状态，以及执行WATCH命令时用到的数据结构。</li><li>客户端执行发布与订阅功能时用到的数据结构。</li><li>客户端的身份验证标志。</li><li>客户端的创建时间，客户端和服务器最后一次通信的时间，以及客户端的输出缓冲区大小超出软性限制（soft limit）的时间。</li></ul><p>Redis服务器状态结构的clients属性是一个链表，这个链表保存了所有与服务器连接的客户端的状态结构，对客户端执行批量操作，或者查找某个指定的客户端，都可以通过遍历clients链表来完成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 一个链表，保存了所有客户端状态</span></span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h3><p>客户端状态包含的属性可以分为两类：</p><ul><li>一类是比较通用的属性，这些属性很少与特定功能相关，无论客户端执行的是什么工作，它们都要用到这些属性。</li><li>另外一类是和特定功能相关的属性，比如操作数据库时需要用到的db属性和dictid属性，执行事务时需要用到的mstate属性，以及执行WATCH命令时需要用到的watched_keys属性等等。</li></ul><p>执行<a class="link"   href="https://redis.io/docs/latest/commands/client-list/" >CLIENT list<i class="fas fa-external-link-alt"></i></a>命令可以列出目前所有连接到服务器的普通客户端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; CLIENT list</span><br><span class="line">id=3 addr=172.17.0.1:47759 laddr=172.17.0.2:6379 fd=11 name= age=0 idle=0 flags=N db=0 sub=0 psub=0 ssub=0 multi=-1 watch=0 qbuf=26 qbuf-free=20448 argv-mem=10 multi-mem=0 rbs=1024 rbp=673 obl=0 oll=0 omem=0 tot-mem=22426 events=r cmd=client|list user=default redir=-1 resp=2 lib-name=jedis lib-ver=4.4.3</span><br></pre></td></tr></table></figure><ul><li><strong>id</strong>: 客户端的唯一标识符。</li><li><strong>addr</strong>: 客户端的 IP 地址和端口号。</li><li><strong>laddr</strong>: Redis 服务器本地的 IP 地址和端口号，用于此连接。</li><li><strong>fd</strong>: 客户端连接的文件描述符。</li><li><strong>name</strong>: 客户端名称，默认空白，可通过 <code>CLIENT SETNAME</code> 设置。</li><li><strong>age</strong>: 该连接的持续时间（以秒为单位）。</li><li><strong>idle</strong>: 客户端自上次发出命令后空闲的时间（以秒为单位）。</li><li><strong>flags</strong>: 客户端的标志位。这里的 <code>N</code> 表示普通客户端，未设置特殊标志。</li><li><strong>db</strong>: 客户端正在使用的数据库编号。</li><li><strong>sub</strong>: 该客户端的频道订阅数量。</li><li><strong>psub</strong>: 该客户端的模式订阅数量（订阅模式匹配的通配符频道）。</li><li><strong>ssub</strong>: 共享订阅数量，用于集群环境下的连接共享。</li><li><strong>multi</strong>: 当前事务队列中的命令数量。如果客户端未使用事务，则显示为 <code>-1</code>。</li><li><strong>watch</strong>: 客户端监视的键的数量（事务监视机制）。</li><li><strong>qbuf</strong>: 查询缓冲区的当前长度（字节数）。</li><li><strong>qbuf-free</strong>: 查询缓冲区的空闲空间（字节数）。</li><li><strong>argv-mem</strong>: 命令参数占用的内存量（字节数）。</li><li><strong>multi-mem</strong>: 事务命令队列所占用的内存量（字节数）。</li><li><strong>rbs</strong>: 该客户端的复制缓冲区大小。</li><li><strong>rbp</strong>: 复制缓冲区中的偏移量。</li><li><strong>obl</strong>: 输出缓冲区的长度。</li><li><strong>oll</strong>: 输出缓冲区的链表长度。</li><li><strong>omem</strong>: 输出缓冲区占用的内存量。</li><li><strong>tot-mem</strong>: 客户端连接总占用的内存量。</li><li><strong>events</strong>: 事件标志，<code>r</code> 表示客户端可读。</li><li><strong>cmd</strong>: 客户端最后执行的命令。</li><li><strong>user</strong>: 客户端认证的用户名（这里为 <code>default</code>）。</li><li><strong>redir</strong>: 当前客户端重定向的目标（<code>-1</code> 表示未重定向）。</li><li><strong>resp</strong>: 客户端使用的 RESP 协议版本。</li><li><strong>lib-name</strong>: 客户端连接库的名称（例如 <code>jedis</code>）。</li><li><strong>lib-ver</strong>: 客户端库的版本（例如 <code>4.4.3</code>）。</li></ul><p>下面就不放书中所列举的各属性的含义了，只取部分解释，因为书中使用的Redis版本较老，部分已经更改或弃用了。需要最新的还是得看官方文档（很全）。</p><p>其中，客户端标识 flags 可以是以下组合：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">A: connection to be closed ASAP</span><br><span class="line">b: the client is waiting in a blocking operation</span><br><span class="line">c: connection to be closed after writing entire reply</span><br><span class="line">d: a watched keys has been modified - EXEC will fail</span><br><span class="line">e: the client is excluded from the client eviction mechanism</span><br><span class="line">i: the client is waiting for a VM I/O (deprecated)</span><br><span class="line">M: the client is a master</span><br><span class="line">N: no specific flag set</span><br><span class="line">O: the client is a client in MONITOR mode</span><br><span class="line">P: the client is a Pub/Sub subscriber</span><br><span class="line">r: the client is in readonly mode against a cluster node</span><br><span class="line">S: the client is a replica node connection to this instance</span><br><span class="line">u: the client is unblocked</span><br><span class="line">U: the client is connected via a Unix domain socket</span><br><span class="line">x: the client is in a MULTI/EXEC context</span><br><span class="line">t: the client enabled keys tracking in order to perform client side caching</span><br><span class="line">T: the client will not touch the LRU/LFU of the keys it accesses</span><br><span class="line">R: the client tracking target client is invalid</span><br><span class="line">B: the client enabled broadcast tracking mode </span><br></pre></td></tr></table></figure><p><strong><code>PUBSUB</code>命令和<code>SCRIPT LOAD</code>命令的特殊性</strong><br>通常情况下，Redis只会将那些对数据库进行了修改的命令写入到AOF文件，并复制到各个从服务器。<strong>如果一个命令没有对数据库进行任何修改，那么它就会被认为是只读命令，这个命令不会被写入到AOF文件，也不会被复制到从服务器。</strong></p><p>以上规则适用于绝大部分Redis命令，但<code>PUBSUB</code>命令和<code>SCRIPT LOAD</code>命令是其中的例外。<br>PUBSUB命令虽然没有修改数据库，但PUBSUB命令向频道的所有订阅者发送消息这一行为带有副作用，接收到消息的所有客户端的状态都会因为这个命令而改变。<br>因此，在<strong>早期版本</strong>服务器需要使用<code>REDIS_FORCE_AOF</code>标志，强制将这个命令写入AOF文件，这样在将来载入AOF文件时，服务器就可以再次执行相同的PUBSUB命令，并产生相同的副作用。<br><code>SCRIPT LOAD</code>命令的情况与<code>PUBSUB</code>命令类似：虽然<code>SCRIPT LOAD</code>命令没有修改数据库，但它修改了服务器状态，所以它是一个带有副作用的命令，服务器需要使用<code>REDIS_FORCE_AOF</code>标志，强制将这个命令写入AOF文件，使得将来在载入AOF文件时，服务器可以产生相同的副作用。<br>另外，为了让主服务器和从服务器都可以正确地载入<code>SCRIPT LOAD</code>命令指定的脚本，服务器需要使用<code>REDIS_FORCE_REPL</code>标志，强制将<code>SCRIPT LOAD</code>命令复制给所有从服务器。</p><p>关于Redis主从复制可以参考这几篇文章：<br><a class="link"   href="https://redis.io/docs/latest/operate/oss_and_stack/management/replication" >Redis replication<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://blog.csdn.net/Seky_fei/article/details/106877329" >Redis主从同步原理、及SYNC和PSYNC同步区别<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://cloud.tencent.com/developer/article/2297090" >Redis:发布订阅(pub&#x2F;sub)的实现原理及避坑场景<i class="fas fa-external-link-alt"></i></a></p><h3 id="客户端的创建与关闭"><a href="#客户端的创建与关闭" class="headerlink" title="客户端的创建与关闭"></a>客户端的创建与关闭</h3><p>服务器使用不同的方式来创建和关闭不同类型的客户端。</p><h4 id="创建普通客户端"><a href="#创建普通客户端" class="headerlink" title="创建普通客户端"></a>创建普通客户端</h4><p>如果客户端是通过网络连接与服务器进行连接的普通客户端，那么在客户端使用connect函数连接到服务器时，服务器就会调用连接事件处理器，为客户端创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构clients链表的末尾。</p><h4 id="关闭普通客户端"><a href="#关闭普通客户端" class="headerlink" title="关闭普通客户端"></a>关闭普通客户端</h4><p>一个普通客户端可以因为多种原因而被关闭：</p><ul><li>如果客户端进程退出或者被杀死，那么客户端与服务器之间的网络连接将被关闭，从而造成客户端被关闭。</li><li>如果客户端向服务器发送了带有不符合协议格式的命令请求，那么这个客户端也会被服务器关闭。</li><li>如果客户端成为了<code>CLIENT KILL</code>命令的目标，那么它也会被关闭。</li><li>如果用户为服务器设置了timeout配置选项，那么当客户端的空转时间超过timeout选项设置的值时，客户端将被关闭。<br>不过timeout选项有一些例外情况：如果客户端是主服务器（打开了REDIS_MASTER标志），从服务器（打开了REDIS_SLAVE标志），正在被<code>BLPOP</code>等命令阻塞（打开了REDIS_BLOCKED标志），或者正在执行<code>SUBSCRIBE</code>、<code>PSUBSCRIBE</code>等订阅命令，那么即使客户端的空转时间超过了timeout选项的值，客户端也不会被服务器关闭。</li><li>如果客户端发送的命令请求的大小超过了输入缓冲区的限制大小（默认为1 GB），那么这个客户端会被服务器关闭。</li><li>如果要发送给客户端的命令回复的大小超过了输出缓冲区的限制大小，那么这个客户端会被服务器关闭。</li></ul><p>前面介绍输出缓冲区的时候提到过，可变大小缓冲区由一个链表和任意多个字符串对象组成，理论上来说，这个缓冲区可以保存任意长的命令回复。<br>但是，为了避免客户端的回复过大，占用过多的服务器资源，服务器会时刻检查客户端的输出缓冲区的大小，并在缓冲区的大小超出范围时，执行相应的限制操作。</p><p>服务器使用两种模式来限制客户端输出缓冲区的大小：</p><ul><li>硬性限制（hard limit）：如果输出缓冲区的大小超过了硬性限制所设置的大小，那么服务器立即关闭客户端。</li><li>软性限制（soft limit）：如果输出缓冲区的大小超过了软性限制所设置的大小，但还没超过硬性限制，那么服务器将使用客户端状态结构的obuf_soft_limit_reached_time属性记录下客户端到达软性限制的起始时间；<br>之后服务器会继续监视客户端，如果输出缓冲区的大小一直超出软性限制，并且持续时间超过服务器设定的时长，那么服务器将关闭客户端；相反地，如果输出缓冲区的大小在指定时间之内，不再超出软性限制，那么客户端就不会被关闭，并且obuf_soft_limit_reached_time属性的值也会被清零。</li></ul><p>使用<a class="link"   href="https://redis.io/docs/latest/develop/reference/clients/" >client-output-buffer-limit<i class="fas fa-external-link-alt"></i></a>选项可以为普通客户端、从服务器客户端、执行发布与订阅功能的客户端分别设置不同的软性限制和硬性限制。<br><code>client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</code></p><h4 id="Lua脚本的伪客户端"><a href="#Lua脚本的伪客户端" class="headerlink" title="Lua脚本的伪客户端"></a>Lua脚本的伪客户端</h4><p>服务器会在初始化时创建负责执行Lua脚本中包含的Redis命令的伪客户端，并将这个伪客户端关联在服务器状态结构的lua_client属性中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    redisClient *lua_client;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>lua_client伪客户端在服务器运行的整个生命期中会一直存在，只有服务器被关闭时，这个客户端才会被关闭。</p><h4 id="AOF文件的伪客户端"><a href="#AOF文件的伪客户端" class="headerlink" title="AOF文件的伪客户端"></a>AOF文件的伪客户端</h4><p>服务器在载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的伪客户端，并在载入完成之后，关闭这个伪客户端。</p><h2 id="第十四章-服务器"><a href="#第十四章-服务器" class="headerlink" title="第十四章 - 服务器"></a>第十四章 - 服务器</h2><p>Redis服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令所产生的数据，并通过资源管理来维持服务器自身的运转。</p><h3 id="命令请求的执行过程"><a href="#命令请求的执行过程" class="headerlink" title="命令请求的执行过程"></a>命令请求的执行过程</h3><p>从客户端发送SET KEY VALUE命令到获得回复OK期间，客户端和服务器共需要执行以下操作：</p><ol><li>客户端向服务器发送命令请求SET KEY VALUE。<br>Redis服务器的命令请求来自Redis客户端，当用户在客户端中键入一个命令请求时，客户端会将这个命令请求转换成协议格式，然后通过连接到服务器的套接字，将协议格式的命令请求发送给服务器。</li><li>服务器接收并处理客户端发来的命令请求<code>SET KEY VALUE</code>，在数据库中进行设置操作，并产生命令回复OK。<br>当客户端与服务器之间的连接套接字因为客户端的写入而变得可读时，服务器将调用命令请求处理器来执行以下操作：<ol><li>读取套接字中协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里面。</li><li>对输入缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数，以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的argv属性和argc属性里面。</li><li>调用命令执行器，执行客户端指定的命令。<ol><li>命令执行器（1）：查找命令实现<br>命令执行器要做的第一件事就是根据客户端状态的<code>argv[0]</code>参数，在命令表（command table）中查找参数所指定的命令，并将找到的命令保存到客户端状态的cmd属性里面。<br>命令表是一个字典，字典的键是一个个命令名字，比如”set”、”get”、”del”等等；而字典的值则是一个个redisCommand结构，每个redisCommand结构记录了一个Redis命令的实现信息。</li><li>命令执行器（2）：执行预备操作<br>到目前为止，服务器已经将执行命令所需的命令实现函数（保存在客户端状态的cmd属性）、参数（保存在客户端状态的argv属性）、参数个数（保存在客户端状态的argc属性）都收集齐了，但是在真正执行命令之前，程序还需要进行一些预备操作，从而确保命令可以正确、顺利地被执行，这些操作包括：<ul><li>检查客户端状态的cmd指针是否指向NULL，如果是的话，那么说明用户输入的命令名字找不到相应的命令实现，服务器不再执行后续步骤，并向客户端返回一个错误。</li><li>根据客户端cmd属性指向的redisCommand结构的arity属性，检查命令请求所给定的参数个数是否正确，当参数个数不正确时，不再执行后续步骤，直接向客户端返回一个错误。比如说，如果redisCommand结构的arity属性的值为-3，那么用户输入的命令参数个数必须大于等于3个才行。</li><li>检查客户端是否已经通过了身份验证，未通过身份验证的客户端只能执行AUTH命令，如果未通过身份验证的客户端试图执行除AUTH命令之外的其他命令，那么服务器将向客户端返回一个错误。</li><li>如果服务器打开了maxmemory功能，那么在执行命令之前，先检查服务器的内存占用情况，并在有需要时进行内存回收，从而使得接下来的命令可以顺利执行。如果内存回收失败，那么不再执行后续步骤，向客户端返回一个错误。</li><li>如果服务器上一次执行BGSAVE命令时出错，并且服务器打开了stop-writes-on-bgsave-error功能，而且服务器即将要执行的命令是一个写命令，那么服务器将拒绝执行这个命令，并向客户端返回一个错误。</li><li>如果客户端当前正在用SUBSCRIBE命令订阅频道，或者正在用PSUBSCRIBE命令订阅模式，那么服务器只会执行客户端发来的SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE、PUNSUBSCRIBE四个命令，其他命令都会被服务器拒绝。</li><li>如果服务器正在进行数据载入，那么客户端发送的命令必须带有l标识（比如INFO、SHUTDOWN、PUBLISH等等）才会被服务器执行，其他命令都会被服务器拒绝。</li><li>如果服务器因为执行Lua脚本而超时并进入阻塞状态，那么服务器只会执行客户端发来的SHUTDOWN nosave命令和SCRIPT KILL命令，其他命令都会被服务器拒绝。</li><li>如果客户端正在执行事务，那么服务器只会执行客户端发来的EXEC、DISCARD、MULTI、WATCH四个命令，其他命令都会被放进事务队列中。</li><li>如果服务器打开了监视器功能，那么服务器会将要执行的命令和参数等信息发送给监视器。当完成了以上预备操作之后，服务器就可以开始真正执行命令了。</li></ul></li><li>命令执行器（3）：调用命令的实现函数<br>服务器已经将要执行命令的实现保存到了客户端状态的cmd属性里面，并将命令的参数和参数个数分别保存到了客户端状态的argv属性和argv属性里面，当服务器决定要执行命令时，只需要调用cmd指针的proc(client)函数即可。<br>因为执行命令所需的实际参数都已经保存到客户端状态的argv属性里面了，所以命令的实现函数只需要一个指向客户端状态的指针作为参数即可。<br>被调用的命令实现函数会执行指定的操作，并产生相应的命令回复，这些回复会被保存在客户端状态的输出缓冲区里面（buf属性和reply属性），之后实现函数还会为客户端的套接字关联命令回复处理器，这个处理器负责将命令回复返回给客户端。<br>对于前面SET命令的例子来说，函数调用setCommand（client）将产生一个”+OK\r\n”回复，这个回复会被保存到客户端状态的buf属性里面。</li><li>命令执行器（4）：执行后续工作<br>在执行完实现函数之后，服务器还需要执行一些后续工作：<ul><li>如果服务器开启了慢查询日志功能，那么慢查询日志模块会检查是否需要为刚刚执行完的命令请求添加一条新的慢查询日志。</li><li>根据刚刚执行命令所耗费的时长，更新被执行命令的redisCommand结构的milliseconds属性，并将命令的redisCommand结构的calls计数器的值增一。</li><li>如果服务器开启了AOF持久化功能，那么AOF持久化模块会将刚刚执行的命令请求写入到AOF缓冲区里面。</li><li>如果有其他从服务器正在复制当前这个服务器，那么服务器会将刚刚执行的命令传播给所有从服务器。</li></ul></li></ol></li></ol></li><li>将命令回复发送给客户端。<br>命令实现函数会将命令回复保存到客户端的输出缓冲区里面，并为客户端的套接字关联命令回复处理器，当客户端套接字变为可写状态时，服务器就会执行命令回复处理器，将保存在客户端输出缓冲区中的命令回复发送给客户端。</li><li>客户端接收并打印命令回复。<br>当客户端接收到协议格式的命令回复之后，它会将这些回复转换成人类可读的格式，并打印给用户观看（假设我们使用的是Redis自带的redis-cli客户端。</li></ol><h3 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h3><p>Redis服务器中的serverCron函数默认每隔100毫秒执行一次，这个函数负责管理服务器的资源，并保持服务器自身的良好运转。</p><p><code>serverCron</code> 是 Redis 的核心函数之一，它负责定期执行一系列后台任务来确保 Redis 服务器的正常运行。这个函数通常每 100 毫秒执行一次，由 Redis 的事件处理机制触发。它在 Redis 的主事件循环中扮演着关键角色。<br><code>serverCron</code> 函数的设计目标是将服务器的维护任务和客户请求的处理分开，并通过定时任务来管理服务器的内部状态。</p><p>a) 客户端超时管理 (<code>clientTimeout</code>)</p><ul><li>Redis 会检查每个客户端的空闲时间 (<code>idle</code>)，如果客户端空闲超过指定的超时时间（通常是 0 表示不限制），则关闭这些连接，释放资源。这可以防止大量的空闲连接消耗内存和资源。</li><li>例如，Redis 会定期扫描所有客户端，关闭超时的连接。客户端的状态被记录在 <code>client</code> 结构体中，包括它的活动时间等。</li></ul><p>b) 过期键处理</p><ul><li>Redis 通过扫描数据库中的键来检查和删除过期的键。<code>serverCron</code> 会定期触发过期键的清理操作，尤其是检查那些通过 <code>EXPIRE</code> 设置了过期时间的键。</li><li>Redis 采用两种过期处理方式：<ol><li>惰性删除：每次访问键时检查是否过期，如果过期则删除。</li><li>定期删除：定期触发 <code>serverCron</code> 扫描所有数据库，删除过期的键。</li></ol></li></ul><p>c) 主从复制管理</p><ul><li><code>serverCron</code> 还会管理主从复制的相关操作，如检查主服务器与从服务器的状态、处理复制偏移量等。若发生故障，它也会发起故障切换操作。</li><li>在哨兵模式下，它还负责与哨兵协调，检查主节点是否宕机，是否需要执行故障转移。</li></ul><p>d) 内存管理</p><ul><li>Redis 允许配置内存限制，当 Redis 使用的内存超过限制时，它会尝试执行内存回收操作。<code>serverCron</code> 会定期触发内存逐出操作（如 LRU，LFU 策略）。</li><li>它会定期检查当前的内存使用情况，并触发后台的内存清理过程，按照配置的逐出策略删除不再需要的键。</li></ul><p>e) AOF 和 RDB 持久化</p><ul><li><code>serverCron</code> 还负责触发 AOF 文件的同步、AOF 重写（如果开启了 <code>appendonly</code> 配置）和 RDB 快照保存（如果开启了 <code>save</code> 配置）。</li><li>在每次 <code>serverCron</code> 执行时，它会检查是否需要进行 AOF 和 RDB 的操作。例如，如果上次 AOF 重写时间间隔太长，或是内存达到一定阈值时，可能会触发 AOF 文件的重写操作。</li></ul><p>f) 集群维护</p><ul><li>在 Redis 集群模式下，<code>serverCron</code> 会定期检查集群节点的状态。它会周期性地向集群中的其他节点发送心跳检测请求，确保节点间的连接是活跃的。</li><li>在集群环境下，<code>serverCron</code> 也负责检查各节点的分片数据，处理分片重分配等操作。</li></ul><p>g) 统计信息更新</p><ul><li>每次执行 <code>serverCron</code> 时，Redis 会更新一些运行时的统计信息，如内存使用情况、命令执行次数、客户端数量等。这些信息对运维监控和性能分析非常重要。</li></ul><p>h) Lua 脚本处理</p><ul><li>Redis 支持 Lua 脚本，<code>serverCron</code> 会检查当前正在执行的 Lua 脚本。如果脚本执行超时，它会中断脚本执行，并返回错误。</li></ul><h3 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h3><p>一个Redis服务器从启动到能够接受客户端的命令请求，需要经过一系列的初始化和设置过程，比如初始化服务器状态，接受用户指定的服务器配置，创建相应的数据结构和网络连接等等。</p><h4 id="初始化服务器状态结构"><a href="#初始化服务器状态结构" class="headerlink" title="初始化服务器状态结构"></a>初始化服务器状态结构</h4><p>初始化服务器的第一步就是创建一个<code>struct redisServer</code>类型的实例变量server作为服务器的状态，并为结构中的各个属性设置默认值。<br>初始化server变量的工作由redis.c&#x2F;initServerConfig函数完成</p><p>以下是initServerConfig函数完成的主要工作：</p><ul><li>设置服务器的运行ID。</li><li>设置服务器的默认运行频率。</li><li>设置服务器的默认配置文件路径。</li><li>设置服务器的运行架构。</li><li>设置服务器的默认端口号。</li><li>设置服务器的默认RDB持久化条件和AOF持久化条件。</li><li>初始化服务器的LRU时钟。</li><li>创建命令表。</li></ul><h4 id="载入配置选项"><a href="#载入配置选项" class="headerlink" title="载入配置选项"></a>载入配置选项</h4><p>在启动服务器时，用户可以通过给定配置参数或者指定配置文件来修改服务器的默认配置。</p><ul><li>如果用户为这些属性的相应选项指定了新的值，那么服务器就使用用户指定的值来更新相应的属性。</li><li>如果用户没有为属性的相应选项设置新的值，那么服务器就沿用之前initServerConfig函数为属性设置的默认值。</li></ul><h4 id="初始化服务器数据结构"><a href="#初始化服务器数据结构" class="headerlink" title="初始化服务器数据结构"></a>初始化服务器数据结构</h4><p>在之前执行initServerConfig函数初始化server状态时，程序只创建了命令表一个数据结构，不过除了命令表之外，服务器状态还包含其他数据结构，比如：</p><ul><li>server.clients链表，这个链表记录了所有与服务器相连的客户端的状态结构，链表的每个节点都包含了一个redisClient结构实例。</li><li>server.db数组，数组中包含了服务器的所有数据库。</li><li>用于保存频道订阅信息的server.pubsub_channels字典，以及用于保存模式订阅信息的server.pubsub_patterns链表。</li><li>用于执行Lua脚本的Lua环境server.lua。</li><li>用于保存慢查询日志的server.slowlog属性。</li></ul><p>当初始化服务器进行到这一步，服务器将调用initServer函数，为以上提到的数据结构分配内存，并在有需要时，为这些数据结构设置或者关联初始化值。<br>服务器到现在才初始化数据结构的原因在于，服务器必须先载入用户指定的配置选项，然后才能正确地对数据结构进行初始化。<br>如果在执行initServerConfig函数时就对数据结构进行初始化，那么一旦用户通过配置选项修改了和数据结构有关的服务器状态属性，服务器就要重新调整和修改已创建的数据结构。<br>为了避免出现这种麻烦的情况，服务器选择了将server状态的初始化分为两步进行，initServerConfig函数主要负责初始化一般属性，而initServer函数主要负责初始化数据结构。</p><p>除了初始化数据结构之外，initServer还进行了一些非常重要的设置操作，其中包括：</p><ul><li>为服务器设置进程信号处理器。</li><li>创建共享对象：这些对象包含Redis服务器经常用到的一些值，比如包含”OK”回复的字符串对象，包含”ERR”回复的字符串对象，包含整数1到10000的字符串对象等等，服务器通过重用这些共享对象来避免反复创建相同的对象。</li><li>打开服务器的监听端口，并为监听套接字关联连接应答事件处理器，等待服务器正式运行时接受客户端的连接。</li><li>为serverCron函数创建时间事件，等待服务器正式运行时执行serverCron函数。</li><li>如果AOF持久化功能已经打开，那么打开现有的AOF文件，如果AOF文件不存在，那么创建并打开一个新的AOF文件，为AOF写入做好准备。</li><li>初始化服务器的后台I&#x2F;O模块（bio），为将来的I&#x2F;O操作做好准备。</li></ul><p>当initServer函数执行完毕之后，服务器将用ASCII字符在日志中打印出Redis的图标，以及Redis的版本号信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">2024-11-13T01:58:13.881201049Z                 _._                                                  </span><br><span class="line">2024-11-13T01:58:13.881203185Z            _.-``__ &#x27;&#x27;-._                                             </span><br><span class="line">2024-11-13T01:58:13.881204638Z       _.-``    `.  `_.  &#x27;&#x27;-._           Redis Community Edition      </span><br><span class="line">2024-11-13T01:58:13.881205864Z   .-`` .-```.  ```\/    _.,_ &#x27;&#x27;-._     7.4.1 (00000000/0) 64 bit</span><br><span class="line">2024-11-13T01:58:13.881207186Z  (    &#x27;      ,       .-`  | `,    )     Running in standalone mode</span><br><span class="line">2024-11-13T01:58:13.881208407Z  |`-._`-...-` __...-.``-._|&#x27;` _.-&#x27;|     Port: 6379</span><br><span class="line">2024-11-13T01:58:13.881209585Z  |    `-._   `._    /     _.-&#x27;    |     PID: 1</span><br><span class="line">2024-11-13T01:58:13.881210759Z   `-._    `-._  `-./  _.-&#x27;    _.-&#x27;                                   </span><br><span class="line">2024-11-13T01:58:13.881211947Z  |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;|                                  </span><br><span class="line">2024-11-13T01:58:13.881213124Z  |    `-._`-._        _.-&#x27;_.-&#x27;    |           https://redis.io       </span><br><span class="line">2024-11-13T01:58:13.881214326Z   `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;                                   </span><br><span class="line">2024-11-13T01:58:13.881215484Z  |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;|                                  </span><br><span class="line">2024-11-13T01:58:13.881216637Z  |    `-._`-._        _.-&#x27;_.-&#x27;    |                                  </span><br><span class="line">2024-11-13T01:58:13.881217812Z   `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;                                   </span><br><span class="line">2024-11-13T01:58:13.881218989Z       `-._    `-.__.-&#x27;    _.-&#x27;                                       </span><br><span class="line">2024-11-13T01:58:13.881220151Z           `-._        _.-&#x27;                                           </span><br><span class="line">2024-11-13T01:58:13.881221346Z               `-.__.-&#x27;                                               </span><br><span class="line">2024-11-13T01:58:13.881222564Z </span><br><span class="line">2024-11-13T01:58:13.883108976Z 1:M 13 Nov 2024 01:58:13.883 * Server initialized</span><br></pre></td></tr></table></figure><h4 id="还原数据库状态"><a href="#还原数据库状态" class="headerlink" title="还原数据库状态"></a>还原数据库状态</h4><p>在完成了对服务器状态server变量的初始化之后，服务器需要载入RDB文件或者AOF文件，并根据文件记录的内容来还原服务器的数据库状态。<br>根据服务器是否启用了AOF持久化功能，服务器载入数据时所使用的目标文件会有所不同：</p><ul><li>如果服务器启用了AOF持久化功能，那么服务器使用AOF文件来还原数据库状态。</li><li>相反地，如果服务器没有启用AOF持久化功能，那么服务器使用RDB文件来还原数据库状态。</li></ul><p>当服务器完成数据库状态还原工作之后，服务器将在日志中打印出载入文件并还原数据库状态所耗费的时长。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2024-11-13T01:58:13.883532676Z 1:M 13 Nov 2024 01:58:13.883 * Loading RDB produced by version 7.4.1</span><br><span class="line">2024-11-13T01:58:13.883543863Z 1:M 13 Nov 2024 01:58:13.883 * RDB age 169350 seconds</span><br><span class="line">2024-11-13T01:58:13.883545635Z 1:M 13 Nov 2024 01:58:13.883 * RDB memory usage when created 1.16 Mb</span><br><span class="line">2024-11-13T01:58:13.883549523Z 1:M 13 Nov 2024 01:58:13.883 * Done loading RDB, keys loaded: 1, keys expired: 0.</span><br><span class="line">2024-11-13T01:58:13.883742175Z 1:M 13 Nov 2024 01:58:13.883 * DB loaded from disk: 0.000 seconds</span><br></pre></td></tr></table></figure><h4 id="执行事件循环"><a href="#执行事件循环" class="headerlink" title="执行事件循环"></a>执行事件循环</h4><p>在初始化的最后一步，服务器将打印出以下日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2024-11-13T01:58:13.883757032Z 1:M 13 Nov 2024 01:58:13.883 * Ready to accept connections tcp</span><br></pre></td></tr></table></figure><p>并开始执行服务器的事件循环（loop）。<br>至此，服务器的初始化工作圆满完成，服务器现在开始可以接受客户端的连接请求，并处理客户端发来的命令请求了。</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>至此，这本书已经读完一半了。剩下还有两部分，多机数据库的实现（第十五至十七章）和独立功能的实现（第十八至第二十四章）。<br>由于这本书是16年出版的，所使用的redis版本为2.9 ，而我测试使用的redis版本为7.4<br>经过近十年的更新，书中很多api和参数可能已经变化或弃用。不过整体架构肯定是一脉相承的。<br>所以这本书的阅读就到这里了。</p><p>最后，技术相关书籍的阅读学习还是要找近两三年出版的比较好。<br>特别是关于实现方面，涉及大量需要实际搭环境验证的场景，过时的内容非常影响阅读。另外，非常推荐阅读官方文档，<a class="link"   href="https://redis.io/docs/latest/" >Redis官方文档<i class="fas fa-external-link-alt"></i></a>还是挺详细的，还有AI式的搜索。<br>但是关于设计方面，思想不会过时，架构则是根据实际需要去设计调整。那么这本书还是值得一看的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第九章-数据库&quot;&gt;&lt;a href=&quot;#第九章-数据库&quot; class=&quot;headerlink&quot; title=&quot;第九章 - 数据库&quot;&gt;&lt;/a&gt;第九章 - 数据库&lt;/h2&gt;&lt;h3 id=&quot;服务器中的数据库&quot;&gt;&lt;a href=&quot;#服务器中的数据库&quot; class=&quot;head</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://cooooing.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Redis" scheme="https://cooooing.github.io/tags/Redis/"/>
    
    <category term="数据库" scheme="https://cooooing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="《Redis设计与实现》" scheme="https://cooooing.github.io/tags/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B/"/>
    
  </entry>
  
</feed>
