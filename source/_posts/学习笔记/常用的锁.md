---
layout: post
title: 常用的锁
date: 2025-07-31 14:22:54
categories:
  - 学习笔记
tags:
  - 并发
  - 锁
---

在并发编程中，锁是用于同步线程、避免数据竞争和确保线程安全的重要机制。

## 互斥锁（Mutex）

互斥锁是最基本的锁类型，确保同一时间只有一个线程可以访问共享资源。

- 线程获取锁后，其他尝试获取锁的线程会被阻塞，直到锁被释放。
- 通常用于保护临界区（Critical Section）。
- 实现简单，但可能导致线程阻塞和上下文切换开销。

> 用于需要确保独占访问共享资源的场景。

## 读写锁（Read-Write Lock）

允许多个线程同时读取共享资源，但写操作需独占访问。

- **读锁**：多个线程可同时持有读锁（共享锁）。
- **写锁**：写锁是独占的，写时不允许其他读或写操作。
- 提高并发性能，尤其在读多写少的场景。

是互斥锁的一种扩展，区分读写操作以提升性能。
> 用于读操作频繁、写操作较少的场景，如数据库缓存。

## 条件锁（Condition Lock）

结合条件变量，用于线程间的协作，线程在特定条件满足时才继续执行。

- 通常与互斥锁配合使用，线程等待条件满足时进入休眠，条件满足时被唤醒。
- 提高效率，避免忙等待。

条件锁依赖互斥锁，互斥锁保护共享条件变量。
> 用于生产者-消费者模型、线程同步等待。

## 信号量（Semaphore）

一种计数器机制，控制多个线程对有限资源的访问。

- 允许指定数量的线程同时访问资源（计数>1）。
- 当计数为1时，行为类似于互斥锁。

信号量是互斥锁的泛化，支持多线程并发访问。互斥锁限制为单一线程访问。
> 用于限制并发访问数量，如连接池管理。

## 分布式锁

在分布式系统中，用于协调多个进程或节点对共享资源的访问。

- 跨机器实现，通常基于外部存储（如Redis、ZooKeeper、Etcd）。
- 需考虑网络延迟、节点故障等复杂情况。

分布式锁是互斥锁的分布式扩展，适用于跨进程或跨机器场景。本地锁（如Mutex）仅限于单机多线程。
> 用于分布式系统中协调跨进程或跨节点的资源访问，如分布式任务调度。

## 悲观锁和乐观锁（加锁策略）

### 悲观锁（Pessimistic Lock）

悲观锁假设并发操作中冲突（数据竞争）发生的概率较高，因此**在访问共享资源之前，总是先获取锁**，确保独占访问。其他线程在锁被释放前会被阻塞。

> 适用于写操作频繁、冲突概率高、数据一致性要求严格的场景。
> 如互斥锁、读写锁、数据库锁（行锁、表锁）。

### 乐观锁（Optimistic Lock）

乐观锁假设并发操作中冲突发生的概率较低，**允许线程先执行操作，在提交时检查数据是否被修改**。
如果未被修改，则提交成功；否则，回滚并重试。**乐观锁通常不使用传统锁机制，而是依赖版本控制或原子操作**。

乐观锁是非阻塞的，线程直接操作共享资源，而无需等待锁。
通过版本号、时间戳或CAS（Compare-And-Swap）检查数据是否被修改。

> 适用于读多场景，高并发低冲突。
> 如缓存更新、计数器

## 阻塞锁和非阻塞锁（等待机制）

### 阻塞锁（Blocking Lock）

阻塞锁是指当线程尝试获取锁时，如果锁已被其他线程占用，当前线程会进入阻塞状态（挂起），等待锁释放。
阻塞状态通常由操作系统管理，线程被放入等待队列，暂停执行，直到被唤醒。

**锁不可用时，线程被挂起，释放CPU资源。**
但通常涉及线程的上下文切换（从用户态到内核态），开销较高。
线程唤醒和重新调度可能引入延迟。

> 适用于需要强一致性、长时间持有锁或高冲突场景。
> 互斥锁、读写锁、条件锁都属于阻塞锁。

### 非阻塞锁（Non-Blocking Lock）

非阻塞锁是指当线程尝试获取锁时，如果锁不可用，线程不会进入阻塞状态，而是立即返回（失败）或通过忙等待（busy-waiting）继续尝试。
非阻塞锁通常基于原子操作实现，尽量避免操作系统介入。

**锁不可用时，线程要么立即返回，要么短暂自旋（循环尝试）。**
基于原子操作（如CAS、Test-and-Set），通常在用户态完成。
自旋可能浪费CPU资源，但避免上下文切换。

> 适用于需要高吞吐量、短锁持有时间、冲突概率较低的场景。
> 自旋锁、乐观锁属于非阻塞锁。TryLock机制用于快速失败（尝试获取锁，失败则立即返回）。

## 可重入锁和非可重入锁（重入性）

**基于锁是否允许同一线程多次获取的特性进行分类。** 
它们在实现线程安全和避免死锁方面有显著差异。

### 可重入锁（Reentrant Lock）

可重入锁允许同一线程多次获取同一把锁而不会导致死锁。每次获取锁时，锁内部会记录重入次数，线程必须释放相同次数的锁才能完全解锁。

同一线程可多次调用Lock()，每次增加锁的计数器。
释放时需调用Unlock()与Lock()次数相同，计数器减为0时锁被释放。

> 适用于复杂逻辑中，同一线程多次进入临界区（递归函数或嵌套调用）的场景。

### 非可重入锁（Non-Reentrant Lock）

非可重入锁不允许同一线程多次获取同一把锁。如果线程尝试重复加锁，会导致死锁或异常。

> 适用于简单互斥场景。


## 公平锁和非公平锁（分配策略）

**根据锁的分配策略分类。**
区别在于当多个线程（或goroutine）竞争锁时，锁是否按照线程请求的顺序（通常是先到先得）分配。

### 公平锁（Fair Lock）

公平锁确保线程按照请求锁的顺序获取锁，通常采用先到先得（FIFO，First-In-First-Out）策略。
当锁释放时，等待队列中最先请求的线程优先获得锁。

线程按请求顺序获取锁，避免线程饥饿（某些线程长期无法获取锁）。
维护了一个队列，用于记录线程的请求顺序。在锁被释放时，唤醒队列头部的线程。

> 适用于需要严格公平性、避免线程饥饿的场景。
> 需要维护队列，性能相对较低。

### 非公平锁（Non-Fair Lock）

**非公平锁不保证线程按请求顺序获取锁。**
当锁释放时，等待线程和新请求线程竞争锁，操作系统或运行时决定哪个线程获得锁，可能导致后请求的线程优先获取。

不保证FIFO，可能导致线程饥饿（某些线程长期无法获取锁）。

> 适用于追求高性能、允许一定程度不公平的场景。

