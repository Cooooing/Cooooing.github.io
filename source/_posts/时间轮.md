---
layout: post
title: 时间轮
date: 2025-07-23 22:29:39
categories:
  - 编程记录
tags:
  - go
  - 时间轮
  - 定时任务
  - 算法
---

## 介绍

时间轮（Timing Wheel）是一种高效的时间管理数据结构，广泛应用于网络协议、操作系统、定时任务调度等领域。
时间轮的核心思想是将时间划分为多个“槽”（slot），每个槽对应一个时间单位，并通过指针的旋转来管理定时任务。

## 时间轮的两种设计

时间轮由多个时间槽组成，每个时间槽对应一个时间单位（如1毫秒、1秒等），是它所支持的最小粒度。
时间轮的核心是一个环形数组，数组的每个元素代表一个时间槽。时间轮有一个指针，指向当前的时间槽，随着时间的推进，指针会顺时针移动，类似于钟表的指针。

1. **初始化**：时间轮初始化时，所有时间槽为空。
2. **添加任务**：当需要添加一个定时任务时，系统会根据任务的延迟时间计算出它应该被放置在哪个时间槽中。例如，如果当前指针指向第 `n` 个槽，任务的延迟时间为 `t`，每个槽的时间单位为 `Δt`，则任务应被放置在 `(n + t / Δt) % N` 个槽中（其中 `N` 是时间轮的总槽数）。
3. **指针移动**：每隔一个时间单位（如1毫秒），指针向前移动一个槽。
4. **任务执行**：当指针到达某个槽时，该槽中的所有任务都会被执行。

为了支持更长的定时任务，有两个拓展时间轮的设计。多层时间轮和记录圈数的时间轮。

**多层时间轮模仿了现实世界中的时钟结构：秒针、分针、时针分别代表不同层级的时间单位。每一层时间轮负责一个时间单位（如秒、分、小时），低层时间轮每完成一圈，上层时间轮前进一格。**

例如：
第一层：每个槽代表1秒，共60槽（代表1分钟）
第二层：每个槽代表1分钟，共60槽（代表1小时）
第三层：每个槽代表1小时，共24槽（代表1天）

每隔一个时间单位（如1秒），最底层时间轮指针移动
如果最底层完成一圈，第二层移动一格
如果第二层完成一圈，第三层移动一格
每当最底层的指针移动到某个槽时，执行该槽中的所有任务。
当其他层的指针移动到某个槽时，将该槽中的任务加入下一层的时间轮。**高层轮的任务只是“占位符”，真正的执行在最底层（秒轮）进行。**

例如一个任务在 1小时2分钟3秒后执行。当前时间为21:30:02，任务在22:32:05执行。

| 层级 | 槽号 | 说明                  |
|----|----|---------------------|
| 时轮 | 22 | 1小时后触发，触发后将任务推进到分轮  |
| 分轮 | 32 | 32分钟后触发，触发后将任务推进到秒轮 |
| 秒轮 | 5  | 5秒后执行最终任务           |

它支持非常长延时的任务，并且内存占用较低，时间复杂度为O(1)。但实现复杂，需要处理多级时间轮联动。

**记录圈数的时间轮在每个槽中不仅记录任务，还记录该任务需要等待的圈数（round）。指针每移动一圈，所有任务的圈数减一，当圈数为零时执行任务。**

它是一个固定大小的时间轮（如32或64个槽）。每个槽是一个任务列表，每个任务额外记录圈数。

每次指针移动一个槽
遍历当前槽中所有任务：如果任务的round > 0，round -= 1，如果 round == 0，执行任务

它的结构简单易于实现，支持较长的延迟，时间复杂度也为O(1)。但它每次移动指针时需要遍历当前槽中的所有任务。

## 实现

这里实现记录圈数方式的时间轮。

~~~go
package timewheel

import (
	"container/list"
	"errors"
	"github.com/orcaman/concurrent-map/v2"
	"github.com/panjf2000/ants/v2"
	"github.com/sirupsen/logrus"
	"runtime/debug"
	"time"
)

// TimeWheel 核心结构体
type TimeWheel struct {
	interval          time.Duration // 时间轮的精度
	slots             []*list.List  // 时间轮每个位置存储的Task列表
	ticker            *time.Ticker  // 时间轮的计时器
	currentPos        int           // 时间轮当前的位置
	slotNums          int           // 时间轮的齿轮数 interval*slotNums就是时间轮转一圈走过的时间
	addTaskChannel    chan *Task
	removeTaskChannel chan *Task
	stopChannel       chan bool
	taskRecords       cmap.ConcurrentMap[string, *list.Element] // Map结构来存储Task对象，key是Task.key，value是Task在双向链表中的存储对象list.Element
	isRunning         bool
	pool              *ants.Pool // 协程池
}

// Job 需要执行的Job的函数结构体
type Job func(task *Task)

// Task 时间轮上需要执行的任务
type Task struct {
	Key         string        // 用来标识task对象，是唯一的
	Interval    time.Duration // 任务周期
	Times       int           // 任务需要执行的次数，如果需要一直执行，设置成-1
	Job         Job           // 任务需要执行的Job
	createdTime time.Time     // 任务的创建时间
	pos         int           // 任务在轮的位置
	circle      int           // 任务需要在轮走多少圈才能执行
}

// ErrDuplicateTaskKey is an definedError for duplicate task key
var ErrDuplicateTaskKey = errors.New("duplicate task key")

// ErrTaskKeyNotFount is an definedError when task key is not found
var ErrTaskKeyNotFount = errors.New("task key doesn't existed in task list, please check your input")

// NewTimeWheel 初始化一个TimeWheel对象
func NewTimeWheel(interval time.Duration, slotNums int) *TimeWheel {
	if interval <= 0 || slotNums <= 0 {
		return nil
	}
	pool, err := ants.NewPool(
		16,
		ants.WithPreAlloc(true),
		ants.WithNonblocking(true),
	)
	if err != nil {
		logrus.Errorf("init [timewhell] ants pool failed: %v", err)
	}
	tw := &TimeWheel{
		interval:          interval,
		slots:             make([]*list.List, slotNums),
		currentPos:        0,
		slotNums:          slotNums,
		addTaskChannel:    make(chan *Task, 16),
		removeTaskChannel: make(chan *Task, 16),
		stopChannel:       make(chan bool),
		taskRecords:       cmap.New[*list.Element](),
		isRunning:         false,
		pool:              pool,
	}
	tw.initSlots()
	return tw
}

// Start 启动时间轮
func (tw *TimeWheel) Start() {
	tw.ticker = time.NewTicker(tw.interval)
	go func(tw *TimeWheel) {
		for {
			select {
			case <-tw.ticker.C:
				tw.checkAndRunTask()
			case task := <-tw.addTaskChannel:
				tw.addTask(task, false)
			case task := <-tw.removeTaskChannel:
				tw.removeTask(task)
			case <-tw.stopChannel:
				tw.ticker.Stop()
				return
			}
		}
	}(tw)
	tw.isRunning = true
}

// Stop 关闭时间轮
func (tw *TimeWheel) Stop() {
	tw.stopChannel <- true
	tw.isRunning = false
	tw.pool.Release()
}

// IsRunning 检查全局时间轮是否在正常运行
func (tw *TimeWheel) IsRunning() bool {
	return tw.isRunning
}

// Exist 检查任务是否存在
func (tw *TimeWheel) Exist(key string) bool {
	_, ok := tw.taskRecords.Get(key)
	return ok
}

// GetTaskTimes 获取任务剩余执行次数
func (tw *TimeWheel) GetTaskTimes(key string) int {
	t, ok := tw.taskRecords.Get(key)
	if !ok {
		return 0
	}
	return t.Value.(*Task).Times
}

// AddTask 向时间轮添加固定周期任务
func (tw *TimeWheel) AddTask(task *Task) error {
	if task.Interval <= 0 || task.Key == "" {
		return errors.New("invalid task params")
	}

	// 检查Task.Key是否已经存在
	_, ok := tw.taskRecords.Get(task.Key)
	if ok {
		return ErrDuplicateTaskKey
	}
	task.createdTime = time.Now()
	tw.addTaskChannel <- task
	return nil
}

// RemoveTask 从时间轮删除任务
func (tw *TimeWheel) RemoveTask(key string) error {
	if key == "" {
		return nil
	}

	// 检查该Task是否存在
	val, ok := tw.taskRecords.Get(key)
	if !ok {
		return ErrTaskKeyNotFount
	}

	task := val.Value.(*Task)
	tw.removeTaskChannel <- task
	return nil
}

// 初始化时间轮，每个轮上的卡槽用一个双向队列表示，便于插入和删除
func (tw *TimeWheel) initSlots() {
	for i := 0; i < tw.slotNums; i++ {
		tw.slots[i] = list.New()
	}
}

// 检查该轮点位上的Task，看哪个需要执行
func (tw *TimeWheel) checkAndRunTask() {

	// 获取该轮位置的双向链表
	currentList := tw.slots[tw.currentPos]

	if currentList != nil {
		for item := currentList.Front(); item != nil; {
			task, ok := item.Value.(*Task)
			if !ok {
				item = item.Next()
				continue
			}
			next := item.Next()
			if task.circle > 0 {
				task.circle--
			} else {
				if task.Job != nil {
					// 使用协程池执行任务
					err := tw.pool.Submit(func() {
						defer func() {
							if err := recover(); err != nil {
								stack := debug.Stack()
								logrus.Errorf("task %v panic: %v %s\n", task.Key, err, string(stack))
							}
						}()
						task.Job(task)
					})
					if err != nil {
						logrus.Errorf("task %v submit failed: %v\n", task.Key, err)
					}
				} else {
					logrus.Warnf("The task %s don't have job to run\n", task.Key)
				}

				tw.taskRecords.Remove(task.Key)
				currentList.Remove(item)

				if task.Times < 0 {
					tw.addTask(task, true) // 无限次，继续添加
				} else if task.Times > 1 {
					task.Times--
					tw.addTask(task, true) // 剩余次数大于1，继续添加
				}

			}
			item = next
		}
	}

	// 轮前进一步
	tw.currentPos = (tw.currentPos + 1) % tw.slotNums
}

// 添加任务的内部函数
func (tw *TimeWheel) addTask(task *Task, byInterval bool) {
	var pos, circle int
	// 使用任务周期或创建时间生成
	if byInterval {
		pos, circle = tw.getPosAndCircleByInterval(task.Interval)
	} else {
		pos, circle = tw.getPosAndCircleByCreatedTime(task.createdTime, task.Interval)
	}

	task.circle = circle
	task.pos = pos

	element := tw.slots[pos].PushBack(task)
	tw.taskRecords.Set(task.Key, element)
}

// 删除任务的内部函数
func (tw *TimeWheel) removeTask(task *Task) {
	val, ok := tw.taskRecords.Get(task.Key)
	if !ok {
		return
	}
	tw.taskRecords.Remove(task.Key)
	if t, ok := val.Value.(*Task); ok && t.pos < tw.slotNums {
		tw.slots[t.pos].Remove(val)
	}
}

// 该函数通过任务的周期来计算下次执行的位置和圈数
func (tw *TimeWheel) getPosAndCircleByInterval(d time.Duration) (int, int) {
	delayMs := int(d.Milliseconds())
	intervalMs := int(tw.interval.Milliseconds())
	ticks := delayMs / intervalMs
	circle := ticks / tw.slotNums
	pos := (tw.currentPos + ticks) % tw.slotNums

	// 特殊case，当计算的位置和当前位置重叠时，因为当前位置已经走过了，所以circle需要减一
	if pos == tw.currentPos && circle != 0 {
		circle--
	}
	return pos, circle
}

// 该函数用任务的创建时间来计算下次执行的位置和圈数
func (tw *TimeWheel) getPosAndCircleByCreatedTime(createdTime time.Time, d time.Duration) (int, int) {
	delayMs := int(d.Milliseconds())
	intervalMs := int(tw.interval.Milliseconds())
	ticksPassed := int(time.Since(createdTime).Milliseconds()) / intervalMs
	totalTicks := delayMs / intervalMs
	remainingTicks := totalTicks - ticksPassed

	if remainingTicks <= 0 {
		remainingTicks = 1 // 防止立即过期
	}

	circle := remainingTicks / tw.slotNums
	pos := (tw.currentPos + remainingTicks) % tw.slotNums

	// 特殊case，当计算的位置和当前位置重叠时，因为当前位置已经走过了，所以circle需要减一
	if pos == tw.currentPos && circle != 0 {
		circle--
	}

	return pos, circle
}
~~~

测试：

~~~go
package test

import (
	"catventure-idle-server/internal/common/timewheel"
	"github.com/sirupsen/logrus"
	"testing"
	"time"
)

func TestTimeWheel(t *testing.T) {
	var err error
	tw := timewheel.NewTimeWheel(time.Second, 60)
	tw.Start()

	err = tw.AddTask(&timewheel.Task{
		Key:      "test1",
		Interval: time.Second * 5,
		Times:    -1,
		Job: func(task *timewheel.Task) {
			logrus.Infof("task %s run at %s\n", task.Key, time.Now().Format("2006-01-02 15:04:05"))
		},
	})
	if err != nil {
		logrus.Errorf("add task failed: %v", err)
	}
	err = tw.AddTask(&timewheel.Task{
		Key:      "test2",
		Interval: time.Second * 1,
		Times:    10,
		Job: func(task *timewheel.Task) {
			logrus.Infof("task %s run at %s\n", task.Key, time.Now().Format("2006-01-02 15:04:05"))
		},
	})
	if err != nil {
		logrus.Errorf("add task failed: %v", err)
	}
	
	time.Sleep(time.Second * 30) // 休眠30s，查看运行结果
}
~~~

运行结果：

~~~
=== RUN   TestTimeWheel
time="2025-07-24T22:24:57+08:00" level=info msg="task test2 run at 2025-07-24 22:24:57\n"
time="2025-07-24T22:24:58+08:00" level=info msg="task test2 run at 2025-07-24 22:24:58\n"
time="2025-07-24T22:24:59+08:00" level=info msg="task test2 run at 2025-07-24 22:24:59\n"
time="2025-07-24T22:25:00+08:00" level=info msg="task test2 run at 2025-07-24 22:25:00\n"
time="2025-07-24T22:25:00+08:00" level=info msg="task test1 run at 2025-07-24 22:25:00\n"
time="2025-07-24T22:25:01+08:00" level=info msg="task test2 run at 2025-07-24 22:25:01\n"
time="2025-07-24T22:25:02+08:00" level=info msg="task test2 run at 2025-07-24 22:25:02\n"
time="2025-07-24T22:25:03+08:00" level=info msg="task test2 run at 2025-07-24 22:25:03\n"
time="2025-07-24T22:25:04+08:00" level=info msg="task test2 run at 2025-07-24 22:25:04\n"
time="2025-07-24T22:25:05+08:00" level=info msg="task test2 run at 2025-07-24 22:25:05\n"
time="2025-07-24T22:25:05+08:00" level=info msg="task test1 run at 2025-07-24 22:25:05\n"
time="2025-07-24T22:25:10+08:00" level=info msg="task test1 run at 2025-07-24 22:25:10\n"
time="2025-07-24T22:25:15+08:00" level=info msg="task test1 run at 2025-07-24 22:25:15\n"
time="2025-07-24T22:25:20+08:00" level=info msg="task test1 run at 2025-07-24 22:25:20\n"
--- PASS: TestTimeWheel (30.00s)
PASS
~~~