<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="技术博客,后端开发,编程笔记,生活">
    <meta name="description" content="Code | Systems | Life — 专注编程本质，也关心世界如何运转。">
    <meta name="author" content="咕咕咕">

    
    <title>
        
            《收获，不止Oracle》读书笔记上篇-表设计 |
        
        咕咕咕的小破站
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/favicon.png">
    
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    
        
            
                
<link rel="stylesheet" href="/css/APlayer.min.css">

            
        
            
                
<link rel="stylesheet" href="/css/custom.css">

            
        
    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"cooooing.github.io","root":"/","language":"zh-CN","path":"search.json"}
    KEEP.theme_config = {"base_info":{"primary_color":"#0066cc","title":"咕咕咕的小破站","author":"咕咕咕","avatar":"/images/head.jpg","logo":"/images/head.jpg","favicon":"/images/favicon.png"},"menu":{"Archives":"/archives","Categories":"/categories","Tags":"/tags","日常":"/daily","Links":"/links","About":"/about"},"first_screen":{"enable":false,"background_img":"/images/bg.svg","background_img_dark":"/images/bg.svg","description":"Keep writing and Keep loving.","hitokoto":false},"social_contact":{"enable":false,"links":{"github":null,"weixin":null,"qq":null,"weibo":null,"zhihu":null,"twitter":null,"facebook":null,"email":null}},"scroll":{"progress_bar":false,"percent":false,"hide_header":true},"home":{"category":true,"tag":true,"announcement":null},"post":{"author_badge":{"enable":true,"level_badge":false,"custom_badge":["fishing"]},"word_count":{"wordcount":true,"min2read":true},"datetime_format":"YYYY-MM-DD HH:mm:ss","copyright_info":true,"share":true,"reward":{"enable":true,"img_link":"/images/thanks.png","text":"谢谢你请我喝可乐~"}},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true,"layout":"left"},"website_count":{"busuanzi_count":{"enable":true,"site_uv":true,"site_pv":true,"page_pv":true}},"local_search":{"enable":true,"preload":true},"comment":{"enable":true,"use":"giscus","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.21"},"waline":{"server_url":null,"reaction":false,"version":2},"giscus":{"repo":"Cooooing/Cooooing.github.io","repo_id":"R_kgDOHQal_w","category":"Announcements","category_id":"DIC_kwDOHQal_84CjZo6","reactions_enabled":true},"artalk":{"server":null},"disqus":{"shortname":null}},"rss":{"enable":true},"lazyload":{"enable":true},"cdn":{"enable":false,"provider":"cdnjs"},"pjax":{"enable":true},"footer":{"since":2022,"word_count":true,"icp":{"enable":false,"record_code":null,"url":"https://beian.miit.gov.cn"},"site_deploy":{"enable":false,"provider":"github","url":null},"shields_style":{"enable":false,"custom":[{"link_url":null,"img_url":null}]}},"inject":{"enable":true,"css":["/css/APlayer.min.css","/css/custom.css"],"js":["/js/APlayer.min.js","/js/Meting.min.js","/js/leaves.js"]},"root":"","links":[{"name":"鼠鼠在碎觉","link":"https://sszsj.com","avatar":"https://tmx.fishpi.cn/img/head.jpg","description":"我是不慎落入世界的一滴水墨"},{"name":"Gakkiyomi","link":"https://gakkiyomi.blog","avatar":"https://avatars.githubusercontent.com/u/41406557?v=4","description":"为往圣继绝学"},{"name":"Hancel's Blog","link":"https://my.hancel.org","avatar":"https://my.hancel.org/media/logo.jpg","description":"人生而自由，却无往不在枷锁之中。"},{"name":"Eastshann","link":"http://121.4.99.208/","avatar":"http://121.4.99.208/img/avatar.jpg","description":"冲和者，淡泊平和，谦冲守正"},{"name":"小于同学的异世界","link":"https://yby.zone","avatar":"https://yby-zone.obs.cn-east-3.myhuaweicloud.com/avatar.jpg","description":"为吾为枝，余地三尺，以己为棋，胜天半子。"},{"name":"Mlikiowa Home Village","link":"https://nanaeo.cn/","avatar":"https://q1.qlogo.cn/g?b=qq&nk=1627126029&s=100","description":"A litter Village With Mlikiowa"},{"name":"忘忧草","link":"https://owo.wyc.rest/","avatar":"https://owo.wyc.rest/img/%E4%B8%87%E5%8F%B6.jpg","description":"这只是一个小破站而已！"},{"name":"stillwarter","link":"https://stillwarter.github.io/","avatar":"https://file.fishpi.cn/2022/07/MOSHED2022621164630-1b1ec532.gif?imageView2/1/w/210/h/210/interlace/0/q/100","description":"光就是一切的意义"},{"name":"test12138","link":"http://你好.eu.org/","avatar":"https://file.fishpi.cn/2022/06/srchttpimgzcoolcncommunity0116405d84f975a801211d537707c9gifreferhttpimgzcool-0f2d09c9.gif?imageView2/1/w/48/h/48/interlace/0/q/100","description":"大丈夫生于天地之间，岂能郁郁久居人下。"},{"name":"呼呼呼","link":"https://bongbongbakudan.github.io/","avatar":"https://pwl.stackoverflow.wiki/2021/12/blob-28eb4b9f.png?imageView2/1/w/48/h/48/interlace/0/q/100","description":"去整点薯条"},{"name":"Plumbiu","link":"https://blog.plumbiu.top/","avatar":"https://avatars.githubusercontent.com/u/99574369?v=4","description":"这人很勤奋，啥都没留"},{"name":"hiRipple","link":"https://hiripple.com/","avatar":"https://avatars.githubusercontent.com/u/115361435?v=4","description":"超高校级的游戏玩家"}],"version":"4.0.6"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-CLX32WF4R1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];

      function gtag() {
        dataLayer.push(arguments);
      }

      gtag('js', new Date());

      gtag('config', 'G-CLX32WF4R1');
    </script>

    <!-- 51.la -->
    <script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
    <script>LA.init({id: "3JwPz6wbAloyTmMc", ck: "3JwPz6wbAloyTmMc", autoTrack: true})</script>

<meta name="generator" content="Hexo 8.0.0"><link rel="alternate" href="/atom.xml" title="咕咕咕的小破站" type="application/atom+xml">
</head>

<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>


<main class="page-container border-box">

    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="/images/head.jpg">
                </a>
            
            <a class="site-name border-box" href="/">
               咕咕咕的小破站
            </a>
        </div>

        <div class="right border-box">
            <div class="pc">
                <ul class="menu-list">
                    <li class="menu-item">
                        <a class=""
                           href="/"
                        >首页</a>
                    </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >归档</a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >分类</a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >标签</a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/daily"
                            >日常</a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/links"
                            >友链</a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >关于</a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas search fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            <li class="drawer-menu-item flex-center">
                <a class=""
                   href="/"
                >首页</a>
            </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives"
                    >归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories"
                    >分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags"
                    >标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/daily"
                    >日常</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/links"
                    >友链</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about"
                    >关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">
                

                    
<div class="fade-in-down-animation">
    <div class="post-page-container border-box">
        <div class="post-content-container border-box">
            

            <div class="post-content-bottom border-box">
                
                    <div class="post-title">
                        《收获，不止Oracle》读书笔记上篇-表设计
                    </div>
                

                
                    <div class="post-header border-box">
                        
                            <div class="avatar-box border-box">
                                <img src="/images/head.jpg">
                            </div>
                        
                        <div class="info-box">
                            <div class="author border-box">
                                <span class="name">咕咕咕</span>
                                
                                    <span class="author-badge">fishing</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="post-meta-info-container border-box post">
    <div class="post-meta-info border-box">
        

        
            <span class="meta-info-item post-create-date">
                <i class="icon fa-solid fa-calendar-plus"></i>&nbsp;
                <span class="datetime">2024-08-01 10:36:33</span>
            </span>

            <span class="meta-info-item post-update-date">
                <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                <span class="datetime" data-updated="Thu Aug 01 2024 02:36:33 GMT+0000">2024-08-01 10:36:33</span>
            </span>
        

        
            <span class="meta-info-item post-category border-box"><i class="icon fas fa-folder"></i>&nbsp;
                <ul class="post-category-ul">
                    
                            <li class="category-item"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></li>
                        
                    
                </ul>
            </span>
        

        
            <span class="post-tag meta-info-item border-box">
                <i class="icon fas fa-tags"></i>&nbsp;
                <ul class="post-tag-ul">
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li>
                        
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B/">《收获，不止Oracle》</a></li>
                        
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/Oracle/">Oracle</a></li>
                        
                    
                </ul>
            </span>
        

        
        
            <span class="meta-info-item post-wordcount">
                <i class="icon fas fa-file-word"></i>&nbsp;<span>10.3k 字</span>
            </span>
        
        
            <span class="meta-info-item post-min2read">
                <i class="icon fas fa-clock"></i>&nbsp;<span>43 分钟</span>
            </span>
        
        
            <span class="meta-info-item post-pv">
                <i class="icon fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
            </span>
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="post-content keep-markdown-body">
                    

                    <h2 id="第四章-祝贺，表设计成就英雄"><a href="#第四章-祝贺，表设计成就英雄" class="headerlink" title="第四章 - 祝贺，表设计成就英雄"></a>第四章 - 祝贺，表设计成就英雄</h2><ul>
<li><strong>普通堆表</strong>：适合大部分设计场景，有优点也有缺点，需要和其他表设计取长补短。 <ul>
<li>优点：语法简单方便、适用大部分场景</li>
<li>缺点：表更新日志开销较大、Delete无法释放空间、表记录太大检索较慢、素引回表读开销很大、即便有序插入，也难以有序读出</li>
</ul>
</li>
<li><strong>全局临时表</strong>：适合接口表设计<ul>
<li>优点：高效删除、产生日志少、不同SESSION独立，不产生锁</li>
<li>缺点：语法特别、数据无法得到有效的保护</li>
</ul>
</li>
<li><strong>分区表</strong>：适合日志表<ul>
<li>优点：有效的分区消除、高效的记录清理、高效的记录转移</li>
<li>缺点：语法复杂、分区过多对系统有一定的影响</li>
</ul>
</li>
<li><strong>索引组织表</strong>：适合极少更新的配置表<ul>
<li>优点：表就是索引，可以避免回表、语法复杂</li>
<li>缺点：更新开销牧大</li>
</ul>
</li>
<li><strong>簇表</strong>：适合使用频繁关联查询的多表<ul>
<li>优点：可以减少或避免排序</li>
<li>缺点：语法复杂、表更新开销大</li>
</ul>
</li>
</ul>
<p>每个人都有每个人的特点和优势，要善于发掘和利用，才可以把事情做好。<br>不同的表也一样，有的适用于这个应用场景，却不适合另外一个场景，要学会选择性地使用技术。<br><strong>技术其实并不难，最难的是如何选择。</strong> 这一章主要就是在强调什么场合该选什么技术。没有高级的技术，只有最合适的技术。</p>
<h3 id="普通堆表不足之处"><a href="#普通堆表不足之处" class="headerlink" title="普通堆表不足之处"></a>普通堆表不足之处</h3><h4 id="表更新日志开销较大"><a href="#表更新日志开销较大" class="headerlink" title="表更新日志开销较大"></a>表更新日志开销较大</h4><p>下面的脚本是利用 v$statname 和 v$mystat 两个动态性能视图来跟踪当前SESSION操作产生的日志量.<br>使用方法很简单：首次先执行该脚本，查看日志大小，随即执行你的更新语句，再执行该脚本返回的日志大小，两者相减，就是你此次更新语句产生的日志大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查看产生多少日志</span><br><span class="line">select a.name, b.value</span><br><span class="line">from v$statname a,</span><br><span class="line">     v$mystat b</span><br><span class="line">where a.statistic# = b.statistic#</span><br><span class="line">  and a.name = &#x27;redo size&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 赋权</span><br><span class="line">grant all on v_$statname to TEST_USER;</span><br><span class="line">grant all on v_$mystat to TEST_USER;</span><br><span class="line">-- 以下创建视图，方便后续直接用 select * from v_redo_size 进行查询</span><br><span class="line">create or replace view v_redo_size as</span><br><span class="line">select a.name, b.value</span><br><span class="line">from v$statname a,</span><br><span class="line">     v$mystat b</span><br><span class="line">where a.statistic# = b.statistic#</span><br><span class="line">  and a.name = &#x27;redo size&#x27;;</span><br></pre></td></tr></table></figure>

<p>下面观察各个更新操作产生的日志量。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from v_redo_size;</span><br><span class="line"></span><br><span class="line">NAME                                                                  VALUE</span><br><span class="line">---------------------------------------------------------------- ----------</span><br><span class="line">redo size                                                               600</span><br><span class="line"></span><br><span class="line">SQL&gt; delete from t;</span><br><span class="line"></span><br><span class="line">70927 rows deleted.</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from v_redo_size;</span><br><span class="line"></span><br><span class="line">NAME                                                                  VALUE</span><br><span class="line">---------------------------------------------------------------- ----------</span><br><span class="line">redo size                                                           1152708</span><br><span class="line"></span><br><span class="line">SQL&gt; insert into t select OBJECT_ID from dba_objects;</span><br><span class="line"></span><br><span class="line">71191 rows created.</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from v_redo_size;</span><br><span class="line"></span><br><span class="line">NAME                                                                  VALUE</span><br><span class="line">---------------------------------------------------------------- ----------</span><br><span class="line">redo size                                                           2262512</span><br><span class="line"></span><br><span class="line">SQL&gt; update t set id = rownum;</span><br><span class="line"></span><br><span class="line">71191 rows updated.</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from v_redo_size;</span><br><span class="line"></span><br><span class="line">NAME                                                                  VALUE</span><br><span class="line">---------------------------------------------------------------- ----------</span><br><span class="line">redo size                                                          13080536</span><br></pre></td></tr></table></figure>

<p>删除操作产生了 1152708 - 600 &#x3D; 1146708 字节，大约1.09M 的日志。<br>插入操作产生了 2262512 - 1152708 &#x3D; 1109804 字节，大约1.06M 的日志。<br>更新操作产生了 13080536 - 2262512 &#x3D; 10818024 字节，大约10.32M 的日志。</p>
<p>无论是删除、插入还是修改，都会产生日志。前面体系结构中讲过这些日志是用于数据库的备份和恢复的。<br>如果仅从性能角度而不从安全性角度来考虑，更新表写日志就意味着数据库多做了额外的事情而影响了效率，虽说安全第一，不过在某些特定的场合，某些表的记录只是作为中间结果临时运算而根本无须永久保留，这些表无须写日志，那就既高效又安全了！<br>这就是后续会说的全局临时表。</p>
<h4 id="Delete无法释放空间"><a href="#Delete无法释放空间" class="headerlink" title="Delete无法释放空间"></a>Delete无法释放空间</h4><p>使用 <code>delete from t</code> 删除表，前后查询所产生的逻辑读次数是相同的。只有使用 <code>truncate table t</code> 清空表，才能显著减少逻辑读次数。<br>显然，<strong>delete删除并不能释放空间，虽然delete将很多块的记录删除了，但是空块依然保留，Oracle在查询时依然会去查询这些空块。</strong><br><strong>而truncate是一种释放高水平位的动作，这些空块被回收，空间也就释放了。</strong></p>
<p>不过truncate显然不能替代delete，因为truncate是一种DDL操作而非DML操作，truncate后面是不能带条件的，truncate table t where…是不允许的。<br>但是如果表中这些where条件能形成有效的分区，Oracle是支持在分区表中做truncate分区的，命令大致为 <code>alter table t truncate partition &#39;分区名&#39;</code>。<br>如果where条件就是分区条件，那等同于换角度实现了truncate table t where…的功能。<br><strong>这就是分区表最实用的功能之一了，高效地清理数据，释放空间。</strong></p>
<p>此外，当大量delete删除再大量insert插入时，Oracle会去这些delete的空块中首先完成插入（直接路径插入除外），所以频繁delete又频繁insert的应用，是不会出现空块过多的情况的。</p>
<h4 id="表记录太大检索较慢"><a href="#表记录太大检索较慢" class="headerlink" title="表记录太大检索较慢"></a>表记录太大检索较慢</h4><p>一张表其实就是一个SEGMENT，一般情况下我们都需要遍历该SEGMENT的所有BLOCK来完成对该表进行更新查询等操作，在这种情况下，表越大，更新查询操作就越慢。<br>有没有什么好方法能提升检索的速度呢？主要思路就是缩短访问路径来完成同样的更新查询操作，简单地说就是完成同样的需求访问BLOCK的个数越少越好。<br>Oracle为了尽可能减少访问路径提供了两种主要技术，<strong>一种是索引技术，另一种则是分区技术</strong>。</p>
<p>以 <code>select * from t where insert_time &gt; xxxx and insert_time &lt; xxxx</code> 为例，如果id是主键，那么Oracle会直接通过索引找到对应的BLOCK，然后直接读取该BLOCK中的记录。</p>
<p>首先说索引，这是Oracle中最重要也是最实用的技术之一。<br>在本例中，如果 <code>insert_time &gt; xxxx and insert_time &lt; xxxx</code> 返回的记录非常少，或者说T表的总记录相比非常少，则在 insert_time 列建索引能极大提升该语句的效率。<br>比如建了一个 t_id_index 的索引，在该SQL查询时首先会访问 t_id_index 这个新建出来的索引段，然后通过索引段和表段的映射关系，迅速从表中获取行列的信息并返回结果。具体细节后续索引部分细说。<br>索引本身也是一把双刃剑，既能给数据库开发应用带来极大的帮助，也会给数据库带来不小的灾难。</p>
<p>减少访问路径的第二种技术就是分区技术，把普通表T表改造为分区表，比如以 insert_time 这个时间列为分区字段，比如从 2020年1月到2023年12月按月建36个分区。<br>早先的T表就一个T段，现在情况变化了，从1个大段分解成了36个小段，分别存储了2010年1月到2012年12月的信息，此时假如 <code>insert_time &gt; xxxx and insert_time &lt; xxxx</code> 这个时间跨度正好是落在2020年11月，那Oracle的检索就只要完成一个小段的遍历即可。<br>假设这36个小段比较均匀，我们就可以大致理解为访问量只有原来的三十六分之一，大幅度减少了访问路径，从而高效地提升了性能。</p>
<h4 id="索引回表读开销很大"><a href="#索引回表读开销很大" class="headerlink" title="索引回表读开销很大"></a>索引回表读开销很大</h4><p>观察下面例子中，<code>TABLE ACCESS BY INDEX ROWID BATCHED</code> 的开销。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">L&gt; drop table t purge;</span><br><span class="line"></span><br><span class="line">Table dropped.</span><br><span class="line"></span><br><span class="line">SQL&gt; create table t as select * from dba_objects where ROWNUM &lt;= 200;</span><br><span class="line"></span><br><span class="line">Table created.</span><br><span class="line"></span><br><span class="line">SQL&gt; create index t_object_id_index on t(object_id);</span><br><span class="line"></span><br><span class="line">Index created.</span><br><span class="line"></span><br><span class="line">SQL&gt; set linesize 1000</span><br><span class="line">SQL&gt; set autotrace traceonly</span><br><span class="line">SQL&gt; select * from t where object_id &lt;= 10;</span><br><span class="line"></span><br><span class="line">9 rows selected.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Execution Plan</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">Plan hash value: 632031452</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">| Id  | Operation                           | Name              | Rows  | Bytes | Cost (%CPU)| Time     |</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">|   0 | SELECT STATEMENT                    |                   |     9 |   963 |     2   (0)| 00:00:01 |</span><br><span class="line">|   1 |  TABLE ACCESS BY INDEX ROWID BATCHED| T                 |     9 |   963 |     2   (0)| 00:00:01 |</span><br><span class="line">|*  2 |   INDEX RANGE SCAN                  | T_OBJECT_ID_INDEX |     9 |       |     1   (0)| 00:00:01 |</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Predicate Information (identified by operation id):</span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">   2 - access(&quot;OBJECT_ID&quot;&lt;=10)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Statistics</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">       1316  recursive calls</span><br><span class="line">          0  db block gets</span><br><span class="line">       1620  consistent gets</span><br><span class="line">        135  physical reads</span><br><span class="line">          0  redo size</span><br><span class="line">       4319  bytes sent via SQL*Net to client</span><br><span class="line">        108  bytes received via SQL*Net from client</span><br><span class="line">          2  SQL*Net roundtrips to/from client</span><br><span class="line">         96  sorts (memory)</span><br><span class="line">          0  sorts (disk)</span><br><span class="line">          9  rows processed</span><br></pre></td></tr></table></figure>

<p>一般来说，根据索引来检索记录，会有一个先从索引中找到记录，再根据索引列上的 ROWID 定位到表中从而返回索引列以外的其他列的动作，这就是<code>TABLE ACCESS BY INDEX ROWID</code>。<br>下面观察如果消除 <code>TABLE ACCESS BY INDEX ROWID BATCHED</code> 的开销。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select object_id from t where object_id &lt;= 10;</span><br><span class="line"></span><br><span class="line">9 rows selected.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Execution Plan</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">Plan hash value: 3023054428</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">| Id  | Operation        | Name              | Rows  | Bytes | Cost (%CPU)| Time     |</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">|   0 | SELECT STATEMENT |                   |     9 |    36 |     1   (0)| 00:00:01 |</span><br><span class="line">|*  1 |  INDEX RANGE SCAN| T_OBJECT_ID_INDEX |     9 |    36 |     1   (0)| 00:00:01 |</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Predicate Information (identified by operation id):</span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">   1 - access(&quot;OBJECT_ID&quot;&lt;=10)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Statistics</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">       1262  recursive calls</span><br><span class="line">          0  db block gets</span><br><span class="line">       1484  consistent gets</span><br><span class="line">        151  physical reads</span><br><span class="line">          0  redo size</span><br><span class="line">        697  bytes sent via SQL*Net to client</span><br><span class="line">        108  bytes received via SQL*Net from client</span><br><span class="line">          2  SQL*Net roundtrips to/from client</span><br><span class="line">         96  sorts (memory)</span><br><span class="line">          0  sorts (disk)</span><br><span class="line">          9  rows processed</span><br></pre></td></tr></table></figure>

<p>这里没有 <code>TABLE ACCESS BY INDEX ROWID</code> 了。<br>因为语句从 <code>select * from t where object_id &lt;= 10;</code> 改写为 <code>select object_id from t where object_id &lt;= 10;</code> 了，不用从索引中回到表中获取索引列以外的其他列了。<br>性能上，逻辑读从1620变为1484，代价从2变为1。（每次执行前都清空了共享池和缓存）<br>避免回表从而使性能提升这是一个很简单的道理，少做事性能当然提升了。<br>只是 <code>select * from t</code> 和 <code>select object_id from t</code>毕竞不等价，有没有什么方法可以实现写法依然是 <code>select * from t</code> 但是还是可以不回表呢？<br><strong>普通表是做不到的，能实现这种功能的只有索引组织表。</strong></p>
<h4 id="有序插入却难以有序读出"><a href="#有序插入却难以有序读出" class="headerlink" title="有序插入却难以有序读出"></a>有序插入却难以有序读出</h4><p>在对普通表的操作中，我们无法保证在有序插入的前提下就能有序读出。<br>最简单的一个理由就是，如果把行记录插入块中，然后删除了该行，接下来插入的行会去填补块中的空余部分，这就无法保证有序了。<br>所以在查询数据时，如果想有序地展现，就必须使用order by，否则根本不能保证顺序展现，而order by操作是开销很大的操作。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select object_id from t;</span><br><span class="line"></span><br><span class="line">200 rows selected.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Execution Plan</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">Plan hash value: 1601196873</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">| Id  | Operation         | Name | Rows  | Bytes | Cost (%CPU)| Time     |</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">|   0 | SELECT STATEMENT  |      |   200 |   800 |     3   (0)| 00:00:01 |</span><br><span class="line">|   1 |  TABLE ACCESS FULL| T    |   200 |   800 |     3   (0)| 00:00:01 |</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Statistics</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">          1  recursive calls</span><br><span class="line">          0  db block gets</span><br><span class="line">         20  consistent gets</span><br><span class="line">          4  physical reads</span><br><span class="line">          0  redo size</span><br><span class="line">       4228  bytes sent via SQL*Net to client</span><br><span class="line">        433  bytes received via SQL*Net from client</span><br><span class="line">         15  SQL*Net roundtrips to/from client</span><br><span class="line">          0  sorts (memory)</span><br><span class="line">          0  sorts (disk)</span><br><span class="line">        200  rows processed</span><br><span class="line"></span><br><span class="line">SQL&gt; select object_id from t order by OBJECT_ID desc;</span><br><span class="line"></span><br><span class="line">200 rows selected.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Execution Plan</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">Plan hash value: 961378228</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">| Id  | Operation          | Name | Rows  | Bytes | Cost (%CPU)| Time     |</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">|   0 | SELECT STATEMENT   |      |   200 |   800 |     4  (25)| 00:00:01 |</span><br><span class="line">|   1 |  SORT ORDER BY     |      |   200 |   800 |     4  (25)| 00:00:01 |</span><br><span class="line">|   2 |   TABLE ACCESS FULL| T    |   200 |   800 |     3   (0)| 00:00:01 |</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Statistics</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">         50  recursive calls</span><br><span class="line">          6  db block gets</span><br><span class="line">         46  consistent gets</span><br><span class="line">          1  physical reads</span><br><span class="line">       1008  redo size</span><br><span class="line">       4228  bytes sent via SQL*Net to client</span><br><span class="line">        433  bytes received via SQL*Net from client</span><br><span class="line">         15  SQL*Net roundtrips to/from client</span><br><span class="line">          3  sorts (memory)</span><br><span class="line">          0  sorts (disk)</span><br><span class="line">        200  rows processed</span><br></pre></td></tr></table></figure>

<p>可以观察到，有排序的操作的统计信息模块有个 3 sorts(memory)，表示发生了排序，执行计划中也有<code>SORT ORDER BY</code>的关键字。<br>不过最重要的是，没排序的操作代价为3，有排序的操作代价为4，性能上是有差异的，在大数量时将会非常明显。<br>关于order by避免排序的方法有两种思路。第一种思路是在order by的排序列建索引，至于为什么，还是留着后续索引部分细说。第二种方法就是，将普通表改造为有序散列聚簇表，这样可以保证顺序插入，order by展现时无须再有排序动作。</p>
<h3 id="奇特的全局临时表"><a href="#奇特的全局临时表" class="headerlink" title="奇特的全局临时表"></a>奇特的全局临时表</h3><p>从数据安全性来看，对表记录的操作写日志是不可避免的，否则备份恢复就无从谈起了，只是现实中真的有一部分应用对表的某些操作是不需要恢复的，比如运算过程中临时处理的中间结果集，这时就可以考虑用全局临时表来实现。</p>
<h4 id="全局临时表的类型"><a href="#全局临时表的类型" class="headerlink" title="全局临时表的类型"></a>全局临时表的类型</h4><p>全局临时表分为两种类型，一种是<strong>基于会话的全局临时表(commit preserve rows)</strong>，一种是<strong>基于事务的全局临时表(on commit delete rows)</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 创建基于会话的全局临时表</span><br><span class="line">drop table t_tmp_session purge;</span><br><span class="line">create global temporary table T_TMP_session on commit preserve rows as select * from dba_objects where 1 = 2;</span><br><span class="line">select table_name, temporary, duration from user_tables where table_name = &#x27;T_TMP_SESSION&#x27;;</span><br><span class="line">-- 创建基于事务的全局临时表</span><br><span class="line">drop table t_tmp_transaction purge;</span><br><span class="line">create global temporary table t_tmp_transaction on commit delete rows as select * from dba_objects where 1 = 2;</span><br><span class="line">select table_name, temporary, DURATION from user_tables where table_name = &#x27;T_TMP_TRANSACTION&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="观察各类DML的REDO日志量"><a href="#观察各类DML的REDO日志量" class="headerlink" title="观察各类DML的REDO日志量"></a>观察各类DML的REDO日志量</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from v_redo_size;</span><br><span class="line"></span><br><span class="line">NAME                                                                  VALUE</span><br><span class="line">---------------------------------------------------------------- ----------</span><br><span class="line">redo size                                                             43504</span><br><span class="line"></span><br><span class="line">SQL&gt; insert into T_TMP_session select * from dba_objects;</span><br><span class="line"></span><br><span class="line">71208 rows created.</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from v_redo_size;</span><br><span class="line"></span><br><span class="line">NAME                                                                  VALUE</span><br><span class="line">---------------------------------------------------------------- ----------</span><br><span class="line">redo size                                                            605748</span><br><span class="line">-- 基于会话的全局临时表，插入数据时产生了 605748 - 43504 = 562244 ，约0.54MB</span><br><span class="line">SQL&gt; insert into t_tmp_transaction select * from dba_objects;</span><br><span class="line"></span><br><span class="line">71208 rows created.</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from v_redo_size;</span><br><span class="line"></span><br><span class="line">NAME                                                                  VALUE</span><br><span class="line">---------------------------------------------------------------- ----------</span><br><span class="line">redo size                                                           1167932</span><br><span class="line">-- 基于事务的全局临时表，插入数据时产生了 1167932 - 605748 = 562184 ，约0.54MB</span><br><span class="line">SQL&gt; update T_TMP_session set object_id = rownum;</span><br><span class="line"></span><br><span class="line">71208 rows updated.</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from v_redo_size;</span><br><span class="line"></span><br><span class="line">NAME                                                                  VALUE</span><br><span class="line">---------------------------------------------------------------- ----------</span><br><span class="line">redo size                                                           6850608</span><br><span class="line">-- 基于会话的全局临时表，更新数据时产生了 6850608 - 1167932 = 5682676 ，约5.42MB</span><br><span class="line">SQL&gt; update t_tmp_transaction set object_id = rownum;</span><br><span class="line"></span><br><span class="line">71208 rows updated.</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from v_redo_size;</span><br><span class="line"></span><br><span class="line">NAME                                                                  VALUE</span><br><span class="line">---------------------------------------------------------------- ----------</span><br><span class="line">redo size                                                          11516184</span><br><span class="line">-- 基于事务的全局临时表，更新数据时产生了 11516184 - 6850608 = 4665576 ，约4.45MB</span><br><span class="line">SQL&gt; delete from T_TMP_session;</span><br><span class="line"></span><br><span class="line">71208 rows deleted.</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from v_redo_size;</span><br><span class="line"></span><br><span class="line">NAME                                                                  VALUE</span><br><span class="line">---------------------------------------------------------------- ----------</span><br><span class="line">redo size                                                          23298188</span><br><span class="line">-- 基于会话的全局临时表，删除数据时产生了 23298188 - 11516184 = 11782004 ，约11.24MB</span><br><span class="line">SQL&gt; delete from t_tmp_transaction;</span><br><span class="line"></span><br><span class="line">71208 rows deleted.</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from v_redo_size;</span><br><span class="line"></span><br><span class="line">NAME                                                                  VALUE</span><br><span class="line">---------------------------------------------------------------- ----------</span><br><span class="line">redo size                                                          35080104</span><br><span class="line">-- 基于事务的全局临时表，删除数据时产生了 35080104 - 23298188 = 11781916 ，约11.24MB</span><br></pre></td></tr></table></figure>

<p><strong>可以发现全局临时表，无论插入，修改还是删除，都还是要写日志。</strong><br><strong>只是无论插入更新还是删除，操作普通表产生的日志都比全局临时表要多。</strong><br>具体比较就省略了，比较语句上基本没有差别。</p>
<h4 id="全局临时表两大特性"><a href="#全局临时表两大特性" class="headerlink" title="全局临时表两大特性"></a>全局临时表两大特性</h4><p>全局临时表最重要的特点有两个。</p>
<ol>
<li><strong>高效删除记录</strong>，基于事务的全局临时表COMMIT或者SESSION连接退出后，临时表记录自动删除；基于会话的全局临时表则是SESSION连接退出后，临时表记录自动删除，都无须手动去操作。</li>
<li><strong>针对不同会话数据独立</strong>，不同的SESSION访问全局临时表，看到的结果不同。</li>
</ol>
<h5 id="高效删除记录"><a href="#高效删除记录" class="headerlink" title="高效删除记录"></a>高效删除记录</h5><p><strong>基于事务的全局临时表COMMIT后，记录会被删除。</strong><br>另外，用C0MMT方式删除全局临时表记录所产生的日志量才很小，比起直接用delete方式操作产生的日志量，几乎可以忽略不计了。<br>这点日志其实还是是COMMIT动作本身产生的，所以基本可以理解为全局临时表的COMMIT或者退出SESSION的方式不会产生日志。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; insert into t_tmp_transaction select * from dba_objects;</span><br><span class="line"></span><br><span class="line">71208 rows created.</span><br><span class="line"></span><br><span class="line">SQL&gt; select count(1) from t_tmp_transaction;</span><br><span class="line"></span><br><span class="line">  COUNT(1)</span><br><span class="line">----------</span><br><span class="line">     71208</span><br><span class="line"></span><br><span class="line">SQL&gt; commit;</span><br><span class="line"></span><br><span class="line">Commit complete.</span><br><span class="line"></span><br><span class="line">SQL&gt; select count(1) from t_tmp_transaction;</span><br><span class="line"></span><br><span class="line">  COUNT(1)</span><br><span class="line">----------</span><br><span class="line">         0</span><br></pre></td></tr></table></figure>

<p><strong>基于会话的全局临时表SESSION退出后，记录会被删除。</strong></p>
<p>一般来说，基于SESSION的全局临时表的应用会更多一些，少数比较复杂的应用，涉及一次调用中需要记录清空再插入等复杂动作时，才考虑用基于事务的全局临时表。</p>
<h5 id="不同会话独立"><a href="#不同会话独立" class="headerlink" title="不同会话独立"></a>不同会话独立</h5><p>即每个session会话中查询到的全局临时表数据是相互独立的，相互隔离、互不干扰。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查询当前会话信息</span><br><span class="line">select * from v$mystat where ROWNUM = 1;</span><br></pre></td></tr></table></figure>

<h3 id="神通广大的分区表"><a href="#神通广大的分区表" class="headerlink" title="神通广大的分区表"></a>神通广大的分区表</h3><p>在如今数据量日益增长的海量数据库时代，分区表技术显得尤为重要，甚至可以说使用得当与否将决定到系统的生死。<br>关于普通堆表的不足，其中表记录太大检索慢和delete删除有瑕疵这两个缺点正好可以被分区表的分区消除和可以高效清理分区数据这两大特点给弥补了。</p>
<p>什么叫分区消除，最通俗的比喻就是，对某表按月份建了范围分区，从1月到12月共12个分区，你查询当前12月的记录，就不会去访问另外11个区，少做事了，这就是分区消除。<br>高效分区清理呢，就是如果要删除某分区的数据，如果直接delete，速度很慢，而且高水平位也不会释放，查询的块依然很多，这时可以直接truncate这个分区，速度非常快。</p>
<p><strong>在这个Google的时代，语法和知识点都不是问题，搜不到的是体系，是重点，是思想。</strong><br>上面是书中的原话，这里还想说的就是。时代在进步，如今AI的时代，获取知识更加容易。但无论什么时代，都要善于利用工具。</p>
<h4 id="分区表类型及原理"><a href="#分区表类型及原理" class="headerlink" title="分区表类型及原理"></a>分区表类型及原理</h4><p>首先探讨的是分区表的类型及原理。分区表的类型有范围分区、列表分区、HA$H分区及组合分区4种。<br>其中范围分区应用最为广泛，需要重点学习和掌握，而列表分区次之，在某些场合下也可以考虑使用组合分区，相对而言HASH分区在应用中适用的场景并不广泛，使用的频率比较低。</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/momoyan/p/9164411.html" >oracle分区表的使用和查询<i class="fas fa-external-link-alt"></i></a></p>
<h5 id="范围分区"><a href="#范围分区" class="headerlink" title="范围分区"></a>范围分区</h5><p>范围分区最常见的是按时间列进行分区。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">-- 创建范围分区表</span><br><span class="line">create table range_part_tab</span><br><span class="line">(</span><br><span class="line">    id        number,</span><br><span class="line">    deal_date date,</span><br><span class="line">    area_code number,</span><br><span class="line">    contents  varchar2(4000)</span><br><span class="line">)</span><br><span class="line">    partition by range (deal_date)</span><br><span class="line">(</span><br><span class="line">    partition p1 values less than (TO_DATE(&#x27;2024-02-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">    partition p2 values less than (TO_DATE(&#x27;2024-03-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">    partition p3 values less than (TO_DATE(&#x27;2024-04-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">    partition p4 values less than (TO_DATE(&#x27;2024-05-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">    partition p5 values less than (TO_DATE(&#x27;2024-06-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">    partition p6 values less than (TO_DATE(&#x27;2024-07-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">    partition p7 values less than (TO_DATE(&#x27;2024-08-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">    partition p8 values less than (TO_DATE(&#x27;2024-09-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">    partition p9 values less than (TO_DATE(&#x27;2024-10-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">    partition p10 values less than (TO_DATE(&#x27;2024-11-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">    partition p11 values less than (TO_DATE(&#x27;2024-12-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">    partition p12 values less than (TO_DATE(&#x27;2025-01-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">    partition p_max values less than (maxvalue)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">-- 插入一整年随机日期和591-599之间的随机数。共100000条数据</span><br><span class="line">insert into range_part_tab(id, deal_date, area_code, contents)</span><br><span class="line">select rownum,</span><br><span class="line">       to_date(to_char(sysdate - 365, &#x27;J&#x27;) + TRUNC(DBMS_RANDOM.VALUE(0, 365)), &#x27;J&#x27;),</span><br><span class="line">       ceil(dbms_random.value(590, 599)),</span><br><span class="line">       rpad(&#x27;*&#x27;, 400, &#x27;*&#x27;)</span><br><span class="line">from dual</span><br><span class="line">connect by rownum &lt;= 100000;</span><br></pre></td></tr></table></figure>

<ol>
<li>范围分区的关键字为 <code>partition by range</code> ，即这三个关键字表示该分区为范围分区。后面为范围的字段。</li>
<li><code>values less than</code> 是范围分区特定的语法，用于指明具体的范围，比如<code>partition p3 values less than (TO_DATE(&#39;2024-04-01&#39;, &#39;YYYY-MM-DD&#39;))</code>，表示小于3月份的记录。partition p1到partition pmax 表示总共建立了13个分区。最后还要注意<code>partition p_max values less than (maxvalue)</code>的部分，表示超出这些范围的记录全部落在这个分区中，包括空值，免得出错。</li>
<li>分区表的分区可分别指定在不同的表空间里，如果不写即为都在同一默认表空间里。如果将每个分区保存到单独的表空间中，这样数据文件就可以跨越多个物理磁盘。</li>
</ol>
<h5 id="列表分区"><a href="#列表分区" class="headerlink" title="列表分区"></a>列表分区</h5><p>列表分区的特点是某列的值只有几个，基于这样的特点我们可以采用列表分区。创建一个按字段数据列表固定可枚举值分区的表。插入记录分区字段的值必须在列表中，否则不能被插入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-- 创建列表分区表</span><br><span class="line">create table list_part_tab</span><br><span class="line">(</span><br><span class="line">    id        number,</span><br><span class="line">    deal_date date,</span><br><span class="line">    area_code number,</span><br><span class="line">    contents  varchar2(4000)</span><br><span class="line">)</span><br><span class="line">    partition by list (area_code)</span><br><span class="line">(</span><br><span class="line">    partition p_591 values (591),</span><br><span class="line">    partition p_592 values (592),</span><br><span class="line">    partition p_593 values (593),</span><br><span class="line">    partition p_594 values (594),</span><br><span class="line">    partition p_595 values (595),</span><br><span class="line">    partition p_596 values (596),</span><br><span class="line">    partition p_597 values (597),</span><br><span class="line">    partition p_598 values (598),</span><br><span class="line">    partition p_599 values (599),</span><br><span class="line">    partition p_other values (DEFAULT)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ol>
<li>列表分区的关键字为<code>partition by list</code>，即这三个关键字表示该分区为列表分区。</li>
<li>不同于之前范围分区的<code>values less than</code>，列表分区仅需values即可确定范围，值得注意的是，<code>partition p592 values(592)</code>并不是说明取值只能写一个，也可写为多个，比如<code>partition p_union values (592,593,594)</code>。</li>
<li>partition p_591到partition p_other表示总共建立了10个分区。</li>
<li><code>partition p_other values(default)</code>，表示不在刚才591到S99范围的记录全部落在这个默认分区中，包括空值，避免应用出错。</li>
<li>分区表的分区可分别指定在不同的表空间里，如果不写即为都在同一默认表空间里。</li>
</ol>
<h5 id="散列分区（Hash分区）"><a href="#散列分区（Hash分区）" class="headerlink" title="散列分区（Hash分区）"></a>散列分区（Hash分区）</h5><p>hash分区最主要的机制是根据hash算法来计算具体某条纪录应该插入到哪个分区中，hash算法中最重要的是hash函数，Oracle中如果你要使用hash分区，只需指定分区的数量即可。<br>建议分区的数量采用2的n次方，这样可以使得各个分区间数据分布更加均匀。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 创建hash分区表</span><br><span class="line">create table hash_part_tab</span><br><span class="line">(</span><br><span class="line">    id        number,</span><br><span class="line">    deal_date date,</span><br><span class="line">    area_code number,</span><br><span class="line">    contents  varchar2(4000)</span><br><span class="line">)</span><br><span class="line">    partition by hash (deal_date)</span><br><span class="line">    PARTITIONS 16;</span><br></pre></td></tr></table></figure>

<ol>
<li>散列分区的关键字为<code>partition by hash</code>，出现这三个关键字即表示当前分区为散列分区。</li>
<li>散列分区与之前两种分区的明显差别在于：没有指定分区名，而仅仅是指定了分区个数，如<code>PARTITIONS 16</code>。</li>
<li>散列分区的分区数量采用2的n次方，这样可以使得各个分区间数据分布更加均匀。</li>
<li>可以指定散列分区的分区表空间，比如增加如下一小段，<code>STORE IN(ts1,ts2,ts3,ts4,ts5,ts6,ts7,ts8,ts9,ts10,ts11,ts12,ts13,ts14,ts15,ts16)</code>表示分别存在在12个不同的表空间里，当然不写出表空间就是都在同一默认表空间里。</li>
</ol>
<h5 id="组合分区"><a href="#组合分区" class="headerlink" title="组合分区"></a>组合分区</h5><p>组合分区结合了两种或多种不同的分区方法，如范围分区（Range Partitioning）、列表分区（List Partitioning）和散列分区（Hash Partitioning）。<br>通过组合使用这些方法，可以实现更高效的查询性能和更好的数据管理。</p>
<p>基于范围分区和列表分区，表首先按某列进行范围分区，然后再按某列进行列表分区，分区之中的分区被称为子分区。<br>基于范围分区和散列分区，表首先按某列进行范围分区，然后再按某列进行散列分区。<br>以此类推，其实就是分区中的分区。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">-- 创建基于范围和列表的组合分区表</span><br><span class="line">CREATE TABLE range_list_part_tab</span><br><span class="line">(</span><br><span class="line">    id        number,</span><br><span class="line">    deal_date date,</span><br><span class="line">    area_code number,</span><br><span class="line">    contents  varchar2(4000)</span><br><span class="line">)</span><br><span class="line">    partition by range (deal_date) -- 第一级分区：按年份范围分区</span><br><span class="line">    SUBPARTITION by list (area_code) -- 第二级分区：按地区编号列表分区</span><br><span class="line">(</span><br><span class="line">    PARTITION rlp1 VALUES LESS THAN (TO_DATE(&#x27;2024-06-01&#x27;, &#x27;YYYY-MM-DD&#x27;))</span><br><span class="line">        (</span><br><span class="line">        subpartition rlp1_595 values (595),</span><br><span class="line">        subpartition rlp1_other values (DEFAULT)</span><br><span class="line">        ),</span><br><span class="line">    partition rlp2 values less than (maxvalue)</span><br><span class="line">        (</span><br><span class="line">        subpartition rlp2_595 values (595),</span><br><span class="line">        subpartition rlp2_other values (DEFAULT)</span><br><span class="line">        )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">-- 简化</span><br><span class="line"></span><br><span class="line">CREATE TABLE range_list_part_tab</span><br><span class="line">(</span><br><span class="line">  id        number,</span><br><span class="line">  deal_date date,</span><br><span class="line">  area_code number,</span><br><span class="line">  contents  varchar2(4000)</span><br><span class="line">)</span><br><span class="line">  partition by range (deal_date) -- 第一级分区：按年份范围分区</span><br><span class="line">  SUBPARTITION by list (area_code) -- 第二级分区：按地区编号列表分区</span><br><span class="line">  subpartition template</span><br><span class="line">(</span><br><span class="line">  subpartition p_591 values (591),</span><br><span class="line">  subpartition p_592 values (592),</span><br><span class="line">  subpartition p_593 values (593),</span><br><span class="line">  subpartition p_594 values (594),</span><br><span class="line">  subpartition p_595 values (595),</span><br><span class="line">  subpartition p_596 values (596),</span><br><span class="line">  subpartition p_597 values (597),</span><br><span class="line">  subpartition p_598 values (598),</span><br><span class="line">  subpartition p_599 values (599),</span><br><span class="line">  subpartition p_other values (DEFAULT)</span><br><span class="line">)(</span><br><span class="line">  partition p1 values less than (TO_DATE(&#x27;2024-02-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">  partition p2 values less than (TO_DATE(&#x27;2024-03-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">  partition p3 values less than (TO_DATE(&#x27;2024-04-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">  partition p4 values less than (TO_DATE(&#x27;2024-05-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">  partition p5 values less than (TO_DATE(&#x27;2024-06-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">  partition p6 values less than (TO_DATE(&#x27;2024-07-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">  partition p7 values less than (TO_DATE(&#x27;2024-08-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">  partition p8 values less than (TO_DATE(&#x27;2024-09-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">  partition p9 values less than (TO_DATE(&#x27;2024-10-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">  partition p10 values less than (TO_DATE(&#x27;2024-11-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">  partition p11 values less than (TO_DATE(&#x27;2024-12-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">  partition p12 values less than (TO_DATE(&#x27;2025-01-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">  partition p_max values less than (maxvalue)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ol>
<li>组合分区是由主分区和从分区组成的，比如范围列表分区，就表示主分区是范围分区，而从分区是列表分区，从分区的关键字为<code>subpartition</code>,比如本例中的<code>subpartition by list (area_code)</code>。</li>
<li>为了避免在每个主分区中都写相同的从分区，可以考虑用模版方式，比如简化中的<code>subpartition TEMPLATE</code>关键字。</li>
<li>只要涉及子分区模块，都需要有<code>subpartition</code>关键字。</li>
<li>关于表空间和之前的没有差别，依然是可以指定，也可以不指定。</li>
</ol>
<h5 id="分区原理"><a href="#分区原理" class="headerlink" title="分区原理"></a>分区原理</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 创建普通表作为对照</span><br><span class="line">create table norm_tab(id number,deal_date date,area_code number,contents varchar2(4000));</span><br><span class="line">insert into norm_tab(id, deal_date, area_code, contents)</span><br><span class="line">select rownum,</span><br><span class="line">       to_date(to_char(sysdate - 365, &#x27;J&#x27;) + TRUNC(DBMS_RANDOM.VALUE(0, 365)), &#x27;J&#x27;),</span><br><span class="line">       ceil(dbms_random.value(590, 599)),</span><br><span class="line">       rpad(&#x27;*&#x27;, 400, &#x27;*&#x27;)</span><br><span class="line">from dual</span><br><span class="line">connect by rownum &lt; 100000;</span><br></pre></td></tr></table></figure>

<p>比较普通表与分区表在段分配上的差异</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; set linesize 1000</span><br><span class="line">SQL&gt; set pagesize 5000</span><br><span class="line">SQL&gt; column segment_name format a20</span><br><span class="line">SQL&gt; column partition_name format a20</span><br><span class="line">SQL&gt; column segment_type format a20</span><br><span class="line">SQL&gt; select segment_name,partition_name,segment_type,bytes/1024/1024,tablespace_name from user_segments where segment_name IN(&#x27;RANGE_PART_TAB&#x27;,&#x27;NORM_TAB&#x27;);</span><br><span class="line"></span><br><span class="line">SEGMENT_NAME         PARTITION_NAME       SEGMENT_TYPE         BYTES/1024/1024 TABLESPACE_NAME</span><br><span class="line">-------------------- -------------------- -------------------- --------------- ------------------------------</span><br><span class="line">RANGE_PART_TAB       P1                   TABLE PARTITION                   23 SYSTEM</span><br><span class="line">RANGE_PART_TAB       P4                   TABLE PARTITION                    4 SYSTEM</span><br><span class="line">RANGE_PART_TAB       P3                   TABLE PARTITION                    4 SYSTEM</span><br><span class="line">RANGE_PART_TAB       P7                   TABLE PARTITION                    4 SYSTEM</span><br><span class="line">RANGE_PART_TAB       P6                   TABLE PARTITION                    4 SYSTEM</span><br><span class="line">RANGE_PART_TAB       P2                   TABLE PARTITION                    4 SYSTEM</span><br><span class="line">RANGE_PART_TAB       P5                   TABLE PARTITION                    4 SYSTEM</span><br><span class="line">RANGE_PART_TAB       P8                   TABLE PARTITION                .1875 SYSTEM</span><br><span class="line">NORM_TAB                                  TABLE                             46 SYSTEM</span><br><span class="line"></span><br><span class="line">9 rows selected.</span><br></pre></td></tr></table></figure>

<p>分区表会产生多个SEGMENT，而且是建了几个分区就有几个SEGMENT，而普通表仅有一个SEGMENT。<br>分区表一个很简单的思想：化整为零，将大对象切割成多个小对象，从而使得在指定的小对象中定位到数据成为一种可能，最终达到减少访问路径，尽量少做事就能解决问题的目的。</p>
<p>HASH分区表无法让指定的数据到指定的分区去，这对快速检索数据并不是很有利，因此HASH分区在实际的工作中应用得相对较少一些。<br>不过任何事情存在即合理，HASH分区会用在什么场合呢？<br>其实HASH分区最大的好处在于，将数据根据一定HASH算法，均匀分布到不同的分区中去，避免查询数据时集中在某一个地方，从而避免热点块的竞争，改善IO。<br>此外，HASH可以精确匹配，无法范围扫描。<br>现实中我们可以针对某些本身就无法有效执行分区范围的列进行HASH分区，比如ID列之类的，在出现热点块竞争严重时，可考虑如此设计。</p>
<p>组合分区的分区数量比起非组合分区会多很多。比如上面创建的<code>range_list_part_tab</code>表，有130个分区。<br>组合分区存在的意义，就是化整为零思想的升级版，将一个大对象切割得更细更小了。这对于一个超级大表来说，也是有一定的意义的。<br>不过分区表也是有额外开销的，如果分区数量过多，Oracle就需要管理过多的段，在操作分区表时也容易引发Oracle内部大量的递归调用，此外本身的语法也有一定的复杂度。所以一般来说，只有大表才建议建分区，记录数在100万以下的表，基本上不建议建分区。</p>
<h4 id="分区表最实用的特性"><a href="#分区表最实用的特性" class="headerlink" title="分区表最实用的特性"></a>分区表最实用的特性</h4><h5 id="高效的分区清除"><a href="#高效的分区清除" class="headerlink" title="高效的分区清除"></a>高效的分区清除</h5><p>分区表存在最大的意义就在于，可以有效地做到分区消除，比如你对地区号做了分区，查询福州就只会在福州的分区中查找数据，而不会到厦门、漳州、泉州等其他分区中查找，这就是分区消除，消除了福州以外的所有其他分区。<br>原理很简单，就是因为分区表其实是将一个大对象分成了多个小对象，通过分区的规则，可以确定数据在哪个或哪几个小对象中，从而减少访问路径。</p>
<p>比较相同语句，普通表无法用到 DEAL_DATE 条件进行分区消除的情况。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from range_part_tab where deal_date &gt;= TO_DATE(&#x27;2024-02-04&#x27;, &#x27;YYYY-MM-DD&#x27;) and deal_date &lt; TO_DATE(&#x27;2024-02-07&#x27;, &#x27;YYYY-MM-DD&#x27;);</span><br><span class="line"></span><br><span class="line">853 rows selected.</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:00.16</span><br><span class="line"></span><br><span class="line">Execution Plan</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">Plan hash value: 16125146</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">| Id  | Operation              | Name           | Rows  | Bytes | Cost (%CPU)| Time     | Pstart| Pstop |</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">|   0 | SELECT STATEMENT       |                |   832 |  1655K|   129   (0)| 00:00:01 |       |       |</span><br><span class="line">|   1 |  PARTITION RANGE SINGLE|                |   832 |  1655K|   129   (0)| 00:00:01 |     2 |     2 |</span><br><span class="line">|*  2 |   TABLE ACCESS FULL    | RANGE_PART_TAB |   832 |  1655K|   129   (0)| 00:00:01 |     2 |     2 |</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Predicate Information (identified by operation id):</span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">   2 - filter(&quot;DEAL_DATE&quot;&gt;=TO_DATE(&#x27; 2024-02-04 00:00:00&#x27;, &#x27;syyyy-mm-dd hh24:mi:ss&#x27;) AND</span><br><span class="line">              &quot;DEAL_DATE&quot;&lt;TO_DATE(&#x27; 2024-02-07 00:00:00&#x27;, &#x27;syyyy-mm-dd hh24:mi:ss&#x27;))</span><br><span class="line"></span><br><span class="line">Note</span><br><span class="line">-----</span><br><span class="line">   - dynamic statistics used: dynamic sampling (level=2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Statistics</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">         50  recursive calls</span><br><span class="line">          3  db block gets</span><br><span class="line">        652  consistent gets</span><br><span class="line">          0  physical reads</span><br><span class="line">        620  redo size</span><br><span class="line">      29086  bytes sent via SQL*Net to client</span><br><span class="line">       1508  bytes received via SQL*Net from client</span><br><span class="line">         58  SQL*Net roundtrips to/from client</span><br><span class="line">          2  sorts (memory)</span><br><span class="line">          0  sorts (disk)</span><br><span class="line">        853  rows processed</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from norm_tab where deal_date &gt;= TO_DATE(&#x27;2024-02-04&#x27;, &#x27;YYYY-MM-DD&#x27;) and deal_date &lt; TO_DATE(&#x27;2024-02-07&#x27;, &#x27;YYYY-MM-DD&#x27;);</span><br><span class="line"></span><br><span class="line">800 rows selected.</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:00.21</span><br><span class="line"></span><br><span class="line">Execution Plan</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">Plan hash value: 278673677</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">| Id  | Operation         | Name     | Rows  | Bytes | Cost (%CPU)| Time     |</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">|   0 | SELECT STATEMENT  |          |  1494 |  2971K|  1596   (1)| 00:00:01 |</span><br><span class="line">|*  1 |  TABLE ACCESS FULL| NORM_TAB |  1494 |  2971K|  1596   (1)| 00:00:01 |</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Predicate Information (identified by operation id):</span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">   1 - filter(&quot;DEAL_DATE&quot;&gt;=TO_DATE(&#x27; 2024-02-04 00:00:00&#x27;, &#x27;syyyy-mm-dd</span><br><span class="line">              hh24:mi:ss&#x27;) AND &quot;DEAL_DATE&quot;&lt;TO_DATE(&#x27; 2024-02-07 00:00:00&#x27;,</span><br><span class="line">              &#x27;syyyy-mm-dd hh24:mi:ss&#x27;))</span><br><span class="line"></span><br><span class="line">Note</span><br><span class="line">-----</span><br><span class="line">   - dynamic statistics used: dynamic sampling (level=2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Statistics</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">         24  recursive calls</span><br><span class="line">         27  db block gets</span><br><span class="line">       6019  consistent gets</span><br><span class="line">          0  physical reads</span><br><span class="line">       4456  redo size</span><br><span class="line">      27437  bytes sent via SQL*Net to client</span><br><span class="line">       1433  bytes received via SQL*Net from client</span><br><span class="line">         55  SQL*Net roundtrips to/from client</span><br><span class="line">          0  sorts (memory)</span><br><span class="line">          0  sorts (disk)</span><br><span class="line">        800  rows processed</span><br></pre></td></tr></table></figure>

<p>同样的语句，相似记录的表，分区表的代价仅为129，逻辑读只有652，而普通表代价为1596，逻辑读为6019。<br>差别如此之大，和分区表查询只遍历了13个分区中的一个有关。在分区表查询的执行计划中看到p_start和p_stop都标记上2，表示只遍历了第2个分区。这样避开了对其余12个分区的查询。</p>
<p>下面来看组合分区相同语句的执行计划。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from range_list_part_tab where deal_date &gt;= TO_DATE(&#x27;2024-02-04&#x27;, &#x27;YYYY-MM-DD&#x27;) and deal_date &lt; TO_DATE(&#x27;2024-02-07&#x27;, &#x27;YYYY-MM-DD&#x27;);</span><br><span class="line"></span><br><span class="line">864 rows selected.</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:00.30</span><br><span class="line"></span><br><span class="line">Execution Plan</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">Plan hash value: 3813662781</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line">| Id  | Operation              | Name                | Rows  | Bytes | Cost (%CPU)| Time     | Pstart| Pstop |</span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line">|   0 | SELECT STATEMENT       |                     |   692 |  1376K|   135   (2)| 00:00:01 |       |       |</span><br><span class="line">|   1 |  PARTITION RANGE SINGLE|                     |   692 |  1376K|   135   (2)| 00:00:01 |     2 |     2 |</span><br><span class="line">|   2 |   PARTITION LIST ALL   |                     |   692 |  1376K|   135   (2)| 00:00:01 |     1 |    10 |</span><br><span class="line">|*  3 |    TABLE ACCESS FULL   | RANGE_LIST_PART_TAB |   692 |  1376K|   135   (2)| 00:00:01 |    11 |    20 |</span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Predicate Information (identified by operation id):</span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">   3 - filter(&quot;DEAL_DATE&quot;&gt;=TO_DATE(&#x27; 2024-02-04 00:00:00&#x27;, &#x27;syyyy-mm-dd hh24:mi:ss&#x27;) AND</span><br><span class="line">              &quot;DEAL_DATE&quot;&lt;TO_DATE(&#x27; 2024-02-07 00:00:00&#x27;, &#x27;syyyy-mm-dd hh24:mi:ss&#x27;))</span><br><span class="line"></span><br><span class="line">Note</span><br><span class="line">-----</span><br><span class="line">   - dynamic statistics used: dynamic sampling (level=2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Statistics</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">         10  recursive calls</span><br><span class="line">          3  db block gets</span><br><span class="line">        803  consistent gets</span><br><span class="line">          0  physical reads</span><br><span class="line">        620  redo size</span><br><span class="line">      26324  bytes sent via SQL*Net to client</span><br><span class="line">       1533  bytes received via SQL*Net from client</span><br><span class="line">         59  SQL*Net roundtrips to/from client</span><br><span class="line">          0  sorts (memory)</span><br><span class="line">          0  sorts (disk)</span><br><span class="line">        864  rows processed</span><br></pre></td></tr></table></figure>

<p>组合分区的代价为135，比范围分区稍高。按理说组合分区的粒度更细，代价应该更低才对，为什么呢？<br>是因为分区数过多，调用有开销。但由于这里表总记录不过10万，全表扫描开销都不是太大，这时Oracle内部调用的开销影响就相对较大。<br>如果表是一张超级大表，比如有上亿，那这些开销相比而言就可以忽略不计了。<br>所以分区表应用在大表会更合适。</p>
<h5 id="强大的分区操作"><a href="#强大的分区操作" class="headerlink" title="强大的分区操作"></a>强大的分区操作</h5><h6 id="分区-truncate"><a href="#分区-truncate" class="headerlink" title="分区 truncate"></a>分区 truncate</h6><p>delete无法释放空间，而truncate却有效地释放了空间。但可惜的是，针对普通表而言，truncate往往不能轻易使用，因为delete往往是针对某些条件的局部记录删除，而truncate显然不能带上条件，无法做到局部删除。<br>这时分区表就发挥作用了，Oracle可以实现只truncate某个分区，这就等同于实现了局部删除。</p>
<p><code>alter table range_part_tab truncate partition p9;</code> 删除分区表range_part_tab的p9分区</p>
<h6 id="分区数据转移"><a href="#分区数据转移" class="headerlink" title="分区数据转移"></a>分区数据转移</h6><p>关于分区表的历史记录的处理，其实是可以分成删除和转移两部分的，关于转移备份的方案，Oracle提供了一个非常棒的工具，就是分区交换，可以实现普通表和分区表的某个分区之间数据的相互交换，他们之间的交换非常快，基本上在瞬间就可以完成。<br><strong>实际上只是Oracle在内部数据字典做的一些小改动而已。</strong></p>
<p>命令：<code>alter table range_part_tab exchange partition p8 with table mid_table;</code> 不过要注意的一点是，这两张表的字段必须是完全一样的。<br>另外，exchange 是交换的含义，两个表的记录会互换，而不是覆盖。</p>
<h6 id="分区切割"><a href="#分区切割" class="headerlink" title="分区切割"></a>分区切割</h6><p><code>alter table range_part_tab split partition p_max at (TO_DATE(&#39;2024-02-01&#39;,&#39;YYYY-MM-DD&#39;)) into (PARTITION p2024_01,PARTITION P_MAX);</code></p>
<ol>
<li>分区切割的三个关键字是split、at&#x2F;values和into。</li>
<li>如果是RANGE类型的，at部分在此处说明了具体的范围，小于某个指定的值。如果是LIST类型的，使用values。</li>
<li>into 部分说明分区被切割成两个分区，比如 <code>into (PARTITION p2024_01,PARTITION P_MAX);</code> 表示将 P_MAX 切割成 PARTITION p2024_01 和 PARTITION P_MAX 两部分，其中括号里的 P_MAX 可以改为新的名字，也可以保留原来的名字。</li>
<li><strong>不能对HASH类型的分区进行拆分。</strong></li>
</ol>
<h6 id="分区合并"><a href="#分区合并" class="headerlink" title="分区合并"></a>分区合并</h6><p><code>alter table range_part_tab merge partitions p2024_02,p_max into partition p_max;</code></p>
<ol>
<li>分区合并的关键字是 merge 和 into。</li>
<li>merge 后面跟着的是需要合并的两个分区名。</li>
<li>into 部分为合并后的分区名，可以是新的分区名，也可以沿用已存在的分区名。</li>
<li>合并分区是将相邻的分区合并成一个分区，结果分区将采用较高分区的界限，值得注意的是，不能将分区合并到界限较低的分区。</li>
</ol>
<h6 id="分区的增与删"><a href="#分区的增与删" class="headerlink" title="分区的增与删"></a>分区的增与删</h6><p><code>alter table range_part_tab add partition p2025_01 values less than (TO_DATE(&#39;2025-02-01&#39;,&#39;YYYY-MM-DD&#39;));</code></p>
<p>上述语句可以增加分区，不过执行会报错：<code>ORA-14074: Partition Bound Must Collate Higher Than That Of The Last Partition</code><br>这是因为最后一个分区是<code>less than(maxvalue)</code>的情况下，是不能追加分区的，只能SPLIT分裂。<br>因为追加的分区界限比这个p_max还要低，显然不能允许。不过可以改成先试验分区删除，把这个p_max给删除了，然后追加自然就没问题了。</p>
<p><code>alter table range_part_tab drop partition p_max;</code></p>
<ol>
<li>分区增加的关键字是add partition，而分区别除的关键字是drop partition。</li>
<li>由于 max value 分区的存在，无法追加新的分区，必须删除了才可以追加。</li>
</ol>
<h4 id="分区索引类型"><a href="#分区索引类型" class="headerlink" title="分区索引类型"></a>分区索引类型</h4><h5 id="全局索引"><a href="#全局索引" class="headerlink" title="全局索引"></a>全局索引</h5><p>全局索引和普通的建索引无异，基本上可以理解为就是普通索引。</p>
<p><code>create index idx_part_tab_date on range_part_tab(deal_date);</code></p>
<h5 id="局部索引"><a href="#局部索引" class="headerlink" title="局部索引"></a>局部索引</h5><p>局部索引其实就是针对各个分区所建的索引。和局部索引相比，全局索引好比一个大索引，而局部索引好比13个小索引。</p>
<p><code>create index idx_part_tab_area on range_part_tab(area_code) local;</code></p>
<h4 id="分区表相关陷阱"><a href="#分区表相关陷阱" class="headerlink" title="分区表相关陷阱"></a>分区表相关陷阱</h4><h5 id="索引频频失效"><a href="#索引频频失效" class="headerlink" title="索引频频失效"></a>索引频频失效</h5><p>其中最容易出问题的当属分区表的不当操作导致分区索引失效，这些操作就是前面分区操作，这些动作全部都会导致分区索引中的全局索引失效。<br>以下是查看range_part_tab表的索引情况，其中STATUS是N&#x2F;A表示是局部索引，需要进一<br>步在user_ind partitions中分析其索引的状态，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 查看索引情况，其中STATUS是N/A表示是局部索引，需要进一步在user_ind_partitions中分析其索引的状态</span><br><span class="line">select index_name, status</span><br><span class="line">from user_indexes</span><br><span class="line">where index_name in (&#x27;IDX_PART_TAB_DATE&#x27;, &#x27;IDX_PART_TAB_AREA&#x27;);</span><br><span class="line">-- 查看局部索引状态</span><br><span class="line">select index_name, partition_name, status</span><br><span class="line">from user_ind_partitions</span><br><span class="line">where index_name = &#x27;IDX_PART_TAB AREA&#x27;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>status USABLE 表示索引可用，UNUSABLE 表示索引不可用</p>
</blockquote>
<p>其实分区表的分区操作，对局部索引一般都没有影响，但是对全局索引影响比较大。Oracle 在提供这些分区操作时提供了一个很有用的参数 <code>update global indexes</code>,可以有效地避免全局索引失效。<br>其实这个参数的本质动作是在分区操作做完后，暗暗执行了索引重建的工作。使用方式：<code>alter table range_part_tab truncate partition p2 update global indexes;</code></p>
<h5 id="有索引反而效率更低"><a href="#有索引反而效率更低" class="headerlink" title="有索引反而效率更低"></a>有索引反而效率更低</h5><p>有时加上索引，分区表的查询效率反而不如普通表。<br>这个问题涉及索引的特性，<strong>就是索引的高度一般比较低。</strong><br>下一章索引里细说，下一章有整整136页。索引真是数据库一大知识点啊</p>
<h5 id="无法应用分区条件"><a href="#无法应用分区条件" class="headerlink" title="无法应用分区条件"></a>无法应用分区条件</h5><p>在分区设计时，往往没有预先规划好如何应用分区，这是很不应该的。<br>操作分区表时，应该用上分区条件，否则无法做到分区消除，这就浪费了分区表的宝贵特性，应该避免出现。<br><strong>有无分区条件性能差别很大。</strong></p>
<h3 id="有趣的索引组织表"><a href="#有趣的索引组织表" class="headerlink" title="有趣的索引组织表"></a>有趣的索引组织表</h3><p>普通堆表操作时，如果有用到索引，需要先从索引中获取rowid,然后定位到表中，获取id以外的其他列，这就是回表。<br>如果查询列含索引列以外的列，回表就不可避免。</p>
<p>分别建普通表和索引组织表并插入部分数据，其中的<code>organization index</code>关键字就是索引组织表的语法，<strong>索引组织表必须有主键</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">drop table heap_addresses purge;</span><br><span class="line">drop table iot_addresses purge;</span><br><span class="line">create table heap_addresses</span><br><span class="line">(</span><br><span class="line">    empno     number(10),</span><br><span class="line">    addr_type varchar2(10),</span><br><span class="line">    street    varchar2(10),</span><br><span class="line">    city      varchar2(10),</span><br><span class="line">    state     varchar2(2),</span><br><span class="line">    zip       number,</span><br><span class="line">    primary key (empno)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">create table iot_addresses</span><br><span class="line">(</span><br><span class="line">    empno     number(10),</span><br><span class="line">    addr_type varchar2(10),</span><br><span class="line">    street    varchar2(10),</span><br><span class="line">    city      varchar2(10),</span><br><span class="line">    state     varchar2(2),</span><br><span class="line">    zip       number,</span><br><span class="line">    primary key (empno)</span><br><span class="line">)</span><br><span class="line">    organization index</span><br><span class="line"></span><br><span class="line">insert into heap_addresses</span><br><span class="line">select object_id, &#x27;WORK&#x27;, &#x27;123street&#x27;, &#x27;washington&#x27;, &#x27;DC&#x27;, 20123</span><br><span class="line">from all_objects;</span><br><span class="line"></span><br><span class="line">insert into iot_addresses</span><br><span class="line">select object_id, &#x27;WORK&#x27;, &#x27;123street&#x27;, &#x27;washington&#x27;, &#x27;DC&#x27;, 20123</span><br><span class="line">from all_objects;</span><br></pre></td></tr></table></figure>

<p>下面是简单的查询性能比较。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from heap_addresses where empno = 22;</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:00.29</span><br><span class="line"></span><br><span class="line">Execution Plan</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">Plan hash value: 128237854</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">| Id  | Operation                   | Name           | Rows  | Bytes | Cost (%CPU)| Time     |</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">|   0 | SELECT STATEMENT            |                |     1 |    50 |     1   (0)| 00:00:01 |</span><br><span class="line">|   1 |  TABLE ACCESS BY INDEX ROWID| HEAP_ADDRESSES |     1 |    50 |     1   (0)| 00:00:01 |</span><br><span class="line">|*  2 |   INDEX UNIQUE SCAN         | SYS_C008415    |     1 |       |     1   (0)| 00:00:01 |</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Predicate Information (identified by operation id):</span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">   2 - access(&quot;EMPNO&quot;=22)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Statistics</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">          2  recursive calls</span><br><span class="line">          3  db block gets</span><br><span class="line">          7  consistent gets</span><br><span class="line">          0  physical reads</span><br><span class="line">        716  redo size</span><br><span class="line">        935  bytes sent via SQL*Net to client</span><br><span class="line">         83  bytes received via SQL*Net from client</span><br><span class="line">          1  SQL*Net roundtrips to/from client</span><br><span class="line">          0  sorts (memory)</span><br><span class="line">          0  sorts (disk)</span><br><span class="line">          1  rows processed</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from iot_addresses where empno = 22;</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:00.33</span><br><span class="line"></span><br><span class="line">Execution Plan</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">Plan hash value: 268113143</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line">| Id  | Operation         | Name              | Rows  | Bytes | Cost (%CPU)| Time     |</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line">|   0 | SELECT STATEMENT  |                   |     1 |    50 |     1   (0)| 00:00:01 |</span><br><span class="line">|*  1 |  INDEX UNIQUE SCAN| SYS_IOT_TOP_72627 |     1 |    50 |     1   (0)| 00:00:01 |</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Predicate Information (identified by operation id):</span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">   1 - access(&quot;EMPNO&quot;=22)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Statistics</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">          1  recursive calls</span><br><span class="line">          0  db block gets</span><br><span class="line">          4  consistent gets</span><br><span class="line">          0  physical reads</span><br><span class="line">        140  redo size</span><br><span class="line">       1084  bytes sent via SQL*Net to client</span><br><span class="line">        108  bytes received via SQL*Net from client</span><br><span class="line">          2  SQL*Net roundtrips to/from client</span><br><span class="line">          0  sorts (memory)</span><br><span class="line">          0  sorts (disk)</span><br><span class="line">          1  rows processed</span><br></pre></td></tr></table></figure>

<p>索引组织表的逻辑读是4而普通表的逻辑读是7，另外普通表读取主键索引后，为了获取索引列以外的列信息，产生了回表<code>TABLE ACCESS BY INDEX ROWID</code>，而索引组织表没有。<br><strong>索引组织表最大的特点就是，表就是索引，索引就是表，这是一种很特别的设计，所以无须访问表。</strong><br>不过这种设计的表的更新要比普通表开销更大。因为表要和索引一样有序地排列，更新负担将会非常严重。<br>因此这种设计一般适用在很少更新、频繁读的应用场合，比如配置表，这种表数据一般很少变动，却大量读取。</p>
<h3 id="簇表的介绍及应用"><a href="#簇表的介绍及应用" class="headerlink" title="簇表的介绍及应用"></a>簇表的介绍及应用</h3><p>普通表还有一点缺陷，就是ORDER BY语句中的排序不可避免。<br>实际上有序族表可以避免排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Drop table cust_orders;</span><br><span class="line">Drop cluster shc;</span><br><span class="line"></span><br><span class="line">CREATE CLUSTER shc</span><br><span class="line">(</span><br><span class="line">    cust_id NUMBER,</span><br><span class="line">    order_dt timestamp SORT</span><br><span class="line">)</span><br><span class="line">HASHKEYS 10000</span><br><span class="line">HASH IS cust_id</span><br><span class="line">SIZE 8192</span><br><span class="line"></span><br><span class="line">CREATE TABLE cust_orders</span><br><span class="line">(</span><br><span class="line">    cust_id      number,</span><br><span class="line">    order_dt     timestamp SORT,</span><br><span class="line">    order_number number,</span><br><span class="line">    username     varchar2(30),</span><br><span class="line">    ship_addr    number,</span><br><span class="line">    bill_addr    number,</span><br><span class="line">    invoice_num  number</span><br><span class="line">)</span><br><span class="line">    CLUSTER shc (cust_id, order_dt)</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; set autotrace traceonly explain</span><br><span class="line">SQL&gt; variable x number</span><br><span class="line">SQL&gt; select cust_id,order_dt,order_number from cust_orders where cust_id =:x order by order_dt;</span><br><span class="line">Elapsed: 00:00:00.31</span><br><span class="line"></span><br><span class="line">Execution Plan</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">Plan hash value: 465084913</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">| Id  | Operation         | Name        | Rows  | Bytes | Cost (%CPU)|</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">|   0 | SELECT STATEMENT  |             |     1 |    39 |     0   (0)|</span><br><span class="line">|*  1 |  TABLE ACCESS HASH| CUST_ORDERS |     1 |    39 |            |</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Predicate Information (identified by operation id):</span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">   1 - access(&quot;CUST_ID&quot;=TO_NUMBER(:X))</span><br><span class="line"></span><br><span class="line">Note</span><br><span class="line">-----</span><br><span class="line">   - dynamic statistics used: dynamic sampling (level=2)</span><br></pre></td></tr></table></figure>

<p>关于避免排序，还有另外一种方法，也是更常见的方法：排序列正好是索引列时，可避免排序。<br>关于索引避免排序这个知识，也会在下一章与索引相关的部分做详细的介绍。<br>簇表和索引组织表一样，由于结构的特殊导致更新操作开销非常大，所以也需要谨慎使用。</p>

                </div>

                
                        
<div class="post-copyright-info-container border-box">
    <div class="copyright-info-content border-box">
        <div class="copyright-info-top border-box">
            <div class="copyright-post-title border-box text-ellipsis">
                《收获，不止Oracle》读书笔记上篇-表设计
            </div>

            <div class="copyright-post-link border-box text-ellipsis">
                读书笔记/读书笔记/《收获，不止Oracle》读书笔记上篇-表设计/
            </div>
        </div>

        <div class="copyright-info-bottom border-box">
            <div class="copyright-post-author bottom-item">
                <div class="type">
                    作者
                </div>
                <div class="content">咕咕咕</div>
            </div>

            <div class="post-time bottom-item">
                <div class="type">
                    发布于
                </div>
                <div class="content">2024-08-01 10:36</div>
            </div>


            <div class="post-license bottom-item">
                <div class="type">
                    许可
                </div>
                <div class="content tooltip" data-tooltip-content="CC BY-NC-SA 4.0">
                    <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans">
                        <i class="fa-brands fa-creative-commons"></i>
                        <i class="fa-brands fa-creative-commons-by"></i>
                        <i class="fa-brands fa-creative-commons-nc"></i>
                        <i class="fa-brands fa-creative-commons-sa"></i>
                    </a>
                </div>
            </div>
        </div>

        <i class="copyright-bg fa-solid fa-copyright"></i>
    </div>
    <div class="copy-copyright-info flex-center tooltip" data-tooltip-content="复制版权信息" data-tooltip-offset-y="-2px">
        <i class="fa-solid fa-copy"></i>
    </div>
</div>

                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                            <ul class="post-tags-box border-box">
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
                                    </li>
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B/">《收获，不止Oracle》</a>
                                    </li>
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/Oracle/">Oracle</a>
                                    </li>
                                
                            </ul>
                        
                    </div>
                    <div>
                        
                            <div class="post-share-container border-box">
    <ul class="share-list-wrap border-box">
        <li class="qq share-item border-box flex-center tooltip"
            data-tooltip-content="分享到 QQ"
        >
            <i class="fa-brands fa-qq"></i>
        </li>
        <li class="wechat share-item border-box flex-center tooltip tooltip-img"
            data-tooltip-content="分享到微信"
            data-tooltip-img-tip="微信扫一扫"
            data-tooltip-img-style="background-color: #fff; top: -10px; padding: 0.6rem 0.6rem 0.1rem 0.6rem;"
        >
            <i class="fa-brands fa-weixin"></i>
        </li>
        <li class="weibo share-item border-box flex-center tooltip"
            data-tooltip-content="分享到微博"
        >
            <i class="fa-brands fa-weibo"></i>
        </li>
    </ul>
</div>

                        
                    </div>
                </div>

                
                    <div class="reward-author-container border-box flex-center">
    <div class="reward-btn keep-button border-box flex-center tooltip tooltip-img"
            data-tooltip-content="谢谢你请我喝可乐~"
            data-tooltip-img-url="/images/thanks.png"
            data-tooltip-img-trigger="click"
            data-tooltip-img-style="top: -8px;"
    >
        <i class="fa-solid fa-hand-holding-heart"></i>
    </div>
</div>

                

                
                    <div class="post-nav border-box">
                        
                            <div class="prev-post">
                                <a class="prev"
                                   rel="prev"
                                   href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E7%B4%A2%E5%BC%95/"
                                   title="《收获，不止Oracle》读书笔记上篇-索引"
                                >
                                    <span class="left arrow-icon flex-center">
                                        <i class="fas fa-chevron-left"></i>
                                    </span>
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">《收获，不止Oracle》读书笔记上篇-索引</span>
                                        <span class="post-nav-item">上一篇</span>
                                    </span>
                                </a>
                            </div>
                        
                        
                            <div class="next-post">
                                <a class="next"
                                   rel="next"
                                   href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E9%80%BB%E8%BE%91%E4%BD%93%E7%B3%BB/"
                                   title="《收获，不止Oracle》读书笔记上篇-逻辑体系"
                                >
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">《收获，不止Oracle》读书笔记上篇-逻辑体系</span>
                                        <span class="post-nav-item">下一篇</span>
                                    </span>
                                    <span class="right arrow-icon flex-center">
                                        <i class="fas fa-chevron-right"></i>
                                    </span>
                                </a>
                            </div>
                        
                    </div>
                

                
                    


    <div class="comments-container border-box">
        <div id="comments-anchor" class="comment-area-title border-box">
            <i class="fas fa-comments"></i>&nbsp;评论
        </div>
        <div class="comment-plugin-fail border-box">
    <span class="fail-tip">评论插件加载失败</span>
    <button class="reload keep-button">点击重新加载</button>
</div>
<div class="comment-plugin-loading flex-center border-box">
    <i class="loading-icon fa-solid fa-spinner fa-spin"></i>
    <span class="load-tip">正在加载评论插件</span>
</div>
<script data-pjax>
  window.KeepCommentPlugin = {}
  window.KeepCommentPlugin.hideLoading = () => {
    const cplDom = document.querySelector('.comments-container .comment-plugin-loading')
    cplDom.style.display = 'none'
  }
  window.KeepCommentPlugin.loadFailHandle = () => {
    window.KeepCommentPlugin.hideLoading()
    const cpfDom = document.querySelector('.comments-container .comment-plugin-fail')
    cpfDom.style.display = 'flex'
    cpfDom.querySelector('.reload').addEventListener('click', () => {
      window.location.reload()
    })
  }
</script>

        
            

    <div class="giscus-comments-container">
        <div class="giscus" id="giscus"></div>
        <script data-pjax
                onerror="window.KeepCommentPlugin.loadFailHandle()"
        >
          if (!window.KeepCommentPlugin?.getGiscusTheme) {
            window.KeepCommentPlugin.getGiscusTheme = () => {
              return document.body.classList.contains('dark-mode') ? 'dark_dimmed' : 'light_tritanopia'
            }
          }

          if (!window.KeepCommentPlugin?.changeGiscusTheme) {
            window.KeepCommentPlugin.changeGiscusTheme = () => {
              const iframe = document.querySelector('iframe.giscus-frame')
              iframe && iframe.contentWindow.postMessage({
                giscus: {
                  setConfig: {
                    theme: window.KeepCommentPlugin.getGiscusTheme()
                  }
                }
              }, 'https://giscus.app')
            }
          }

          if (!window.KeepCommentPlugin?.initGiscus) {
            window.KeepCommentPlugin.initGiscus = () => {
              const script = document.createElement('script')
              script.async = true
              script.src = 'https://giscus.app/client.js'
              script.setAttribute('data-repo', 'Cooooing/Cooooing.github.io')
              script.setAttribute('data-repo-id', 'R_kgDOHQal_w')
              script.setAttribute('data-category', 'Announcements')
              script.setAttribute('data-category-id', 'DIC_kwDOHQal_84CjZo6')
              script.setAttribute('data-reactions-enabled', '1')
              script.setAttribute('data-lang', 'zh-CN')
              script.setAttribute('data-mapping', 'pathname')
              script.setAttribute('data-strict', '0')
              script.setAttribute('data-emit-metadata', '0')
              script.setAttribute('data-input-position', 'top')
              script.setAttribute('crossorigin', 'anonymous')
              script.setAttribute('loading', 'lazy')
              script.setAttribute('data-theme', window.KeepCommentPlugin.getGiscusTheme())
              document.querySelector('.giscus-comments-container').appendChild(script)
              script.onerror = () => {
                window.KeepCommentPlugin.loadFailHandle()
              }
              script.onload = () => {
                window.KeepCommentPlugin.hideLoading()
              }
              const toggleThemeBtn = document.querySelector('.tool-toggle-theme-mode')
              toggleThemeBtn && toggleThemeBtn.addEventListener('click', () => {
                window.KeepCommentPlugin.changeGiscusTheme()
              })
            }
          }

          if ('true' === "true") {
            setTimeout(() => {
              window.KeepCommentPlugin.initGiscus()
            }, 1000)
          } else {
            window.addEventListener("DOMContentLoaded", window.KeepCommentPlugin.initGiscus)
          }
        </script>
    </div>


        
    </div>





                
            </div>
        </div>

        
            <div class="pc-post-toc left-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%A5%9D%E8%B4%BA%EF%BC%8C%E8%A1%A8%E8%AE%BE%E8%AE%A1%E6%88%90%E5%B0%B1%E8%8B%B1%E9%9B%84"><span class="nav-text">第四章 - 祝贺，表设计成就英雄</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%A0%86%E8%A1%A8%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84"><span class="nav-text">普通堆表不足之处</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97%E5%BC%80%E9%94%80%E8%BE%83%E5%A4%A7"><span class="nav-text">表更新日志开销较大</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Delete%E6%97%A0%E6%B3%95%E9%87%8A%E6%94%BE%E7%A9%BA%E9%97%B4"><span class="nav-text">Delete无法释放空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E8%AE%B0%E5%BD%95%E5%A4%AA%E5%A4%A7%E6%A3%80%E7%B4%A2%E8%BE%83%E6%85%A2"><span class="nav-text">表记录太大检索较慢</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%9B%9E%E8%A1%A8%E8%AF%BB%E5%BC%80%E9%94%80%E5%BE%88%E5%A4%A7"><span class="nav-text">索引回表读开销很大</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E6%8F%92%E5%85%A5%E5%8D%B4%E9%9A%BE%E4%BB%A5%E6%9C%89%E5%BA%8F%E8%AF%BB%E5%87%BA"><span class="nav-text">有序插入却难以有序读出</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A5%87%E7%89%B9%E7%9A%84%E5%85%A8%E5%B1%80%E4%B8%B4%E6%97%B6%E8%A1%A8"><span class="nav-text">奇特的全局临时表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E4%B8%B4%E6%97%B6%E8%A1%A8%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">全局临时表的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E5%90%84%E7%B1%BBDML%E7%9A%84REDO%E6%97%A5%E5%BF%97%E9%87%8F"><span class="nav-text">观察各类DML的REDO日志量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E4%B8%B4%E6%97%B6%E8%A1%A8%E4%B8%A4%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-text">全局临时表两大特性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%AB%98%E6%95%88%E5%88%A0%E9%99%A4%E8%AE%B0%E5%BD%95"><span class="nav-text">高效删除记录</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E4%BC%9A%E8%AF%9D%E7%8B%AC%E7%AB%8B"><span class="nav-text">不同会话独立</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A5%9E%E9%80%9A%E5%B9%BF%E5%A4%A7%E7%9A%84%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="nav-text">神通广大的分区表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="nav-text">分区表类型及原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4%E5%88%86%E5%8C%BA"><span class="nav-text">范围分区</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E5%88%86%E5%8C%BA"><span class="nav-text">列表分区</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E5%88%86%E5%8C%BA%EF%BC%88Hash%E5%88%86%E5%8C%BA%EF%BC%89"><span class="nav-text">散列分区（Hash分区）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E5%88%86%E5%8C%BA"><span class="nav-text">组合分区</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E5%8E%9F%E7%90%86"><span class="nav-text">分区原理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8%E6%9C%80%E5%AE%9E%E7%94%A8%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-text">分区表最实用的特性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%AB%98%E6%95%88%E7%9A%84%E5%88%86%E5%8C%BA%E6%B8%85%E9%99%A4"><span class="nav-text">高效的分区清除</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%BA%E5%A4%A7%E7%9A%84%E5%88%86%E5%8C%BA%E6%93%8D%E4%BD%9C"><span class="nav-text">强大的分区操作</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%86%E5%8C%BA-truncate"><span class="nav-text">分区 truncate</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E6%95%B0%E6%8D%AE%E8%BD%AC%E7%A7%BB"><span class="nav-text">分区数据转移</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E5%88%87%E5%89%B2"><span class="nav-text">分区切割</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E5%90%88%E5%B9%B6"><span class="nav-text">分区合并</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E7%9A%84%E5%A2%9E%E4%B8%8E%E5%88%A0"><span class="nav-text">分区的增与删</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="nav-text">分区索引类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E7%B4%A2%E5%BC%95"><span class="nav-text">全局索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E7%B4%A2%E5%BC%95"><span class="nav-text">局部索引</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8%E7%9B%B8%E5%85%B3%E9%99%B7%E9%98%B1"><span class="nav-text">分区表相关陷阱</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E9%A2%91%E9%A2%91%E5%A4%B1%E6%95%88"><span class="nav-text">索引频频失效</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89%E7%B4%A2%E5%BC%95%E5%8F%8D%E8%80%8C%E6%95%88%E7%8E%87%E6%9B%B4%E4%BD%8E"><span class="nav-text">有索引反而效率更低</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A0%E6%B3%95%E5%BA%94%E7%94%A8%E5%88%86%E5%8C%BA%E6%9D%A1%E4%BB%B6"><span class="nav-text">无法应用分区条件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E8%B6%A3%E7%9A%84%E7%B4%A2%E5%BC%95%E7%BB%84%E7%BB%87%E8%A1%A8"><span class="nav-text">有趣的索引组织表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B0%87%E8%A1%A8%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%BA%94%E7%94%A8"><span class="nav-text">簇表的介绍及应用</span></a></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="border-box website-info-box default">
        
            <div class="copyright-info info-item default">
                &copy;&nbsp;<span>2022</span>&nbsp;-&nbsp;2025
                
                    &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">咕咕咕</a>
                
            </div>

            <div class="theme-info info-item default">
                由&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;驱动&nbsp;&&nbsp;主题&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a>
            </div>

            

            
        

        <div style="color:var(--text-color-4);"><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>(～￣▽￣)～<script src="/js/lifeTime.js"></script></div>
        <a href="https://icp.gov.moe/?keyword=20222450" target="_blank">萌ICP备20222450号</a>


        <div class="count-item info-item default">
            
                <span class="count-box border-box word">
                    <span class="item-type border-box">总字数</span>
                    <span class="item-value border-box word">361.3k</span>
                </span>
            

            
                <span class="count-box border-box uv">
                    <span class="item-type border-box">访客数</span>
                    <span class="item-value border-box uv" id="busuanzi_value_site_uv"></span>
                </span>
            

            
                <span class="count-box border-box pv">
                    <span class="item-type border-box">访问量</span>
                    <span class="item-value border-box pv" id="busuanzi_value_site_pv"></span>
                </span>
            
        </div>

        <div id="aplayer">
          <meting-js
                  server="netease"
                  type="playlist"
                  id="7345595717"
                  fixed="true"
                  mini="true"
                  autoplay="false"
                  listFolded="true"
                  order="random"
                  preload="none">
          </meting-js>
        </div>
            <br>
            <br>
            <br>
    </div>

</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools left-toc">
            <div class="post-tools-container border-box">
    <ul class="tools-list border-box">
        <!-- PC TOC show toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- PC go comment -->
        
            <li class="tools-item flex-center go-to-comments">
                <i class="fas fa-comment"></i>
                <span class="post-comments-count"></span>
            </li>
        
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-toggle-theme-mode flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        
            <li class="tools-item toggle-show-toc-tablet flex-center">
                <i class="fas fa-list"></i>
            </li>
        

        
            <li class="tools-item go-to-comments-tablet flex-center">
                <i class="fas fa-comment"></i>
            </li>
        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

    <!-- tablet toc -->
    
        <div class="tablet-post-toc-mask">
            <div class="tablet-post-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%A5%9D%E8%B4%BA%EF%BC%8C%E8%A1%A8%E8%AE%BE%E8%AE%A1%E6%88%90%E5%B0%B1%E8%8B%B1%E9%9B%84"><span class="nav-text">第四章 - 祝贺，表设计成就英雄</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%A0%86%E8%A1%A8%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84"><span class="nav-text">普通堆表不足之处</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97%E5%BC%80%E9%94%80%E8%BE%83%E5%A4%A7"><span class="nav-text">表更新日志开销较大</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Delete%E6%97%A0%E6%B3%95%E9%87%8A%E6%94%BE%E7%A9%BA%E9%97%B4"><span class="nav-text">Delete无法释放空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E8%AE%B0%E5%BD%95%E5%A4%AA%E5%A4%A7%E6%A3%80%E7%B4%A2%E8%BE%83%E6%85%A2"><span class="nav-text">表记录太大检索较慢</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%9B%9E%E8%A1%A8%E8%AF%BB%E5%BC%80%E9%94%80%E5%BE%88%E5%A4%A7"><span class="nav-text">索引回表读开销很大</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E6%8F%92%E5%85%A5%E5%8D%B4%E9%9A%BE%E4%BB%A5%E6%9C%89%E5%BA%8F%E8%AF%BB%E5%87%BA"><span class="nav-text">有序插入却难以有序读出</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A5%87%E7%89%B9%E7%9A%84%E5%85%A8%E5%B1%80%E4%B8%B4%E6%97%B6%E8%A1%A8"><span class="nav-text">奇特的全局临时表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E4%B8%B4%E6%97%B6%E8%A1%A8%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">全局临时表的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E5%90%84%E7%B1%BBDML%E7%9A%84REDO%E6%97%A5%E5%BF%97%E9%87%8F"><span class="nav-text">观察各类DML的REDO日志量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E4%B8%B4%E6%97%B6%E8%A1%A8%E4%B8%A4%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-text">全局临时表两大特性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%AB%98%E6%95%88%E5%88%A0%E9%99%A4%E8%AE%B0%E5%BD%95"><span class="nav-text">高效删除记录</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E4%BC%9A%E8%AF%9D%E7%8B%AC%E7%AB%8B"><span class="nav-text">不同会话独立</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A5%9E%E9%80%9A%E5%B9%BF%E5%A4%A7%E7%9A%84%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="nav-text">神通广大的分区表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="nav-text">分区表类型及原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4%E5%88%86%E5%8C%BA"><span class="nav-text">范围分区</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E5%88%86%E5%8C%BA"><span class="nav-text">列表分区</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E5%88%86%E5%8C%BA%EF%BC%88Hash%E5%88%86%E5%8C%BA%EF%BC%89"><span class="nav-text">散列分区（Hash分区）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E5%88%86%E5%8C%BA"><span class="nav-text">组合分区</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E5%8E%9F%E7%90%86"><span class="nav-text">分区原理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8%E6%9C%80%E5%AE%9E%E7%94%A8%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-text">分区表最实用的特性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%AB%98%E6%95%88%E7%9A%84%E5%88%86%E5%8C%BA%E6%B8%85%E9%99%A4"><span class="nav-text">高效的分区清除</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%BA%E5%A4%A7%E7%9A%84%E5%88%86%E5%8C%BA%E6%93%8D%E4%BD%9C"><span class="nav-text">强大的分区操作</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%86%E5%8C%BA-truncate"><span class="nav-text">分区 truncate</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E6%95%B0%E6%8D%AE%E8%BD%AC%E7%A7%BB"><span class="nav-text">分区数据转移</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E5%88%87%E5%89%B2"><span class="nav-text">分区切割</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E5%90%88%E5%B9%B6"><span class="nav-text">分区合并</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E7%9A%84%E5%A2%9E%E4%B8%8E%E5%88%A0"><span class="nav-text">分区的增与删</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="nav-text">分区索引类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E7%B4%A2%E5%BC%95"><span class="nav-text">全局索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E7%B4%A2%E5%BC%95"><span class="nav-text">局部索引</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8%E7%9B%B8%E5%85%B3%E9%99%B7%E9%98%B1"><span class="nav-text">分区表相关陷阱</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E9%A2%91%E9%A2%91%E5%A4%B1%E6%95%88"><span class="nav-text">索引频频失效</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89%E7%B4%A2%E5%BC%95%E5%8F%8D%E8%80%8C%E6%95%88%E7%8E%87%E6%9B%B4%E4%BD%8E"><span class="nav-text">有索引反而效率更低</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A0%E6%B3%95%E5%BA%94%E7%94%A8%E5%88%86%E5%8C%BA%E6%9D%A1%E4%BB%B6"><span class="nav-text">无法应用分区条件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E8%B6%A3%E7%9A%84%E7%B4%A2%E5%BC%95%E7%BB%84%E7%BB%87%E8%A1%A8"><span class="nav-text">有趣的索引组织表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B0%87%E8%A1%A8%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%BA%94%E7%94%A8"><span class="nav-text">簇表的介绍及应用</span></a></li></ol></li></ol>
    </div>
</div>

            </div>
        </div>
    
</main>



<!-- common -->

<script src="/js/utils.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/toggle-theme.js"></script>

<script src="/js/code-block.js"></script>

<script src="/js/main.js"></script>

<script src="/js/libs/anime.min.js"></script>


<!-- local-search -->

    
<script src="/js/local-search.js"></script>



<!-- lazyload -->

    
<script src="/js/lazyload.js"></script>



<div class="pjax">
    
        <!-- post-helper -->
        
<script src="/js/post/post-helper.js"></script>


        <!-- toc -->
        
            
<script src="/js/post/toc.js"></script>

        

        <!-- copyright-info -->
        
            
<script src="/js/post/copyright-info.js"></script>

        

        <!-- share -->
        
            
<script src="/js/post/share.js"></script>

        
    

    <!-- category-page -->
    

    <!-- links-page -->
    

    <!-- photos-page -->
    
</div>

<!-- mermaid -->


<!-- pjax -->

    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax',
                '#aplayer',
                '#canvas_sakura'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart()
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd()
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'))
            KEEP.initExecute()
        });
    });
</script>




    
        
            
<script class="custom-inject-js" src="/js/APlayer.min.js" data-pjax></script>

        
    
        
            
<script class="custom-inject-js" src="/js/Meting.min.js" data-pjax></script>

        
    
        
            
<script class="custom-inject-js" src="/js/leaves.js" data-pjax></script>

        
    



</body>
</html>
